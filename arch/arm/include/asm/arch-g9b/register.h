// ----------------------------------------------------------------------
// This file is automatically generated from the script:
// 
// ./create_headers_from_register_map_h.pl
// 
// and was applied to the file
// 
// ./register_map.h
// 
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
// 

//Generated by python script

#ifdef REGISTER_H
#else
#define REGISTER_H


#include "dos_cbus_register.h"
#define Wr(addr, data) *(volatile unsigned long *)(addr)=(data)
#define Rd(addr) *(volatile unsigned long *)(addr)

#define Is_dos_reg(addr) ((((addr)>>8)==0x09 || ((addr)>>8)==0x0c || ((addr)>>8)==0x0e || ((addr)>>8)==0x03)? 1 : 0)
#define Wr_cbus(addr, data) *(volatile unsigned long *)((Is_dos_reg(addr)? 0xd0050000:0xc1100000)|((addr)<<2))=(data)
#define Rd_cbus(addr) *(volatile unsigned long *)((Is_dos_reg(addr)? 0xd0050000:0xc1100000)|((addr)<<2))
#define Wr_reg_bits(reg, val, start, len) \
  Wr_cbus(reg, ((Rd_cbus(reg) & ~(((1L<<(len))-1)<<(start))) | ((unsigned int)(val) << (start))))

//
// Reading file:  ./register_map.h
//
// synopsys translate_off
// synopsys translate_on
//
// Reading file:  stb_define.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  STB_CBUS_BASE = 0x16
// -----------------------------------------------
// There are two instantiations under one CBUS slave.  Each CBUS slave can support
// 256 registers.  Each demux is allocated 128 registers so set the offset in
// the middle
// Copy this define but don't add a base address
#define SECOND_DEMUX_OFFSET_0  0x50
#define THIRD_DEMUX_OFFSET_0   0xa0
//========================================================================
//  STB TOP Registers				    (8'hf0 - 8'hf7)
//========================================================================
// bit 30:28 -- ciplus_o_sel
// bit 27:26 -- ciplus_i_sel
// bit 25 -- use FAIL fro TS2
// bit 24 -- use FAIL fro TS1
// bit 23 -- use FAIL fro TS0
// bit 22 -- invert fec_error for S2P1
// bit 21 -- invert fec_data for S2P1
// bit 20 -- invert fec_sync for S2P1
// bit 19 -- invert fec_valid for S2P1
// bit 18 -- invert fec_clk for S2P1
// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
// Bit 15 -- enable_des_pl_clk
// Bit 14:13 -- reserved
// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
// bit 7 -- enable_des_pl
// bit 6 -- invert fec_error for S2P0
// bit 5 -- invert fec_data for S2P0
// bit 4 -- invert fec_sync for S2P0
// bit 3 -- invert fec_valid for S2P0
// bit 2 -- invert fec_clk for S2P0
// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
#define STB_TOP_CONFIG                             0x16f0
// 31:28 - s2p1_clk_div
// 27:24 - s2p0_clk_div
// 23    - s2p1_disable
// 22    - s2p0_disable
// 21    - Reserved
// 20 -- TS_OUT_error_INVERT
// 19 -- TS_OUT_data_INVERT
// 18 -- TS_OUT_sync_INVERT
// 17 -- TS_OUT_valid_INVERT
// 16 -- TS_OUT_clk_INVERT
// 15:8 -- TS_package_length_sub_1 (default : 187)
//  7:0 -- fec_sync_byte (default : 0x47)
#define TS_TOP_CONFIG                              0x16f1
// Bit 23:16 -- file_m2ts_skip_bytes
// Bit 15:8 -- des_out_dly
// Bit 7:6 -- transport_scrambling_control_odd // should be 3
// Bit 5 -- ts_hiu_enable
// Bit 4:0 -- fec_clk_div
#define TS_FILE_CONFIG                             0x16f2
// Bit 13:8 -- des ts pl state   -- Read Only
// Bit 3:0 PID index to 8 PID to get key-set
// auto increse after TS_PL_PID_DATA read/write
#define TS_PL_PID_INDEX                            0x16f3
// Bit 13 -- PID match disble
// Bit 12:0 -- PID
#define TS_PL_PID_DATA                             0x16f4
#define COMM_DESC_KEY0                             0x16f5
#define COMM_DESC_KEY1                             0x16f6
#define COMM_DESC_KEY_RW                           0x16f7
// CI+ Register defines
// Bits[31:0] of the key
#define CIPLUS_KEY0                                0x16f8
// Bits[63:32] of the key
#define CIPLUS_KEY1                                0x16f9
// Bits[95:64] of the key
#define CIPLUS_KEY2                                0x16fa
// Bits[127:96] of the key
#define CIPLUS_KEY3                                0x16fb
// bit[5] write AES IV B value
// bit[4] write AES IV A value
// bit[3] write AES B key
// bit[2] write AES A key
// bit[1] write DES B key
// bit[0] write DES A key
#define CIPLUS_KEY_WR                              0x16fc
// [15:8]   TS out delay.  This controls the rate at which the CIplus module drives TS out
// [3]      General enable for the ciplus module
// [2]      AES CBC disable (default should be 0 to enable AES CBC)
// [1]      AES Enable
// [0]      DES Eanble
#define CIPLUS_CONFIG                              0x16fd
// bit[31:28] AES IV endian
// bit[27:24] AES message out endian
// bit[23:20] AES message in endian
// bit[19:16] AES key endian
// bit[15:11]  unused
// bit[10:8]  DES message out endian
// bit[6:4]   DES message in endian
// bit[2:0]   DES key endian
#define CIPLUS_ENDIAN                              0x16fe
//
// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
//        Instead, since the demux has multiple instances (and many registers) use a separate
//        script to create a separate stb_define.h for C-code.  
//========================================================================
//  STB Registers				    (8'h00 - 8'h4f)
//
//========================================================================
// STB registers are 8'h0x
// Bit 15:0 -- version number : 0x0002  (v0.01)
// Bit 15 -- fec_core_select 1 - select descramble output
// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File 
// Bit 11 -- FEC_CLK
// Bit 10 -- SOP
// Bit 9 -- D_VALID
// Bit 8 -- D_FAIL
// Bit 7:0 -- D_DATA 7:0
// bit 31 -- enable_free_clk_fec_data_valid
// bit 30 -- enable_free_clk_stb_reg
// bit 29 -- reserved
// bit 28 -- disable_pre_incomplete_section_fix
// bit 27 -- pointer_field_multi_pre_en
// bit 26 -- ignore_pre_incomplete_section
// bit 25 -- video2_enable
// bit 24:22 -- video2_type
// bit 21 -- do_not_trust_pes_package_length
// bit 20 (bit 4) -- Bypass use recoder path
// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
// bit 18 (bit 2) -- Disable Splicing
// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
// Bit 15 - do not trust section length
// Bit 14 - om cmd push even zero
// Bit 13 - reserved
// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
// Bit 11 - discard_av_package -- for ts_recorder use only 
// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
// Bit 9 - ts_recorder_enable
// Bit 8 - (table_id == 0xff) means section_end
// Bit 7 - do not send uncomplete section
// Bit 6 - do not discard duplicate package
// Bit 5 - search SOP when trasport_error_indicator
// Bit 4 - stb demux enable
// Bit 3 - do not reset state machine on SOP
// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
// Bit 1 - do not use SOP input ( check FEC sync byte instead )
// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
// bit 15:8 demux package length - 1 ( default : 187 )
// bit 7:0 default is 0x47
// bit 31:16 -- filter memory write data hi[31:16]
// bit 15:0 -- filter memory write data low [15:0]
// bit 31:24 -- advanced setting hi
// bit 23:16 -- advanced setting low
// bit 15 -- filter memory write data request
// bit 7:0 -- filter memory write addr
// bit 13:8 demux state  -- read only
// bit 7:4 -- maxnum section filter compare address
// bit 3:0 -- maxnum PID filter compare address
// bit 15 - transport_error_indicator
// bit 14 - payload_unit_start_indicator
// bit 13 - transport_priority
// bit 12:0 - PID
// bit 7:6 transport_scrambling_control
// bit 5:4 adaptation_field_control
// bit 3:0 continuity_counter
// bit 15:12 -- om_cmd_count (read only)
// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
// bit   5:3 -- type_stb_om_w_rd (read only)
// bit     2 -- unit_start_stb_om_w_rd (read only)
// bit     1 -- om_cmd_overflow (read only)
// bit     0 -- om_cmd_pending (read) 
// bit     0 -- om_cmd_read_finished (write)
// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
// bit 11:0 -- offset for section data
// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
// bit 7:4 -- section buffer size for group 1
// bit 11:8 -- section buffer size for group 2
// bit 15:12 -- section buffer size for group 3
// section buffer busy status for buff 31:0 ( Read Only )
// section buffer write status for buff 31:0 -- Read
// clear buffer status ( buff READY and BUSY ) -- write
// bit 4:0 -- SEC_BUFFER_INDEX   RW
// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
// bit 14 -- output_section_buffer_valid
// bit 15 -- section_reset_busy (Read Only)
// bit 9:5 -- BYPASS PID number
// bit 4:0 -- PCR PID number
// bit 15:0 -- stream_id filter bit enable
// bit 7:0 -- stream_id filter target
// bit 12 -- PCR_EN
// bit 11:0 -- PCR90K_DIV
// bit 15:0 -- PCR[31:0] R/W
// bit 15:0 -- VPTS[31:0] R/W
// bit 15:0 -- VDTS[31:0] R/W
// bit 15:0 -- APTS[31:0] R/W
// bit 15:0 -- SPTS[31:0] R/W
// read -- status, write 1 clear status
// bit 15 -- SUB_PTS[32]
// bit 14 -- AUDIO_PTS[32]
// bit 13 -- VIDEO_DTS[32]
// bit 12 -- VIDEO_PTS[32]
// bit 3 -- sub_pts_ready
// bit 2 -- audio_pts_ready
// bit 1 -- video_dts_ready
// bit 0 -- video_pts_ready
// bit 3:0 --
//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0] 
//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
//  2 -- pes_package_bytes_left[15:0]
//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
// 
// read only
// default : 0x807f
// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40) 
// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
// 15:0  WRITE 1 CLEAR to clear interrupt source
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int 
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready 
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN 
// Bit 5:3 - demux om write endian control for bypass
// Bit 2:0 - demux om write endian control for section
// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
// Bit 17:15 - demux om write endian control for SUB_PACKET
// Bit 14:12 - demux om write endian control for AUDIO_PACKET
// Bit 11:9  - demux om write endian control for VIDEO_PACKET
// 
// When Bit 31 - 0 write will indicate all type else use Bit 8:6
// Bit 8:6 - demux om write endian control for else
// Bit 15:8 -- last_burst_threshold
// Bit 7 -- use hi_bsf interface
// Bit 6:2 - fec_clk_div
// Bit 1 ts_source_sel 
// Bit 0 - Hiu TS generate enable 
// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
// bit 10 -- mask bit for SUB_AHB_DMA_EN
// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
// bit 8 -- mask bit for SECTION_AHB_DMA_EN
// bit 7 -- mask bit for recoder stream
// bit 6:0 -- mask bit for each type
// bit 31:0 -- vb_wr_ptr for video PDTS 
// bit 31:0 -- ab_wr_ptr for audio PDTS
// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
// bit 19:0 -- SB_START (sb_start << 12 == byte address);  
// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun) 
// bit 31:0 -- sb_wr_ptr for sub PES
// bit 31:16 -- ob_wr_ptr for other PES
// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
// bit 19:0 -- OB_START (ob_start << 12 == byte address);  
// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun) 
// bit 31:0 -- ob_wr_ptr for sub PES
// 15:0  DEMUX interrupt MASK
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int 
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready 
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN 
// 31:16 VIDEO PID filter data
//15 -- splicing VIDEO PID change enable 
//14:10 -- VIDEO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only) 
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 31:16 AUDIO PID filter data
//15 -- splicing AUDIO PID change enable 
//14:10 -- AUDIO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only) 
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 23:16 M2TS_SKIP_BYTES
// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
// 7:0  PACKAGE BYTE COUNT (Read Only)
// 15:0 2 bytes strong sync add to PES
// bit 15 -- stb_om_ren
// bit 14:11 -- reserved
// bit  10:0 -- OM_DATA_RD_ADDR
// bit 15:0 -- OM_DATA_RD
// AUTO STOP SETTING for 32 channels
// 4-nbits per channel
// when write
// bit 3 -- set section active
// bit 2:0 -- auto stop after count (0 means never stop)
// when read
// bit 3 -- current active status (1 - active, 0 - stopped )
// bit 2:0 -- count down to auto stop
// section 31:24
// section 23:16
// section 15:8
// section 7:0
// bit 31:0 reset channel status - each bit reset each channel 
// read -- 32 channel status 
// bit 4 -- video_stamp_use_dts
// bit 3 -- audio_stamp_sync_1_en 
// bit 2 -- audio_stamp_insert_en 
// bit 1 -- video_stamp_sync_1_en 
// bit 0 -- video_stamp_insert_en 
// Write : Bit[4:0] secter filter number for reset
// Read  : select according to output_section_buffer_valid : 
//         per bit per section buffer valid status
//         or section_buffer_ignore
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  stb_define.h
//
//
// Reading file:  periphs_reg.h
//
// $periphs/rtl/periphs_core register defines for the 
// APB bus
// -------------------------------------------------------------------
// PSEL Group #0:  0x000 ~ 0xFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS0_CBUS_BASE = 0x20
// -----------------------------------------------
// The following are handled by $periphs/rtl/periphs_reg.v
#define PREG_CTLREG0_ADDR                          0x2000
// ----------------------------
#define PREG_PAD_GPIO6_EN_N                        0x2008
#define PREG_PAD_GPIO6_O                           0x2009
#define PREG_PAD_GPIO6_I                           0x200a
// ----------------------------
// ----------------------------
#define PREG_JTAG_GPIO_ADDR                        0x200b
// ----------------------------
// Pre-defined GPIO addresses
// ----------------------------
#define PREG_PAD_GPIO0_EN_N                        0x200c
#define PREG_PAD_GPIO0_O                           0x200d
#define PREG_PAD_GPIO0_I                           0x200e
// ----------------------------
#define PREG_PAD_GPIO1_EN_N                        0x200f
#define PREG_PAD_GPIO1_O                           0x2010
#define PREG_PAD_GPIO1_I                           0x2011
// ----------------------------
#define PREG_PAD_GPIO2_EN_N                        0x2012
#define PREG_PAD_GPIO2_O                           0x2013
#define PREG_PAD_GPIO2_I                           0x2014
// ----------------------------
#define PREG_PAD_GPIO3_EN_N                        0x2015
#define PREG_PAD_GPIO3_O                           0x2016
#define PREG_PAD_GPIO3_I                           0x2017
// ----------------------------
#define PREG_PAD_GPIO4_EN_N                        0x2018
#define PREG_PAD_GPIO4_O                           0x2019
#define PREG_PAD_GPIO4_I                           0x201a
// ----------------------------
#define PREG_PAD_GPIO5_EN_N                        0x201b
#define PREG_PAD_GPIO5_O                           0x201c
#define PREG_PAD_GPIO5_I                           0x201d
// ----------------------------
// A9 and L2 cache
// ----------------------------
#define A9_STATUS1                                 0x201f
#define A9_CFG0                                    0x2020
#define A9_CFG1                                    0x2021
#define A9_CFG2                                    0x2022
#define A9_PERIPH_BASE                             0x2023
#define A9_L2_REG_BASE                             0x2024
#define A9_L2_STATUS                               0x2025
#define A9_POR_CFG                                 0x2026
#define A9_STATUS2                                 0x2027
#define AXI_REG_EN                                 0x2028
#define A9_CFG3                                    0x2029
#define A9_CFG4                                    0x202a
#define A9_STATUS3                                 0x202b
// ----------------------------
// Pin Mux  (9)
// ----------------------------
#define PERIPHS_PIN_MUX_0                          0x202c
#define PERIPHS_PIN_MUX_1                          0x202d
#define PERIPHS_PIN_MUX_2                          0x202e
#define PERIPHS_PIN_MUX_3                          0x202f
#define PERIPHS_PIN_MUX_4                          0x2030
#define PERIPHS_PIN_MUX_5                          0x2031
#define PERIPHS_PIN_MUX_6                          0x2032
#define PERIPHS_PIN_MUX_7                          0x2033
#define PERIPHS_PIN_MUX_8                          0x2034
#define PERIPHS_PIN_MUX_9                          0x2035
#define PERIPHS_PIN_MUX_10                         0x2036
#define PERIPHS_PIN_MUX_11                         0x2037
#define PERIPHS_PIN_MUX_12                         0x2038
// ----------------------------
// Pad conntrols
// ----------------------------
#define PAD_PULL_UP_REG6                           0x2039
#define PAD_PULL_UP_REG0                           0x203a
#define PAD_PULL_UP_REG1                           0x203b
#define PAD_PULL_UP_REG2                           0x203c
#define PAD_PULL_UP_REG3                           0x203d
#define PAD_PULL_UP_REG4                           0x203e
#define PAD_PULL_UP_REG5                           0x203f
// ----------------------------
// Random (2)
// ----------------------------
#define RAND64_ADDR0                               0x2040
#define RAND64_ADDR1                               0x2041
// ---------------------------
// Ethernet (1)
// ----------------------------
#define PREG_ETHERNET_ADDR0                        0x2042
// ---------------------------
// AM_ANALOG_TOP
// ----------------------------
#define PREG_AM_ANALOG_ADDR                        0x2043
// ---------------------------
// Mali55 (1)
// ----------------------------
#define PREG_MALI_BYTE_CNTL                        0x2044
// ---------------------------
// WIFI (1)
// ----------------------------
#define PREG_WIFI_CNTL                             0x2045
#define PAD_PULL_UP_EN_REG0                        0x2048
#define PAD_PULL_UP_EN_REG1                        0x2049
#define PAD_PULL_UP_EN_REG2                        0x204a
#define PAD_PULL_UP_EN_REG3                        0x204b
#define PAD_PULL_UP_EN_REG4                        0x204c
#define PAD_PULL_UP_EN_REG5                        0x204d
#define PAD_PULL_UP_EN_REG6                        0x204e
// ---------------------------
// SATA 
// ----------------------------
#define PREG_ETH_REG0                              0x2050
#define PREG_ETH_REG1                              0x2051
// `define PREG_SATA_REG2                      8'h52
// `define PREG_SATA_REG3                      8'h53
// `define PREG_SATA_REG4                      8'h54
// `define PREG_SATA_REG5                      8'h55
// ---------------------------
// Generic production test
// ----------------------------
#define PROD_TEST_REG0                             0x2060
#define PROD_TEST_REG1                             0x2061
#define PROD_TEST_REG2                             0x2062
#define PROD_TEST_REG3                             0x2063
// ---------------------------
// am_analog_top
// ----------------------------
#define METAL_REVISION                             0x206a
#define ADC_TOP_MISC                               0x206b
#define DPLL_TOP_MISC                              0x206c
#define ANALOG_TOP_MISC                            0x206d
#define AM_ANALOG_TOP_REG0                         0x206e
#define AM_ANALOG_TOP_REG1                         0x206f
// ---------------------------
// Sticky regs
// ----------------------------
#define PREG_STICKY_REG0                           0x207c
#define PREG_STICKY_REG1                           0x207d
#define PREG_WRITE_ONCE_REG                        0x207e
// ---------------------------
// AM Ring Oscillator 
// ----------------------------
#define AM_RING_OSC_REG0                           0x207f
// Control whether to provide random number to HDMITX20
#define HDMITX20_RNDNUM                            0x2080
// -------------------------------------------------------------------
// PSEL Group #1:  0x400 ~ 0x7FF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS1_CBUS_BASE = 0x21
// -----------------------------------------------
// ----------------------------
// $usb/rtl/usb_reg.v   (8)
// ----------------------------
// Moved to base 8'h22
// `define USB_ADDR0                      8'h00
// `define USB_ADDR1                      8'h01
// `define USB_ADDR2                      8'h02
// `define USB_ADDR3                      8'h03
// `define USB_ADDR4                      8'h04
// `define USB_ADDR5                      8'h05
// `define USB_ADDR6                      8'h06
// `define USB_ADDR7                      8'h07
// `define USB_ADDR8                      8'h08
// `define USB_ADDR9                      8'h09
// `define USB_ADDR10                     8'h0a
// `define USB_ADDR11                     8'h0b
// `define USB_ADDR12                     8'h0c
// `define USB_ADDR13                     8'h0d
// `define USB_ADDR14                     8'h0e
// `define USB_ADDR15                     8'h0f
// ----------------------------
// Smart Card (8)
// ----------------------------
#define SMARTCARD_REG0                             0x2110
#define SMARTCARD_REG1                             0x2111
#define SMARTCARD_REG2                             0x2112
#define SMARTCARD_STATUS                           0x2113
#define SMARTCARD_INTR                             0x2114
#define SMARTCARD_REG5                             0x2115
#define SMARTCARD_REG6                             0x2116
#define SMARTCARD_FIFO                             0x2117
#define SMARTCARD_REG8                             0x2118
// ----------------------------
// IR Remote (8)
// ----------------------------
#define IR_DEC_LDR_ACTIVE                          0x2120
#define IR_DEC_LDR_IDLE                            0x2121
#define IR_DEC_LDR_REPEAT                          0x2122
#define IR_DEC_BIT_0                               0x2123
#define IR_DEC_REG0                                0x2124
#define IR_DEC_FRAME                               0x2125
#define IR_DEC_STATUS                              0x2126
#define IR_DEC_REG1                                0x2127
// ----------------------------
// Demod Sampling
// ----------------------------
#define DEMOD_ADC_SAMPLING                         0x212d
// ----------------------------
// WIFI
// ----------------------------
// `define WIFI_ADC_SAMPLING               8'h2e
// `define WIFI_ADC_READBACK               8'h2f
// ----------------------------
// UART0
// ----------------------------
#define UART0_WFIFO                                0x2130
#define UART0_RFIFO                                0x2131
#define UART0_CONTROL                              0x2132
#define UART0_STATUS                               0x2133
#define UART0_MISC                                 0x2134
#define UART0_REG5                                 0x2135
// ----------------------------
// UART1
// ----------------------------
#define UART1_WFIFO                                0x2137
#define UART1_RFIFO                                0x2138
#define UART1_CONTROL                              0x2139
#define UART1_STATUS                               0x213a
#define UART1_MISC                                 0x213b
#define UART1_REG5                                 0x213c
// ----------------------------
// I2C Master (8)
// ----------------------------
#define I2C_M_0_CONTROL_REG                        0x2140
    #define     I2C_M_MANUAL_SDA_I        26
    #define     I2C_M_MANUAL_SCL_I        25
    #define     I2C_M_MANUAL_SDA_O        24
    #define     I2C_M_MANUAL_SCL_O        23
    #define     I2C_M_MANUAL_EN           22
    #define     I2C_M_DELAY_MSB           21
    #define     I2C_M_DELAY_LSB           12
    #define     I2C_M_DATA_CNT_MSB        11
    #define     I2C_M_DATA_CNT_LSB        8
    #define     I2C_M_CURR_TOKEN_MSB      7
    #define     I2C_M_CURR_TOKEN_LSB      4
    #define     I2C_M_ERROR               3
    #define     I2C_M_STATUS              2
    #define     I2C_M_ACK_IGNORE          1
    #define     I2C_M_START               0
#define I2C_M_0_SLAVE_ADDR                         0x2141
#define I2C_M_0_TOKEN_LIST0                        0x2142
#define I2C_M_0_TOKEN_LIST1                        0x2143
#define I2C_M_0_WDATA_REG0                         0x2144
#define I2C_M_0_WDATA_REG1                         0x2145
#define I2C_M_0_RDATA_REG0                         0x2146
#define I2C_M_0_RDATA_REG1                         0x2147
// ----------------------------
// I2C Slave (3)
// ----------------------------
#define I2C_S_CONTROL_REG                          0x2150
#define I2C_S_SEND_REG                             0x2151
#define I2C_S_RECV_REG                             0x2152
#define I2C_S_CNTL1_REG                            0x2153
// ----------------------------
// PWM / DS A/B
// ----------------------------
#define PWM_PWM_A                                  0x2154
#define PWM_PWM_B                                  0x2155
#define PWM_MISC_REG_AB                            0x2156
#define PWM_DELTA_SIGMA_AB                         0x2157
// ---------------------------
// EFUSE (4)
// ----------------------------
// Moved to the Secure APB3 bus
// `define EFUSE_CNTL0                     8'h58
// `define EFUSE_CNTL1                     8'h59
// `define EFUSE_CNTL2                     8'h5a
// `define EFUSE_CNTL3                     8'h5b
// `define EFUSE_CNTL4                     8'h5c
// ---------------------------------------------
// Separate APB slave that shares the CBUS/APB
// register space of the static registers
// ---------------------------------------------
#define ATAPI_IDEREG0                              0x2160
   #define IDE_UDMA_PIO_STATE         15
   #define IDE_BUSY                   14
   #define IDE_ERROR_BIT              13
   #define IDE_DMARQ_BIT              12
   #define IDE_IORDY_BIT              11
   #define IDE_IORDY_EN_BIT           10
   #define IDE_DIS_CSEL_BIT            9
   #define IDE_CSEL_BIT                8
   #define IDE_IRQ14                   2
   #define IDE_ATAPI_GPIO_EN           3
   #define IDE_DMARQ_FULL              1
   #define IDE_ENABLE                  0
#define ATAPI_IDEREG1                              0x2161
#define ATAPI_IDEREG2                              0x2162
    #define IDE_XFER_CNT_MSB_BIT      18
    #define IDE_XFER_CNT_LSB_BIT       0
#define ATAPI_CYCTIME                              0x2163
#define ATAPI_IDETIME                              0x2164
#define ATAPI_PIO_TIMING                           0x2165
#define ATAPI_TABLE_ADD_REG                        0x2166
#define ATAPI_IDEREG3                              0x2167
#define ATAPI_UDMA_REG0                            0x2168
#define ATAPI_UDMA_REG1                            0x2169
// Room for registers here
#define TRANS_PWMA_REG0                            0x2170
#define TRANS_PWMA_REG1                            0x2171
#define TRANS_PWMA_MUX0                            0x2172
#define TRANS_PWMA_MUX1                            0x2173
#define TRANS_PWMA_MUX2                            0x2174
#define TRANS_PWMA_MUX3                            0x2175
#define TRANS_PWMA_MUX4                            0x2176
#define TRANS_PWMA_MUX5                            0x2177
#define TRANS_PWMB_REG0                            0x2178
#define TRANS_PWMB_REG1                            0x2179
#define TRANS_PWMB_MUX0                            0x217a
#define TRANS_PWMB_MUX1                            0x217b
#define TRANS_PWMB_MUX2                            0x217c
#define TRANS_PWMB_MUX3                            0x217d
#define TRANS_PWMB_MUX4                            0x217e
#define TRANS_PWMB_MUX5                            0x217f
// ----------------------------
// NAND (21)
// ----------------------------
#define NAND_START                                 0x2180
#define NAND_ADR_CMD                               0x218a
#define NAND_ADR_STS                               0x218b
#define NAND_END                                   0x218f
// ----------------------------
// PWM / DS C/D
// ----------------------------
#define PWM_PWM_C                                  0x2194
#define PWM_PWM_D                                  0x2195
#define PWM_MISC_REG_CD                            0x2196
#define PWM_DELTA_SIGMA_CD                         0x2197
// ----------------------------
// ISP_FLASH_LED_CTRL
// ----------------------------
//bit 31, reg_led_en //rising pulse start, falling pulse stop for torch mode
//bit 30, reg_inc_i_st_lat //for as3685, dynamic increase current during st_latch
//bit 29:28, reg_inv_en_pol //bit[29], invert en1, bit [28], invert en2
//bit 27, reg_switch_en1en2  //switch output en1 and en2. For IS3231: en1 is EN, en2 is mode. 
//bit 26, reg_force_off_mode //1: reset state machine at the falling edge no matter which state it is in
//bit 25, reg_hold_nonstd_off_mode //hold the non-std led_off signal input before state "OFF"
//bit 24, reg_flash_mode_timeout_en  //force to exit the Tlat state when time out, for flash mode protection
//bit 23, reg_en1_st_ini_level //en1 level during state ST_INI
//bit 22, reg_en2_st_set_mp_level //en2 level during state ST_SET_MP_HI, ST_SET_MP_LO
//bit 21, reg_en1_st_off_level //en1 level during state ST_OFF
//bit 20, reg_en2_st_off_level //en2 level during state ST_OFF
//bit 19:12, reg_en1_mp_num  //en1 multi pulse number, up to 256 step current control
//bit 10:0, reg_t_st_ini //Max: 85.2 us under 24M clock input
#define ISP_LED_CTRL                               0x2198
//bit 31:21, reg_t_en1_inc_i_st_lat_cnt //Max: 85.2us under 24M. for as3685, dynamic increase current during st_latch
//bit 20:10, reg_t_en2_lo_st_ini //Max: 85.2 us under 24M clock input
//bit 9:0, reg_t_en2_hi1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
#define ISP_LED_TIMING1                            0x2199
//bit 31:21, reg_t_en1_mp_hi_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
//bit 20:10, reg_t_en1_mp_lo_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
//bit 9:0, reg_t_en2_lo1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
#define ISP_LED_TIMING2                            0x219a
//bit 30:28, RO state
//bit 25:0, reg_flash_mode_timeout_cnt //up to 2.79s at 24Mhz clk input
#define ISP_LED_TIMING3                            0x219b
//bit 25:0, reg_t_st_lat_cnt //up to 2.79s, keep the led on if it's 26'h3ffffff under torch mode
#define ISP_LED_TIMING4                            0x219c
//bit 31:26, reg_t_st_off_cnt[5:0] //up to 85.2us OFF state.
//bit 25:0, reg_t_en2_hi2_st_lat_cnt //EN2 can output hi-lo-hi during ST_LATCH, this is the second hi -duration
#define ISP_LED_TIMING5                            0x219d
//bit 30:26, reg_t_st_off_cnt[10:6] //up to 85.2us OFF state.
//bit 25:0, reg_t_en1_st_lat_hold_cnt //to make sure Tlat to meat it's minimum request 500us (since non-std led_off signal may comes in anytime)
#define ISP_LED_TIMING6                            0x219e
// ----------------------------
// SAR ADC (16)
// ----------------------------
#define SAR_ADC_REG0                               0x21a0
#define SAR_ADC_CHAN_LIST                          0x21a1
#define SAR_ADC_AVG_CNTL                           0x21a2
#define SAR_ADC_REG3                               0x21a3
#define SAR_ADC_DELAY                              0x21a4
#define SAR_ADC_LAST_RD                            0x21a5
#define SAR_ADC_FIFO_RD                            0x21a6
#define SAR_ADC_AUX_SW                             0x21a7
#define SAR_ADC_CHAN_10_SW                         0x21a8
#define SAR_ADC_DETECT_IDLE_SW                     0x21a9
#define SAR_ADC_DELTA_10                           0x21aa
// ----------------------------
// CTouch (16)
// ----------------------------
#define PWM_PWM_E                                  0x21b0
#define PWM_PWM_F                                  0x21b1
#define PWM_MISC_REG_EF                            0x21b2
#define PWM_DELTA_SIGMA_EF                         0x21b3
// ----------------------------
// UART2
// ----------------------------
#define UART2_WFIFO                                0x21c0
#define UART2_RFIFO                                0x21c1
#define UART2_CONTROL                              0x21c2
#define UART2_STATUS                               0x21c3
#define UART2_MISC                                 0x21c4
#define UART2_REG5                                 0x21c5
// ----------------------------
// UART3
// ----------------------------
#define UART3_WFIFO                                0x21c8
#define UART3_RFIFO                                0x21c9
#define UART3_CONTROL                              0x21ca
#define UART3_STATUS                               0x21cb
#define UART3_MISC                                 0x21cc
#define UART3_REG5                                 0x21cd
// ---------------------------
// RTC (4)
// ---------------------------
#define RTC_ADDR0                                  0x21d0
#define RTC_ADDR1                                  0x21d1
#define RTC_ADDR2                                  0x21d2
#define RTC_ADDR3                                  0x21d3
#define RTC_ADDR4                                  0x21d4
// ----------------------------
// clock measure (4)
// ----------------------------
#define MSR_CLK_DUTY                               0x21d6
#define MSR_CLK_REG0                               0x21d7
#define MSR_CLK_REG1                               0x21d8
#define MSR_CLK_REG2                               0x21d9
#define MSR_CLK_REG3                               0x21da
#define MSR_CLK_REG4                               0x21db
#define MSR_CLK_REG5                               0x21de
// ----------------------------
// LED PWM
// ----------------------------
// `define LED_PWM_REG0                    8'hda
// `define LED_PWM_REG1                    8'hdb
// `define LED_PWM_REG2                    8'hdc
// `define LED_PWM_REG3                    8'hdd
// `define LED_PWM_REG4                    8'hde
// `define LED_PWM_REG5                    8'hdf
// `define LED_PWM_REG6                    8'he0
// ----------------------------
// VGHL PWM
// ----------------------------
// `define VGHL_PWM_REG0                   8'he1
// `define VGHL_PWM_REG1                   8'he2
// `define VGHL_PWM_REG2                   8'he3
// `define VGHL_PWM_REG3                   8'he4
// `define VGHL_PWM_REG4                   8'he5
// `define VGHL_PWM_REG5                   8'he6
// `define VGHL_PWM_REG6                   8'he7
// ----------------------------
// I2C Master
// ----------------------------
#define I2C_M_1_CONTROL_REG                        0x21f0
#define I2C_M_1_SLAVE_ADDR                         0x21f1
#define I2C_M_1_TOKEN_LIST0                        0x21f2
#define I2C_M_1_TOKEN_LIST1                        0x21f3
#define I2C_M_1_WDATA_REG0                         0x21f4
#define I2C_M_1_WDATA_REG1                         0x21f5
#define I2C_M_1_RDATA_REG0                         0x21f6
#define I2C_M_1_RDATA_REG1                         0x21f7
// ----------------------------
// I2C Master
// ----------------------------
#define I2C_M_2_CONTROL_REG                        0x21f8
#define I2C_M_2_SLAVE_ADDR                         0x21f9
#define I2C_M_2_TOKEN_LIST0                        0x21fa
#define I2C_M_2_TOKEN_LIST1                        0x21fb
#define I2C_M_2_WDATA_REG0                         0x21fc
#define I2C_M_2_WDATA_REG1                         0x21fd
#define I2C_M_2_RDATA_REG0                         0x21fe
#define I2C_M_2_RDATA_REG1                         0x21ff
// -------------------------------------------------------------------
// PSEL Group #2:  0x800 ~ 0xbFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS2_CBUS_BASE = 0x22
// -----------------------------------------------
#define USB_ADDR0                                  0x2200
#define USB_ADDR1                                  0x2201
#define USB_ADDR2                                  0x2202
#define USB_ADDR3                                  0x2203
#define USB_ADDR4                                  0x2204
#define USB_ADDR5                                  0x2205
#define USB_ADDR6                                  0x2206
#define USB_ADDR7                                  0x2207
#define USB_ADDR8                                  0x2208
#define USB_ADDR9                                  0x2209
#define USB_ADDR10                                 0x220a
#define USB_ADDR11                                 0x220b
#define USB_ADDR12                                 0x220c
#define USB_ADDR13                                 0x220d
#define USB_ADDR14                                 0x220e
#define USB_ADDR15                                 0x220f
#define USB_ADDR16                                 0x2210
#define USB_ADDR17                                 0x2211
#define USB_ADDR18                                 0x2212
#define USB_ADDR19                                 0x2213
#define USB_ADDR20                                 0x2214
#define USB_ADDR21                                 0x2215
#define USB_ADDR22                                 0x2216
#define USB_ADDR23                                 0x2217
#define USB_ADDR24                                 0x2218
#define USB_ADDR25                                 0x2219
#define USB_ADDR26                                 0x221a
#define USB_ADDR27                                 0x221b
#define USB_ADDR28                                 0x221c
#define USB_ADDR29                                 0x221d
#define USB_ADDR30                                 0x221e
#define USB_ADDR31                                 0x221f
// ----------------------------
// SANA (Stream Analyzer)
// ----------------------------
// [31:16] - ddr_setting
// [15]    - disable_stream_clock_gating
// [14:13] - mem_pd_ctl_sana
// [6:4]   - stream_fetch_endian 
// [3]     - use_parser_vbuf_wp
// [2]     - use_parser_vbuf2_wp
// [1]     - stream_fetch_busy - Read Only
// [0]     - stream_fetch_enable
#define SANA_STREAM_CONTROL                        0x2220
#define SANA_STREAM_START_ADDR                     0x2221
#define SANA_STREAM_END_ADDR                       0x2222
// SW stream_buffer_wr_ptr
#define SANA_STREAM_WR_PTR                         0x2223
#define SANA_STREAM_RD_PTR                         0x2224
//[31:0] stream_buffer_level - read only
#define SANA_STREAM_LEVEL                          0x2225
// [31:29] stream_buffer_hole 256*(4^0) bytes
// [28:23] stream_fifo_hole 
// [22:16] stream_fifo_level
// [15]    stream_fifo_wr_ptr_update_en
// [14:8]  stream_fifo_wr_ptr 
// [7]     stream_fifo_rd_ptr_update_en
// [6:0]   stream_fifo_rd_ptr 
#define SANA_STREAM_FIFO_CTL                       0x2226
// [31:18] - Reserved
// [17]    - sana_int_enable
// [16]    - sana_int_level (default : 0(pulse))
// [15]    - disable_shift_clock_gating
// [14]    - startcode_protect -- TODO
// [8:6]   - sft_valid_wr_position (default : 3 (at least 24 bits available))
// [5:4]   - emulate_code_length_sub_1(Default : 2)
// [3]     - emulation_auto_on_startcode(Default : 0)
// [2:1]   - start_code_length_sub_1(Default : 2)
// [0]     - stream_shift_enable(Default : 0)
#define SANA_SHIFT_CONTROL                         0x2227
// [31:0]  - max 4-bytes start code (Default : 0x00000100)
#define SANA_SHIFT_STARTCODE                       0x2228
// [31:0]  - max 4-bytes emulate code (Default : 0x00000300)
#define SANA_SHIFT_EMULATECODE                     0x2229
// [3]     - sana_int
// [2]     - startcode_searching
// [1]     - emulation_check_on
// [0]     - startcode_check_on
#define SANA_SHIFT_STATUS                          0x222a
// [31:0] sana_shifted_data - read only
#define SANA_SHIFTED_DATA                          0x222b
// [31:0] shift_byte_count[31:0]
#define SANA_SHIFT_BYTE_COUNT                      0x222c
// [31:28] - shift_byte_count[35:32]
// [27:20] - element_read_data[31:24]
// [10]    - bytealign
// [9]     - signed_element
// [8]     - start_element_read
// [7]     - shift_busy
// [6:0]   - shift_bits
#define SANA_SHIFT_COMMAND                         0x222d
// 31:8    - element_read_data[23:0]
//  7:2    - element_read_length
//  1:0    - element_read_state
#define SANA_ELEMENT_RESULT                        0x222e
// support up to 8 masters, one bit per master
// 23:16   - lock_release (Write 1 to release)
// 15:8    - lock_req (write 1 to request)
//  7:0    - lock_result (Read Only)
#define ATOM_LOCK                                  0x222f
// ----------------------------
// BLKMV (9)
// ----------------------------
#define NDMA_CNTL_REG0                             0x2270
    #define NDMA_STATUS                 26
    #define NDMA_PERIODIC_INT_DLY_MSB   25
    #define NDMA_PERIODIC_INT_DLY_LSB   16
    #define NDMA_PERIODIC_INT_EN        15
    #define NDMA_ENABLE                 14
    #define NDMA_AHB_DELAY_MSB          13
    #define NDMA_AHB_DELAY_LSB          0
#define NDMA_TABLE_ADD_REG                         0x2272
#define NDMA_TDES_KEY_LO                           0x2273
#define NDMA_TDES_KEY_HI                           0x2274
#define NDMA_TDES_CONTROL                          0x2275
#define NDMA_RIJNDAEL_CONTROL                      0x2276
#define NDMA_RIJNDAEL_RK_FIFO                      0x2277
#define NDMA_CRC_OUT                               0x2278
#define NDMA_THREAD_REG                            0x2279
#define NDMA_THREAD_TABLE_START0                   0x2280
#define NDMA_THREAD_TABLE_CURR0                    0x2281
#define NDMA_THREAD_TABLE_END0                     0x2282
#define NDMA_THREAD_TABLE_START1                   0x2283
#define NDMA_THREAD_TABLE_CURR1                    0x2284
#define NDMA_THREAD_TABLE_END1                     0x2285
#define NDMA_THREAD_TABLE_START2                   0x2286
#define NDMA_THREAD_TABLE_CURR2                    0x2287
#define NDMA_THREAD_TABLE_END2                     0x2288
#define NDMA_THREAD_TABLE_START3                   0x2289
#define NDMA_THREAD_TABLE_CURR3                    0x228a
#define NDMA_THREAD_TABLE_END3                     0x228b
#define NDMA_CNTL_REG1                             0x228c
#define NDMA_AES_KEY_0                             0x2290
#define NDMA_AES_KEY_1                             0x2291
#define NDMA_AES_KEY_2                             0x2292
#define NDMA_AES_KEY_3                             0x2293
#define NDMA_AES_KEY_4                             0x2294
#define NDMA_AES_KEY_5                             0x2295
#define NDMA_AES_KEY_6                             0x2296
#define NDMA_AES_KEY_7                             0x2297
#define NDMA_AES_IV_0                              0x2298
#define NDMA_AES_IV_1                              0x2299
#define NDMA_AES_IV_2                              0x229a
#define NDMA_AES_IV_3                              0x229b
#define NDMA_AES_REG0                              0x229c
// -------------------------------------------------------------------
// PSEL Group #3:  0xc00 ~ 0xFFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS3_CBUS_BASE = 0x23
// -----------------------------------------------
// ---------------------------
// STREAM (8)
// ---------------------------
// bit 31:24 -- event_length
// bit 23:22 -- bus_1st_sel_1  //00-gpio, 01-reserved, 10-addr, 11-data 
// bit 21:20 -- bus_2nd_sel_1
// bit 19:18 -- bus_1st_sel_0
// bit 17:16 -- bus_2nd_sel_0
// bit 15:0 -- set output value (output 1 will read according to external input) 
#define STREAM_EVENT_INFO                          0x2300
// bit 31    -- force_parity_1
// bit 30    -- LSB_first
// bit 31:20 -- reserved
// bit 19:16 -- toggle point index
// bit 15:8  -- output togle point1
// bit 7:0   -- output togle point0 (0xff means input) 
#define STREAM_OUTPUT_CONFIG                       0x2301
// bit 31:24 -- clock_divide_ext
// bit 23:20 -- s_bus_start ( sclk, sdataout, sdatain)  // 0 means no s_bus used
// bit 19    -- no_sclk_on_pin // will use internal write clock and read clock (like RS232) 
// bit 18    -- invert_sclk_in
// bit 17    -- sdata_send_busy  // indicate one data is sending -- read only
// bit 16    -- one_sdata_received // set when one sdata is received, can write 0 to clear 
// bit 15    -- sdata_parity  // (write -- 0-even, 1-odd) (read -- received parity check)
// bit 14    -- sdata_send_type  // 0 -- 8 bits  1 -- 32 bits ( for fujitsu only )
// bit 13    -- sdata_receive_type // 0 -- 8 bits only  1 -- 8/32 bits 
// bit 12    -- invert_request_out
// bit 11:8  -- request_out_sel  // 0 means disable output
// bit 7:0   --  stop_request_count 
#define C_D_BUS_CONTROL                            0x2302
// bit 31:0  -- serial data (write: output one data, read: input data)
#define C_DATA                                     0x2303
// bit 31:28 bus_width_1
// bit 27:24 bus_start_pin_1
// bit 23:16 bus_sel_chang_point_1 
// bit 15:12 bus_width_0
// bit 11:08 bus_start_pin_0
// bit 07:00 bus_sel_chang_point_0 
#define STREAM_BUS_CONFIG                          0x2304
// bit 31:24 clock_divide
// bit 23:20 clock_output_sel  -- 0 means disable clock output
// bit 19 -- inc_event_addr
// bit 18 -- async_fifo_endian
// bit 17 -- send_to_async_fifo
// bit 16 -- data_in_serial_lsb
// bit 15 -- invert_no_wait_condition_0
// bit 14 -- invert_no_wait_condition_1
// bit 13 -- invert_no_wait_condition_2
// bit 12 -- invert_data_bus
// bit 11 -- invert_clock_in
// bit 10 -- event_wait_clk_en
// bit 9 -- data_in_serial
// bit 8 -- invert_data_in_clk 
// bit 7:4  -- data_in_begin
// bit 3:0  -- data_in_clk_sel
#define STREAM_DATA_IN_CONFIG                      0x2305
// wait condition and irq should not be connected to 0, 0 means disable)
// bit 31:28 -- no_wait_condition_0   (0 means disable this condition)
// bit 27:24 -- no_wait_condition_1   (0 means disable this condition)
// bit 23:20 -- no_wait_condition_2   (0 means disable this condition)
// bit 19:16 -- irq_input_sel         (0 means disable this interrupt)
// bit 15:13 -- interrupt_status (read) clear status (write) (ext 0, ext 1, transfer end)
// bit 12 -- enable_sdata_irq
// bit 11 -- invert_irq_0
// bit 10 -- invert_irq_1
// bit  9 -- enable_transfer_end_irq
// bit  8 -- enable_second_ext_irq
// bit 7:0 -- no_wait_condition_check_point (0xff means no check)
#define STREAM_WAIT_IRQ_CONFIG                     0x2306
// bit 31:24 -- event address
// bit 23:16 -- event data
// bit 15:1 -- event repeat times  (0 means one time event)
// bit 0  -- Start Event (write) event_busy (read)
#define STREAM_EVENT_CTL                           0x2307
// ---------------------------
// SDIO (8)
// ---------------------------
// `define C_SDIO_HIGH16                   8'h00 
// bit 31:0 -- cmd_argument/MS_SHORT_DATA_WRITE
#define CMD_ARGUMENT                               0x2308
// bit 31:24 -- repeat_package_times/MS_SHORT_DATA_WRITE_NUMBER
// bit 21   -- use_int_window
// bit 20   -- cmd_send_data/MS_HAVE_LONG_DATA_WRITE
// bit 19   -- check_busy_on_dat0 (used for R1b response)
// bit 18   -- response_crc7_from_8
// bit 17   -- response_have_data/MS_HAVE_LONG_DATA_READ
// bit 16   -- response_do_not_have_crc7/MS_SHORT_DATA_DO_NOT_HAVE_CRC16
// bit 15:8 -- cmd_response_bits (00 means no response) /MS_SHORT_DATA_READ_NUMBER
// bit 7:0 -- cmd_command/MS_TPC
#define CMD_SEND                                   0x2309
// bit 31:29 -- sdio_write_CRC_ok_status
// bit 28:23 -- sdio_write_Nwr
// bit 22:21 -- m_endian
// bit 20    -- bus_width
// bit 19    -- data_latch_at_negedge (normally at posedge)
// bit 18    -- do_not_delay_data (normally delay one clock)
// bit 17:12 -- cmd_argument_bits (before CRC, normally : 39) 
// bit 11 -- cmd_out_at_posedge (normally at negedge)
// bit 10 -- cmd_disable_CRC
// bit 9:0 -- cmd_clk_divide
#define SDIO_CONFIG                                0x230a
// bit 31:19 -- sdio_timing_out_count
// bit 18 -- arc_timing_out_int_en
// bit 17 -- amrisc_timing_out_int_en
// bit 16 -- sdio_timig_out_int   -- write 1 clear this int bit
// bit 15:12 -- sdio_status_info  -- used for change infor between ARC and Amrisc
// bit 11 -- sdio_set_soft_int -- write 1 to this bit will set sdio_soft_int , read out is m_req_sdio
// bit 10 -- sdio_soft_int   -- write 1 clear this int bit
// bit 9 -- sdio_cmd_int   -- write 1 clear this int bit
// bit 8 -- sdio_if_int   -- write 1 clear this int bit
// bit 7 -- sdio_data_write_crc16_ok -- Read-Only
// bit 6 -- sdio_data_read_crc16_ok  -- Read-Only
// bit 5 -- sdio_response_crc7_ok    -- Read-Only
// bit 4 -- sdio_cmd_busy            -- Read-Only
// bit 3:0 -- sdio_status            -- Read-Only
#define SDIO_STATUS_IRQ                            0x230b
// bit 31 -- halt_hole 0 -- 8 bits 1 -- 16 bits
// bit 30 -- force_halt
// bit 29:24 -- sdio_force_data_read (read_only)
// bit 23:22 -- disable_mem_halt (write and read)
// bit 21:16 -- sdio_force_output_en 
// bit 15 -- soft_reset
// bit 14 -- sdio_force_enable
// bit 13:8 -- sdio_force_data/sdio_read_data
// bit 7:6 -- sdio_if_int_config 
// bit 5 -- arc_soft_int_en
// bit 4 -- arc_cmd_int_en
// bit 3 -- arc_if_int_en
// bit 2 -- amrisc_soft_int_en
// bit 1 -- amrisc_cmd_int_en
// bit 0 -- amrisc_if_int_en
#define SDIO_IRQ_CONFIG                            0x230c
// bit 27:16 -- data_catch_finish_point
// (
// bit 15:12 -- response_read_index  
// bit 9 -- data_catch_readout_en
// bit 8 -- write_read_out_index
// ) this bits only write when write_read_out_index = 1
// bit 11 -- sdio_1_data_swap01 
// bit 10 -- sdio_0_data_on_1 
// bit 7:6 -- data_catch_level 
// bit 5 -- stream_8_bits_mode
// bit 4 -- stream_enable
// bit 3 -- ms_sclk_always
// bit 2 -- ms_enable
// bit 1:0 -- SDIO_port_sel //00-sdio1, 01-sdio2, 02-sdio3
#define SDIO_MULT_CONFIG                           0x230d
// bit 31:0 -- m_addr_sdio
#define SDIO_M_ADDR                                0x230e
// bit 31    -- CRC_status_4line
// bit 30    -- data_rw_do_not_have_crc16/MS_LONG_DATA_DO_NOT_HAVE_CRC16
// bit 29:16 -- data_rw_number/MS_LONG_DATA_NUMBER 
// bit 15:0 -- cmd_argument_ext/MS_SHORT_DATA_EXTENSION
#define SDIO_EXTENSION                             0x230f
// ----------------------------
// ASYNC FIFO (4)
// ----------------------------
#define ASYNC_FIFO_REG0                            0x2310
#define ASYNC_FIFO_REG1                            0x2311
    #define ASYNC_FIFO_FLUSH_STATUS     31
    #define ASYNC_FIFO_ERR              30
    #define ASYNC_FIFO_FIFO_EMPTY       29
    #define ASYNC_FIFO_TO_HIU           24
    #define ASYNC_FIFO_FLUSH            23
    #define ASYNC_FIFO_RESET            22
    #define ASYNC_FIFO_WRAP_EN          21
    #define ASYNC_FIFO_FLUSH_EN         20
    #define ASYNC_FIFO_RESIDUAL_MSB     19
    #define ASYNC_FIFO_RESIDUAL_LSB     15
    #define ASYNC_FIFO_FLUSH_CNT_MSB    14
    #define ASYNC_FIFO_FLUSH_CNT_LSB    0
#define ASYNC_FIFO_REG2                            0x2312
    #define ASYNC_FIFO_FIFO_FULL        26
    #define ASYNC_FIFO_FILL_STATUS      25
    #define ASYNC_FIFO_SOURCE_MSB       24
    #define ASYNC_FIFO_SOURCE_LSB       23
    #define ASYNC_FIFO_ENDIAN_MSB       22
    #define ASYNC_FIFO_ENDIAN_LSB       21
    #define ASYNC_FIFO_FILL_EN          20
    #define ASYNC_FIFO_FILL_CNT_MSB     19
    #define ASYNC_FIFO_FILL_CNT_LSB     0
#define ASYNC_FIFO_REG3                            0x2313
    #define ASYNC_FLUSH_SIZE_IRQ_MSB    15
    #define ASYNC_FLUSH_SIZE_IRQ_LSB    0
// ----------------------------
// ASYNC FIFO (4)
// ----------------------------
#define ASYNC_FIFO2_REG0                           0x2314
#define ASYNC_FIFO2_REG1                           0x2315
#define ASYNC_FIFO2_REG2                           0x2316
#define ASYNC_FIFO2_REG3                           0x2317
// ----------------------------
// SDIO_AHB_CBUS (2)
// ----------------------------
// bit   17    -- arc_ahb_cbus_int_en
// bit   16    -- amrisc_ahb_cbus_int_en
// bit 15:8    -- SDIO_FIFO_count
// bit  7:4    -- m_req_count
// bit    3    -- reserved
// bit    2    -- m_write_cbus
// bit    1    -- m_req_cbus
// bit    0    -- sdio_ahb_cbus_enable
#define SDIO_AHB_CBUS_CTRL                         0x2318
// m_rd_data[31:0] when (m_write_cbus == 0)  CBUS write
// m_wr_data[31:0] when (m_write_cbus == 1)  CBUS read
#define SDIO_AHB_CBUS_M_DATA                       0x2319
// ----------------------------
// SPI 
// ----------------------------
#define SPI_FLASH_CMD                              0x2320
    #define SPI_FLASH_READ    31
    #define SPI_FLASH_WREN    30
    #define SPI_FLASH_WRDI    29
    #define SPI_FLASH_RDID    28
    #define SPI_FLASH_RDSR    27
    #define SPI_FLASH_WRSR    26
    #define SPI_FLASH_PP      25
    #define SPI_FLASH_SE      24
    #define SPI_FLASH_BE      23
    #define SPI_FLASH_CE      22
    #define SPI_FLASH_DP      21
    #define SPI_FLASH_RES     20
    #define SPI_HPM           19
    #define SPI_FLASH_USR     18
    #define SPI_FLASH_USR_ADDR 15
    #define SPI_FLASH_USR_DUMMY 14
    #define SPI_FLASH_USR_DIN   13
    #define SPI_FLASH_USR_DOUT   12
    #define SPI_FLASH_USR_DUMMY_BLEN   10
    #define SPI_FLASH_USR_CMD     0
#define SPI_FLASH_ADDR                             0x2321
    #define SPI_FLASH_BYTES_LEN 24
    #define SPI_FLASH_ADDR_START 0
#define SPI_FLASH_CTRL                             0x2322
    #define SPI_ENABLE_AHB    17
    #define SPI_SST_AAI       16
    #define SPI_RES_RID       15
    #define SPI_FREAD_DUAL    14
    #define SPI_READ_READ_EN  13
    #define SPI_CLK_DIV0      12
    #define SPI_CLKCNT_N      8
    #define SPI_CLKCNT_H      4
    #define SPI_CLKCNT_L      0
#define SPI_FLASH_CTRL1                            0x2323
#define SPI_FLASH_STATUS                           0x2324
#define SPI_FLASH_CTRL2                            0x2325
#define SPI_FLASH_CLOCK                            0x2326
#define SPI_FLASH_USER                             0x2327
#define SPI_FLASH_USER1                            0x2328
#define SPI_FLASH_USER2                            0x2329
#define SPI_FLASH_USER3                            0x232a
#define SPI_FLASH_USER4                            0x232b
#define SPI_FLASH_SLAVE                            0x232c
#define SPI_FLASH_SLAVE1                           0x232d
#define SPI_FLASH_SLAVE2                           0x232e
#define SPI_FLASH_SLAVE3                           0x232f
#define SPI_FLASH_C0                               0x2330
#define SPI_FLASH_C1                               0x2331
#define SPI_FLASH_C2                               0x2332
#define SPI_FLASH_C3                               0x2333
#define SPI_FLASH_C4                               0x2334
#define SPI_FLASH_C5                               0x2335
#define SPI_FLASH_C6                               0x2336
#define SPI_FLASH_C7                               0x2337
#define SPI_FLASH_B8                               0x2338
#define SPI_FLASH_B9                               0x2339
#define SPI_FLASH_B10                              0x233a
#define SPI_FLASH_B11                              0x233b
#define SPI_FLASH_B12                              0x233c
#define SPI_FLASH_B13                              0x233d
#define SPI_FLASH_B14                              0x233e
#define SPI_FLASH_B15                              0x233f
// ----------------------------
// I2C Master
// ----------------------------
#define I2C_M_3_CONTROL_REG                        0x2348
#define I2C_M_3_SLAVE_ADDR                         0x2349
#define I2C_M_3_TOKEN_LIST0                        0x234a
#define I2C_M_3_TOKEN_LIST1                        0x234b
#define I2C_M_3_WDATA_REG0                         0x234c
#define I2C_M_3_WDATA_REG1                         0x234d
#define I2C_M_3_RDATA_REG0                         0x234e
#define I2C_M_3_RDATA_REG1                         0x234f
// ----------------------------
// SPICC
// ----------------------------
#define SPICC_RXDATA                               0x2360
#define SPICC_TXDATA                               0x2361
#define SPICC_CONREG                               0x2362
#define SPICC_INTREG                               0x2363
#define SPICC_DMAREG                               0x2364
#define SPICC_STATREG                              0x2365
#define SPICC_PERIODREG                            0x2366
#define SPICC_TESTREG                              0x2367
#define SPICC_DRADDR                               0x2368
#define SPICC_DWADDR                               0x2369
// ----------------------------
// SDHC (SDIO #2)
// ----------------------------
#define SD_REG0_ARGU                               0x2380
#define SD_REG1_SEND                               0x2381
#define SD_REG2_CNTL                               0x2382
#define SD_REG3_STAT                               0x2383
#define SD_REG4_CLKC                               0x2384
#define SD_REG5_ADDR                               0x2385
#define SD_REG6_PDMA                               0x2386
#define SD_REG7_MISC                               0x2387
#define SD_REG8_DATA                               0x2388
#define SD_REG9_ICTL                               0x2389
#define SD_REGA_ISTA                               0x238a
#define SD_REGB_SRST                               0x238b
#define SD_REGC_ESTA                               0x238c
#define SD_REGD_ENHC                               0x238d
#define SD_REGE_CLK2                               0x238e
//
// Closing file:  periphs_reg.h
//
//
// Reading file:  isa_reg.h
//
// $isa/rtl/isa_core register defines for the APB bus
// CBUS base slave address
// -----------------------------------------------
// CBUS_BASE:  ISA_CBUS_BASE = 0x26
// -----------------------------------------------
// Up to 256 registers for this base
#define ISA_DEBUG_REG0                             0x2600
#define ISA_DEBUG_REG1                             0x2601
#define ISA_DEBUG_REG2                             0x2602
#define ISA_DEBUG_REG3                             0x2603
#define ISA_PLL_CLK_SIM0                           0x2608
#define ISA_CNTL_REG0                              0x2609
// -----------------------------------------------------------
#define AO_CPU_IRQ_IN0_INTR_STAT                   0x2610
#define AO_CPU_IRQ_IN0_INTR_STAT_CLR               0x2611
#define AO_CPU_IRQ_IN0_INTR_MASK                   0x2612
#define AO_CPU_IRQ_IN0_INTR_FIRQ_SEL               0x2613
// define MEDIA_CPU_IRQ_IN1_INTR_STAT           8'h14
// define MEDIA_CPU_IRQ_IN1_INTR_STAT_CLR       8'h15
// define MEDIA_CPU_IRQ_IN1_INTR_MASK           8'h16
// define MEDIA_CPU_IRQ_IN1_INTR_FIRQ_SEL       8'h17
// 
// define MEDIA_CPU_IRQ_IN2_INTR_STAT              8'h18
// define MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR          8'h19
// define MEDIA_CPU_IRQ_IN2_INTR_MASK              8'h1a
// define MEDIA_CPU_IRQ_IN2_INTR_FIRQ_SEL          8'h1b
// 
// define MEDIA_CPU_IRQ_IN3_INTR_STAT            8'h1c
// define MEDIA_CPU_IRQ_IN3_INTR_STAT_CLR        8'h1d
// define MEDIA_CPU_IRQ_IN3_INTR_MASK            8'h1e
// define MEDIA_CPU_IRQ_IN3_INTR_FIRQ_SEL        8'h1f
#define GPIO_INTR_EDGE_POL                         0x2620
#define GPIO_INTR_GPIO_SEL0                        0x2621
#define GPIO_INTR_GPIO_SEL1                        0x2622
#define GPIO_INTR_FILTER_SEL0                      0x2623
// `define GLOBAL_INTR_DISABLE                 8'h24    never used
#define MEDIA_CPU_INTR_STAT                        0x2628
#define MEDIA_CPU_INTR_STAT_CLR                    0x2629
#define MEDIA_CPU_INTR_MASK                        0x262a
#define MEDIA_CPU_INTR_FIRQ_SEL                    0x262b
// -----------------------------------------------------------
#define ISA_BIST_REG0                              0x2630
#define ISA_BIST_REG1                              0x2631
// -----------------------------------------------------------
#define WATCHDOG_TC                                0x2640
//#define WATCHDOG_RESET                             0x2641
#define WATCHDOG_RESET_REG                         0x2641
// -----------------------------------------------------------
#define AHB_ARBITER_REG                            0x2642
#define AHB_ARBDEC_REG                             0x2643
#define AHB_ARBITER2_REG                           0x264a
#define DEVICE_MMCP_CNTL                           0x264b
#define AUDIO_MMCP_CNTL                            0x264c
// -----------------------------------------------------------
#define ISA_TIMER_MUX                              0x2650
#define ISA_TIMERA                                 0x2651
#define ISA_TIMERB                                 0x2652
#define ISA_TIMERC                                 0x2653
#define ISA_TIMERD                                 0x2654
#define ISA_TIMERE                                 0x2655
#define FBUF_ADDR                                  0x2656
    #define VIDEO_FRM_BUF_MSB_BIT      23 
    #define VIDEO_FRM_BUF_LSB_BIT       2 
#define SDRAM_CTL0                                 0x2657
#define SDRAM_CTL2                                 0x2658
//`define AO_CPU_CTL                          8'h59
#define SDRAM_CTL4                                 0x265a
#define SDRAM_CTL5                                 0x265b
#define SDRAM_CTL6                                 0x265c
#define SDRAM_CTL7                                 0x265d
#define SDRAM_CTL8                                 0x265e
#define AHB_MP4_MC_CTL                             0x265f
#define MEDIA_CPU_PCR                              0x2660
#define MEDIA_CPU_CTL                              0x2661
#define ISA_TIMER_MUX1                             0x2664
#define ISA_TIMERF                                 0x2665
#define ISA_TIMERG                                 0x2666
#define ISA_TIMERH                                 0x2667
#define ISA_TIMERI                                 0x2668
// ---------------------------------------------
#define ABUF_WR_CTL0                               0x2670
    #define ABUF_WR_INT_EN	    31
    #define ABUF_WR_INT_POS_MSB      30 
    #define ABUF_WR_INT_POS_LSB      16 
    #define ABUF_WR_BLK_SIZE_MSB     14 
    #define ABUF_WR_BLK_SIZE_LSB      0
#define ABUF_WR_CTL1                               0x2671
    #define ABUF_WR_INT_EN	    31
    #define ABUF_WR_INT_POS_MSB      30 
    #define ABUF_WR_INT_POS_LSB      16 
    #define ABUF_WR_BLK_SIZE_MSB     14 
    #define ABUF_WR_BLK_SIZE_LSB      0
#define ABUF_WR_CTL2                               0x2672
    #define ABUF_WR_CUR_FF_CNT_MSB   21
    #define ABUF_WR_CUR_FF_CNT_LSB   16
    #define ABUF_WR_CUR_BLK_MSB      14
    #define ABUF_WR_CUR_BLK_LSB       0   
#define ABUF_WR_CTL3                               0x2673
    #define ABUF_WR_AHB_RST_PLS       3
    #define ABUF_WR_FF_CLR_PLS        2
    #define ABUF_WR_PLY_RPT_LVL	     1
    #define ABUF_WR_FF_PAUSE_LVL      0
#define ABUF_RD_CTL0                               0x2674
#define ABUF_RD_CTL1                               0x2675
    #define ABUF_RD_INT_EN	    31
    #define ABUF_RD_INT_POS_MSB      30 
    #define ABUF_RD_INT_POS_LSB      16 
    #define ABUF_RD_BLK_SIZE_MSB     14 
    #define ABUF_RD_BLK_SIZE_LSB      0   
#define ABUF_RD_CTL2                               0x2676
    #define ABUF_RD_CUR_FF_CNT_MSB   21
    #define ABUF_RD_CUR_FF_CNT_LSB   16
    #define ABUF_RD_CUR_BLK_MSB      14
    #define ABUF_RD_CUR_BLK_LSB       0   
#define ABUF_RD_CTL3                               0x2677
    #define ABUF_RD_PLY_ONCE_PLS      4
    #define ABUF_RD_AHB_RST_PLS       3
    #define ABUF_RD_FF_CLR_PLS        2
    #define ABUF_RD_PLY_RPT_LVL	     1
    #define ABUF_RD_FF_PAUSE_LVL      0
#define ABUF_ARB_CTL0                              0x2678
#define ABUF_FIFO_CTL0                             0x2679
    #define AIUout_FIFO_THRESHOLD_MSB 11
    #define AIUout_FIFO_THRESHOLD_LSB 6 
    #define AIUin_FIFO_THRESHOLD_MSB  5
    #define AIUin_FIFO_THRESHOLD_LSB  0
// ---------------------------------------------
#define AHB_BRIDGE_CNTL_WR                         0x2680
#define AHB_BRIDGE_REMAP0                          0x2681
#define AHB_BRIDGE_REMAP1                          0x2682
#define AHB_BRIDGE_REMAP2                          0x2683
#define AHB_BRIDGE_REMAP3                          0x2684
#define AHB_BRIDGE_CNTL_REG1                       0x2685
#define AHB_BRIDGE_CNTL_REG2                       0x2686
// ---------------------------------------------
// ----------------------------------------------
// `define SYS_CPU_0_IRQ_IN0_INTR_STAT         8'h90
// `define SYS_CPU_0_IRQ_IN0_INTR_STAT_CLR     8'h91
// `define SYS_CPU_0_IRQ_IN0_INTR_MASK         8'h92
// `define SYS_CPU_0_IRQ_IN0_INTR_FIRQ_SEL     8'h93
// `define SYS_CPU_0_IRQ_IN1_INTR_STAT         8'h94
// `define SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR     8'h95
// `define SYS_CPU_0_IRQ_IN1_INTR_MASK         8'h96
// `define SYS_CPU_0_IRQ_IN1_INTR_FIRQ_SEL     8'h97
// `define SYS_CPU_0_IRQ_IN2_INTR_STAT         8'h98
// `define SYS_CPU_0_IRQ_IN2_INTR_STAT_CLR     8'h99
// `define SYS_CPU_0_IRQ_IN2_INTR_MASK         8'h9a
// `define SYS_CPU_0_IRQ_IN2_INTR_FIRQ_SEL     8'h9b
// `define SYS_CPU_0_IRQ_IN3_INTR_STAT         8'h9c
// `define SYS_CPU_0_IRQ_IN3_INTR_STAT_CLR     8'h9d
// `define SYS_CPU_0_IRQ_IN3_INTR_MASK         8'h9e
// `define SYS_CPU_0_IRQ_IN3_INTR_FIRQ_SEL     8'h9f
// ----------------------------------------------
// `define SYS_CPU_1_IRQ_IN0_INTR_STAT         8'ha0
// `define SYS_CPU_1_IRQ_IN0_INTR_STAT_CLR     8'ha1
// `define SYS_CPU_1_IRQ_IN0_INTR_MASK         8'ha2
// `define SYS_CPU_1_IRQ_IN0_INTR_FIRQ_SEL     8'ha3
//  
// `define SYS_CPU_1_IRQ_IN1_INTR_STAT         8'ha4
// `define SYS_CPU_1_IRQ_IN1_INTR_STAT_CLR     8'ha5
// `define SYS_CPU_1_IRQ_IN1_INTR_MASK         8'ha6
// `define SYS_CPU_1_IRQ_IN1_INTR_FIRQ_SEL     8'ha7
//  
// `define SYS_CPU_1_IRQ_IN2_INTR_STAT         8'ha8
// `define SYS_CPU_1_IRQ_IN2_INTR_STAT_CLR     8'ha9
// `define SYS_CPU_1_IRQ_IN2_INTR_MASK         8'haa
// `define SYS_CPU_1_IRQ_IN2_INTR_FIRQ_SEL     8'hab
//  
// `define SYS_CPU_1_IRQ_IN3_INTR_STAT         8'hac
// `define SYS_CPU_1_IRQ_IN3_INTR_STAT_CLR     8'had
// `define SYS_CPU_1_IRQ_IN3_INTR_MASK         8'hae
// `define SYS_CPU_1_IRQ_IN3_INTR_FIRQ_SEL     8'haf
// ----------------------------------------------
// `define MEDIA_CPU_IRQ_IN4_INTR_STAT         8'hb0
// `define MEDIA_CPU_IRQ_IN4_INTR_STAT_CLR     8'hb1
// `define MEDIA_CPU_IRQ_IN4_INTR_MASK         8'hb2
// `define MEDIA_CPU_IRQ_IN4_INTR_FIRQ_SEL     8'hb3
// `define SYS_CPU_0_IRQ_IN4_INTR_STAT         8'hb4
// `define SYS_CPU_0_IRQ_IN4_INTR_STAT_CLR     8'hb5
// `define SYS_CPU_0_IRQ_IN4_INTR_MASK         8'hb6
// `define SYS_CPU_0_IRQ_IN4_INTR_FIRQ_SEL     8'hb7
// `define SYS_CPU_1_IRQ_IN4_INTR_STAT         8'hb8
// `define SYS_CPU_1_IRQ_IN4_INTR_STAT_CLR     8'hb9
// `define SYS_CPU_1_IRQ_IN4_INTR_MASK         8'hba
// `define SYS_CPU_1_IRQ_IN4_INTR_FIRQ_SEL     8'hbb
// `define SYS_CPU_2_IRQ_IN4_INTR_STAT         8'hbc
// `define SYS_CPU_2_IRQ_IN4_INTR_STAT_CLR     8'hbd
// `define SYS_CPU_2_IRQ_IN4_INTR_MASK         8'hbe
// `define SYS_CPU_2_IRQ_IN4_INTR_FIRQ_SEL     8'hbf
// ----------------------------------------------
// `define SYS_CPU_2_IRQ_IN0_INTR_STAT         8'hc0
// `define SYS_CPU_2_IRQ_IN0_INTR_STAT_CLR     8'hc1
// `define SYS_CPU_2_IRQ_IN0_INTR_MASK         8'hc2
// `define SYS_CPU_2_IRQ_IN0_INTR_FIRQ_SEL     8'hc3
// `define SYS_CPU_2_IRQ_IN1_INTR_STAT         8'hc4
// `define SYS_CPU_2_IRQ_IN1_INTR_STAT_CLR     8'hc5
// `define SYS_CPU_2_IRQ_IN1_INTR_MASK         8'hc6
// `define SYS_CPU_2_IRQ_IN1_INTR_FIRQ_SEL     8'hc7
// `define SYS_CPU_2_IRQ_IN2_INTR_STAT         8'hc8
// `define SYS_CPU_2_IRQ_IN2_INTR_STAT_CLR     8'hc9
// `define SYS_CPU_2_IRQ_IN2_INTR_MASK         8'hca
// `define SYS_CPU_2_IRQ_IN2_INTR_FIRQ_SEL     8'hcb
// `define SYS_CPU_2_IRQ_IN3_INTR_STAT         8'hcc
// `define SYS_CPU_2_IRQ_IN3_INTR_STAT_CLR     8'hcd
// `define SYS_CPU_2_IRQ_IN3_INTR_MASK         8'hce
// `define SYS_CPU_2_IRQ_IN3_INTR_FIRQ_SEL     8'hcf
// ----------------------------------------------
// `define SYS_CPU_3_IRQ_IN0_INTR_STAT         8'hd0
// `define SYS_CPU_3_IRQ_IN0_INTR_STAT_CLR     8'hd1
// `define SYS_CPU_3_IRQ_IN0_INTR_MASK         8'hd2
// `define SYS_CPU_3_IRQ_IN0_INTR_FIRQ_SEL     8'hd3
// `define SYS_CPU_3_IRQ_IN1_INTR_STAT         8'hd4
// `define SYS_CPU_3_IRQ_IN1_INTR_STAT_CLR     8'hd5
// `define SYS_CPU_3_IRQ_IN1_INTR_MASK         8'hd6
// `define SYS_CPU_3_IRQ_IN1_INTR_FIRQ_SEL     8'hd7
// `define SYS_CPU_3_IRQ_IN2_INTR_STAT         8'hd8
// `define SYS_CPU_3_IRQ_IN2_INTR_STAT_CLR     8'hd9
// `define SYS_CPU_3_IRQ_IN2_INTR_MASK         8'hda
// `define SYS_CPU_3_IRQ_IN2_INTR_FIRQ_SEL     8'hdb
// `define SYS_CPU_3_IRQ_IN3_INTR_STAT         8'hdc
// `define SYS_CPU_3_IRQ_IN3_INTR_STAT_CLR     8'hdd
// `define SYS_CPU_3_IRQ_IN3_INTR_MASK         8'hde
// `define SYS_CPU_3_IRQ_IN3_INTR_FIRQ_SEL     8'hdf
// ----------------------------------------------
// `define SYS_CPU_3_IRQ_IN4_INTR_STAT         8'he0
// `define SYS_CPU_3_IRQ_IN4_INTR_STAT_CLR     8'he1
// `define SYS_CPU_3_IRQ_IN4_INTR_MASK         8'he2
// `define SYS_CPU_3_IRQ_IN4_INTR_FIRQ_SEL     8'he3
// `define MEDIA_CPU_IRQ_IN5_INTR_STAT         8'he4
// `define MEDIA_CPU_IRQ_IN5_INTR_STAT_CLR     8'he5
// `define MEDIA_CPU_IRQ_IN5_INTR_MASK         8'he6
// `define MEDIA_CPU_IRQ_IN5_INTR_FIRQ_SEL     8'he7
// `define SYS_CPU_0_IRQ_IN5_INTR_STAT         8'he8
// `define SYS_CPU_0_IRQ_IN5_INTR_STAT_CLR     8'he9
// `define SYS_CPU_0_IRQ_IN5_INTR_MASK         8'hea
// `define SYS_CPU_0_IRQ_IN5_INTR_FIRQ_SEL     8'heb
//
// Closing file:  isa_reg.h
//
//
// Reading file:  bt656_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// BT656 0x2d  
// ----------------------------
// -----------------------------------------------
// CBUS_BASE:  BT656_CBUS_BASE = 0x13
// -----------------------------------------------
#define BT_CTRL                                    0x1340
    #define BT_SOFT_RESET           31      // Soft reset
    #define BT_JPEG_START           30  
    #define BT_JPEG_IGNORE_BYTES    18     //20:18
    #define BT_JPEG_IGNORE_LAST     17
    #define BT_UPDATE_ST_SEL        16 
    #define BT_COLOR_REPEAT         15
    #define BT_VIDEO_MODE           13     // 14:13
    #define BT_AUTO_FMT             12   
    #define BT_PROG_MODE            11
    #define BT_JPEG_MODE            10
    #define BT_XCLK27_EN_BIT        9      // 1 : xclk27 is input.     0 : xclk27 is output.
    #define BT_FID_EN_BIT           8       // 1 : enable use FID port.
    #define BT_CLK27_SEL_BIT        7       // 1 : external xclk27      0 : internal clk27.
    #define BT_CLK27_PHASE_BIT      6       // 1 : no inverted          0 : inverted.
    #define BT_ACE_MODE_BIT         5       // 1 : auto cover error by hardware.
    #define BT_SLICE_MODE_BIT       4       // 1 : no ancillay flag     0 : with ancillay flag.
    #define BT_FMT_MODE_BIT         3       // 1 : ntsc                 0 : pal.
    #define BT_REF_MODE_BIT         2       // 1 : from bit stream.     0 : from ports.
    #define BT_MODE_BIT             1       // 1 : BT656 model          0 : SAA7118 mode.
    #define BT_EN_BIT               0       // 1 : enable.
#define BT_VBISTART                                0x1341
#define BT_VBIEND                                  0x1342
#define BT_FIELDSADR                               0x1343
#define BT_LINECTRL                                0x1344
#define BT_VIDEOSTART                              0x1345
#define BT_VIDEOEND                                0x1346
#define BT_SLICELINE0                              0x1347
#define BT_SLICELINE1                              0x1348
#define BT_PORT_CTRL                               0x1349
  #define BT_HSYNC_PHASE      0
  #define BT_VSYNC_PHASE      1
  #define BT_HSYNC_PULSE      2
  #define BT_VSYNC_PULSE      3
  #define BT_FID_PHASE        4
  #define BT_FID_HSVS         5
  #define BT_IDQ_EN           6
  #define BT_IDQ_PHASE        7
  #define BT_D8B              8
  #define BT_10BTO8B          9
  #define BT_FID_DELAY       10    //12:10
  #define BT_VSYNC_DELAY     13    //
  #define BT_HSYNC_DELAY     16
#define BT_SWAP_CTRL                               0x134a
#define BT_ANCISADR                                0x134b
#define BT_ANCIEADR                                0x134c
#define BT_AFIFO_CTRL                              0x134d
#define BT_601_CTRL0                               0x134e
#define BT_601_CTRL1                               0x134f
#define BT_601_CTRL2                               0x1350
#define BT_601_CTRL3                               0x1351
#define BT_FIELD_LUMA                              0x1352
#define BT_RAW_CTRL                                0x1353
#define BT_STATUS                                  0x1354
#define BT_INT_CTRL                                0x1355
#define BT_ANCI_STATUS                             0x1356
#define BT_VLINE_STATUS                            0x1357
#define BT_AFIFO_PTR                               0x1358
#define BT_JPEGBYTENUM                             0x1359
#define BT_ERR_CNT                                 0x135a
#define BT_JPEG_STATUS0                            0x135b
#define BT_JPEG_STATUS1                            0x135c
#define BT_LCNT_STATUS                             0x135d
#define BT_PCNT_STATUS                             0x135e
#define BT656_ADDR_END                             0x135f
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  bt656_reg.h
//
// TEMP DEFINES
// -----------------------------------------------
// CBUS_BASE:  PERIPHS4_CBUS_BASE = 0x24
// -----------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS5_CBUS_BASE = 0x25
// -----------------------------------------------
// For iq_om_width change for RealVideo
#define IQ_OM_WIDTH                                0x2510
//`define IQ_OM_WIDTH_12
#define DBG_ADDR_START                             0x2ff0
#define DBG_ADDR_END                               0x2fff
#define DBG_CTRL                                   0x2ff1
#define DBG_LED                                    0x2ff2
#define DBG_SWITCH                                 0x2ff3
#define DBG_VERSION                                0x2ff4
//========================================================================
//  Global Control Registers			    (12'h000 - 12'h0ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  RESET_CBUS_BASE = 0x11
// -----------------------------------------------
#define VERSION_CTRL                               0x1100
#define RESET0_REGISTER                            0x1101
#define RESET1_REGISTER                            0x1102
#define RESET2_REGISTER                            0x1103
#define RESET3_REGISTER                            0x1104
#define RESET4_REGISTER                            0x1105
#define RESET5_REGISTER                            0x1106
#define RESET6_REGISTER                            0x1107
#define RESET7_REGISTER                            0x1108
#define RESET0_MASK                                0x1110
#define RESET1_MASK                                0x1111
#define RESET2_MASK                                0x1112
#define RESET3_MASK                                0x1113
#define RESET4_MASK                                0x1114
#define RESET5_MASK                                0x1115
#define RESET6_MASK                                0x1116
#define CRT_MASK                                   0x1117
#define RESET7_MASK                                0x1118
#define RESET0_LEVEL                               0x1120
#define RESET1_LEVEL                               0x1121
#define RESET2_LEVEL                               0x1122
#define RESET3_LEVEL                               0x1123
#define RESET4_LEVEL                               0x1124
#define RESET5_LEVEL                               0x1125
#define RESET6_LEVEL                               0x1126
#define RESET7_LEVEL                               0x1127
//======================================
//  Reset Register Bits	
//
//======================================
    #define HIU_RESET	    0x0001
    #define VLD_RESET	    0x0002
    #define IQIDCT_RESET	0x0004
    #define MC_RESET	    0x0008
    #define DCU_RESET	    0x0010
    #define VIU_RESET	    0x0020
    #define AIU_RESET	    0x0040
    #define CPU_RESET	    0x0080
    #define AC3_RESET	    0x0100
    #define MPEG_RESET	    0x0200
//========================================================================
//  Host uP Interface				    (12'h100 - 12'h2ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  HIU_CBUS_BASE = 0x10
// -----------------------------------------------
#define SCR_HIU                                    0x100b
#define HPG_TIMER                                  0x100f
#define HHI_GP0_PLL_CNTL                           0x1010
#define HHI_GP0_PLL_CNTL2                          0x1011
#define HHI_GP0_PLL_CNTL3                          0x1012
#define HHI_GP0_PLL_CNTL4                          0x1013
#define HHI_GP0_PLL_CNTL5                          0x1014
#define HHI_GP1_PLL_CNTL                           0x1016
#define HHI_GP1_PLL_CNTL2                          0x1017
#define HHI_GP1_PLL_CNTL3                          0x1018
#define HHI_GP1_PLL_CNTL4                          0x1019
#define HHI_GP1_PLL_CNTL5                          0x101a
#define HHI_CADC_CNTL                              0x1020
#define HHI_CADC_CNTL2                             0x1021
#define HHI_CADC_CNTL3                             0x1022
#define HHI_CADC_CNTL4                             0x1023
#define HHI_CADC_CNTL5                             0x1024
#define HHI_CADC_CNTL6                             0x1025
#define HHI_DADC_CNTL                              0x1027
#define HHI_DADC_CNTL2                             0x1028
#define HHI_DADC_RDBK0_I                           0x1029
#define HHI_DADC_CNTL3                             0x102a
#define HHI_DADC_CNTL4                             0x102b
#define HARM_ASB_MB0                               0x1030
#define HARM_ASB_MB1                               0x1031
#define HARM_ASB_MB2                               0x1032
#define HARM_ASB_MB3                               0x1033
#define HASB_ARM_MB0                               0x1034
#define HASB_ARM_MB1                               0x1035
#define HASB_ARM_MB2                               0x1036
#define HASB_ARM_MB3                               0x1037
#define HHI_TIMER90K                               0x103b
#define HHI_MEM_PD_REG0                            0x1040
//VIU1
//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
#define HHI_VPU_MEM_PD_REG0                        0x1041
//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
#define HHI_VPU_MEM_PD_REG1                        0x1042
#define HHI_DEMOD_MEM_PD_REG                       0x1043
#define HHI_AUD_DAC_CTRL                           0x1044
// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
#define HHI_VIID_CLK_DIV                           0x104a
#define HHI_VIID_CLK_CNTL                          0x104b
#define HHI_VIID_DIVIDER_CNTL                      0x104c
// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
#define HHI_GCLK_MPEG0                             0x1050
#define HHI_GCLK_MPEG1                             0x1051
#define HHI_GCLK_MPEG2                             0x1052
#define HHI_GCLK_OTHER                             0x1054
#define HHI_GCLK_AO                                0x1055
#define HHI_SYS_CPU_CLK_CNTL1                      0x1057
// PLL Controls
#define HHI_VID_CLK_DIV                            0x1059
#define HHI_MPEG_CLK_CNTL                          0x105d
#define HHI_AUD_CLK_CNTL                           0x105e
#define HHI_VID_CLK_CNTL                           0x105f
#define HHI_WIFI_CLK_CNTL                          0x1060
#define HHI_WIFI_PLL_CNTL                          0x1061
#define HHI_WIFI_PLL_CNTL2                         0x1062
#define HHI_WIFI_PLL_CNTL3                         0x1063
#define HHI_AUD_CLK_CNTL2                          0x1064
#define HHI_VID_CLK_CNTL2                          0x1065
#define HHI_VID_DIVIDER_CNTL                       0x1066
#define HHI_SYS_CPU_CLK_CNTL                       0x1067
#define HHI_A9_CLK_CNTL                            (HHI_SYS_CPU_CLK_CNTL)
#define HHI_VID_PLL_CLK_DIV                        0x1068
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
#define HHI_MALI_CLK_CNTL                          0x106c
#define HHI_MIPI_PHY_CLK_CNTL                      0x106e
#define HHI_VPU_CLK_CNTL                           0x106f
#define HHI_OTHER_PLL_CNTL                         0x1070
#define HHI_OTHER_PLL_CNTL2                        0x1071
#define HHI_OTHER_PLL_CNTL3                        0x1072
#define HHI_HDMI_CLK_CNTL                          0x1073
#define HHI_DEMOD_CLK_CNTL                         0x1074
#define HHI_SATA_CLK_CNTL                          0x1075
#define HHI_ETH_CLK_CNTL                           0x1076
#define HHI_CLK_DOUBLE_CNTL                        0x1077
#define HHI_VDEC_CLK_CNTL                          0x1078
#define HHI_VDEC2_CLK_CNTL                         0x1079
#define HHI_VDEC3_CLK_CNTL                         0x107a
#define HHI_VDEC4_CLK_CNTL                         0x107b
// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
#define HHI_HDMI_AFC_CNTL                          0x107f
#define HHI_HDMIRX_CLK_CNTL                        0x1080
#define HHI_HDMIRX_AUD_CLK_CNTL                    0x1081
#define HHI_EDP_APB_CLK_CNTL                       0x1082
#define HHI_VID_PLL_MOD_CNTL0                      0x1084
#define HHI_VID_PLL_MOD_LOW_TCNT                   0x1085
#define HHI_VID_PLL_MOD_HIGH_TCNT                  0x1086
#define HHI_VID_PLL_MOD_NOM_TCNT                   0x1087
// Removed `define HHI_DDR_CLK_CNTL            8'h88 
#define HHI_32K_CLK_CNTL                           0x1089
#define HHI_GEN_CLK_CNTL                           0x108a
#define HHI_GEN_CLK_CNTL2                          0x108b
#define HHI_JTAG_CONFIG                            0x108e
#define HHI_VAFE_CLKXTALIN_CNTL                    0x108f
#define HHI_VAFE_CLKOSCIN_CNTL                     0x1090
#define HHI_VAFE_CLKIN_CNTL                        0x1091
#define HHI_TVFE_AUTOMODE_CLK_CNTL                 0x1092
#define HHI_VAFE_CLKPI_CNTL                        0x1093
#define HHI_VDIN_MEAS_CLK_CNTL                     0x1094
// `define HHI_PCM2_CLK_CNTL           8'h95
#define HHI_PCM_CLK_CNTL                           0x1096
#define HHI_NAND_CLK_CNTL                          0x1097
#define HHI_ISP_LED_CLK_CNTL                       0x1098
#define HHI_EDP_TX_PHY_CNTL0                       0x109c
#define HHI_EDP_TX_PHY_CNTL1                       0x109d
#define HHI_MPLL_CNTL                              0x10a0
#define HHI_MPLL_CNTL2                             0x10a1
#define HHI_MPLL_CNTL3                             0x10a2
#define HHI_MPLL_CNTL4                             0x10a3
#define HHI_MPLL_CNTL5                             0x10a4
#define HHI_MPLL_CNTL6                             0x10a5
#define HHI_MPLL_CNTL7                             0x10a6
#define HHI_MPLL_CNTL8                             0x10a7
#define HHI_MPLL_CNTL9                             0x10a8
#define HHI_MPLL_CNTL10                            0x10a9
#define HHI_ADC_PLL_CNTL                           0x10aa
#define HHI_ADC_PLL_CNTL2                          0x10ab
#define HHI_ADC_PLL_CNTL3                          0x10ac
#define HHI_ADC_PLL_CNTL4                          0x10ad
#define HHI_AUDCLK_PLL_CNTL                        0x10b0
#define HHI_AUDCLK_PLL_CNTL2                       0x10b1
#define HHI_AUDCLK_PLL_CNTL3                       0x10b2
#define HHI_AUDCLK_PLL_CNTL4                       0x10b3
#define HHI_AUDCLK_PLL_CNTL5                       0x10b4
#define HHI_AUDCLK_PLL_CNTL6                       0x10b5
#define HHI_L2_DDR_CLK_CNTL                        0x10b6
#define HHI_VDAC_CNTL0                             0x10bd
#define HHI_VDAC_CNTL1                             0x10be
#define HHI_SYS_PLL_CNTL                           0x10c0
#define HHI_SYS_PLL_CNTL2                          0x10c1
#define HHI_SYS_PLL_CNTL3                          0x10c2
#define HHI_SYS_PLL_CNTL4                          0x10c3
#define HHI_SYS_PLL_CNTL5                          0x10c4
#define HHI_DPLL_TOP_0                             0x10c6
#define HHI_DPLL_TOP_1                             0x10c7
#define HHI_HDMI_PLL_CNTL                          0x10c8
#define HHI_HDMI_PLL_CNTL2                         0x10c9
#define HHI_HDMI_PLL_CNTL3                         0x10ca
#define HHI_HDMI_PLL_CNTL4                         0x10cb
#define HHI_HDMI_PLL_CNTL5                         0x10cc
#define HHI_HDMI_PLL_CNTL6                         0x10cd
#define HHI_HDMI_PLL_CNTL_I                        0x10ce
#define HHI_DSI_LVDS_EDP_CNTL0                     0x10d1
#define HHI_DSI_LVDS_EDP_CNTL1                     0x10d2
#define HHI_CSI_PHY_CNTL0                          0x10d3
#define HHI_CSI_PHY_CNTL1                          0x10d4
#define HHI_CSI_PHY_CNTL2                          0x10d5
#define HHI_CSI_PHY_CNTL3                          0x10d6
#define HHI_CSI_PHY_CNTL4                          0x10d7
#define HHI_DIF_CSI_PHY_CNTL0                      0x10d8
#define HHI_DIF_CSI_PHY_CNTL1                      0x10d9
#define HHI_DIF_CSI_PHY_CNTL2                      0x10da
#define HHI_DIF_CSI_PHY_CNTL3                      0x10db
#define HHI_DIF_CSI_PHY_CNTL4                      0x10dc
#define HHI_DIF_CSI_PHY_CNTL5                      0x10dd
#define HHI_LVDS_TX_PHY_CNTL0                      0x10de
#define HHI_LVDS_TX_PHY_CNTL1                      0x10df
#define HHI_VID2_PLL_CNTL                          0x10e0
#define HHI_VID2_PLL_CNTL2                         0x10e1
#define HHI_VID2_PLL_CNTL3                         0x10e2
#define HHI_VID2_PLL_CNTL4                         0x10e3
#define HHI_VID2_PLL_CNTL5                         0x10e4
#define HHI_VID2_PLL_CNTL6                         0x10e5
#define HHI_HDMI_PHY_CNTL0                         0x10e8
#define HHI_HDMI_PHY_CNTL1                         0x10e9
#define HHI_HDMI_PHY_CNTL2                         0x10ea
#define HHI_HDMI_PHY_CNTL3                         0x10eb
#define HHI_VID_LOCK_CLK_CNTL                      0x10f2
#define HHI_ATV_DMD_SYS_CLK_CNTL                   0x10f3
#define HHI_HDMIRX_AUD_PLL_CNTL                    0x10f8
#define HHI_HDMIRX_AUD_PLL_CNTL2                   0x10f9
#define HHI_HDMIRX_AUD_PLL_CNTL3                   0x10fa
#define HHI_HDMIRX_AUD_PLL_CNTL4                   0x10fb
#define HHI_HDMIRX_AUD_PLL_CNTL5                   0x10fc
#define HHI_HDMIRX_AUD_PLL_CNTL6                   0x10fd
//-----------------------------------------------------------
// PARSER 
//-----------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PARSER_CBUS_BASE = 0x29
// -----------------------------------------------
// bit 31:8 -- es_pack_size
// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
// bit 5 -- es_write
// bit 4 -- es_passthrough
// bit 3 -- insert_before_es_write
// bit 2 -- discard_cmd
// bit 1 -- search_cmd
// bit 0 -- Parser Busy
#define PARSER_CONTROL                             0x2960
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define PARSER_FETCH_ADDR                          0x2961
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian 
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr 
//   4:3 cmd_wr_ptr 
//   2:0 cmd_number 
#define PARSER_FETCH_CMD                           0x2962
// 31:0 stop_fetch_addr
#define PARSER_FETCH_STOP_ADDR                     0x2963
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define PARSER_FETCH_LEVEL                         0x2964
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits) 
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define PARSER_CONFIG                              0x2965
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define PFIFO_WR_PTR                               0x2966
// bit 9:0 -- point to byte address
#define PFIFO_RD_PTR                               0x2967
// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
#define PFIFO_DATA                                 0x2968
// bit 31:0 -- parser search pattern 
#define PARSER_SEARCH_PATTERN                      0x2969
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define PARSER_SEARCH_MASK                         0x296a
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu 
// bit 7:0 -- Parser interrupt enable for Amrisc 
#define PARSER_INT_ENABLE                          0x296b
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based) 
#define PARSER_INT_STATUS                          0x296c
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define PARSER_SCR_CTL                             0x296d
// bit 31:0 SCR value
#define PARSER_SCR                                 0x296e
// bit 31:24 -- insert_loop_number
// bit 23:21 -- 
// bit 20:16 -- insert_byte_number 
// bit 15:0 -- discard number
#define PARSER_PARAMETER                           0x296f
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continous write to this address can write upto 16 bytes 
#define PARSER_INSERT_DATA                         0x2970
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define VAS_STREAM_ID                              0x2971
// Bit 31:0 -- VIDEO_DTS
#define VIDEO_DTS                                  0x2972
// Bit 31:0 -- VIDEO_PTS
#define VIDEO_PTS                                  0x2973
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define VIDEO_PTS_DTS_WR_PTR                       0x2974
// Bit 31:0 -- AUDIO_PTS
#define AUDIO_PTS                                  0x2975
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define AUDIO_PTS_WR_PTR                           0x2976
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:13 -- VIDEO2 Ees_write Endian
// bit 12 -- VIDEO2 using manual read point
// bit 11:9 -- SUB Ees_write Endian 
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian 
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian 
// bit 0 -- VIDEO using manual read point
#define PARSER_ES_CONTROL                          0x2977
// Bit 31:0 PFIFO_MONITOR
#define PFIFO_MONITOR                              0x2978
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_VIDEO_START_PTR                     0x2980
#define PARSER_VIDEO_END_PTR                       0x2981
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define PARSER_VIDEO_WP                            0x2982
#define PARSER_VIDEO_RP                            0x2983
#define PARSER_VIDEO_HOLE                          0x2984
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_AUDIO_START_PTR                     0x2985
#define PARSER_AUDIO_END_PTR                       0x2986
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define PARSER_AUDIO_WP                            0x2987
#define PARSER_AUDIO_RP                            0x2988
#define PARSER_AUDIO_HOLE                          0x2989
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_SUB_START_PTR                       0x298a
#define PARSER_SUB_END_PTR                         0x298b
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define PARSER_SUB_WP                              0x298c
#define PARSER_SUB_RP                              0x298d
#define PARSER_SUB_HOLE                            0x298e
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define PARSER_FETCH_INFO                          0x298f
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define PARSER_STATUS                              0x2990
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define PARSER_AV_WRAP_COUNT                       0x2991
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define WRRSP_PARSER                               0x2992
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug 
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug 
// --------------------------------------------
// PARSER_VIDEO2 DDR Interface
// --------------------------------------------
// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_VIDEO2_START_PTR                    0x2993
#define PARSER_VIDEO2_END_PTR                      0x2994
// --------------------------------------------
// PARSER_VIDEO2 Buffer Level Manager
// --------------------------------------------
#define PARSER_VIDEO2_WP                           0x2995
#define PARSER_VIDEO2_RP                           0x2996
#define PARSER_VIDEO2_HOLE                         0x2997
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO2_wrap_count
#define PARSER_AV2_WRAP_COUNT                      0x2998
// DDR registers
//`define USE_DDR2
//========================================================================
//  DVIN Registers				    (12'h2e0 - 12'h2ef)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  DVIN_CBUS_BASE = 0x12
// -----------------------------------------------
// Bit 31:12 Rsrv
// Bit 11:10 RW, vs_hs_tim_ctrl: Controls which edge of HS/VS the active pixel/line is related:
//                               bit[0]=0: start of active pixel is counted from the rising edge of HS;
//                               bit[0]=1: start of active pixel is counted from the falling edge of HS;
//                               bit[1]=0: start of active line is counted from the rising edge of VS;
//                               bit[1]=1: start of active line is counted from the falling edge of VS.
// Bit     9 RW, sample_clk_neg: 1=invert input dvin_clk
// Bit  8: 7 RW, mode_422to444: 0=No convertion; 1=Rsrv; 2=Convert 422 to 444, use previous C value; 3=Convert 422 to 444, use average C value.
// Bit  6: 5 RW, de_mode: 0x=ignore input DE signal, use internal detection to to determine active pixel;
//                        10=during active pixel, if DE is low, replace input data with the last good data before DE goes low;
//                        11=Active pixel is determined by DE, no internal detection.
// Bit     4 RW, ext_field_sel: 1=Select external input Field, 0=Use internal detected Field.
// Bit     3 RW, field_pol_inv: set to 1 if input Field is low active and ext_field_sel=1
// Bit     2 RW, de_pol_inv: set to 1 if input DE is low active
// Bit     1 RW, vs_pol_inv: set to 1 if input VS is low active
// Bit     0 RW, hs_pol_inv: set to 1 if input HS is low active
#define DVIN_FRONT_END_CTRL                        0x12e0
// Bit 31:28 Reserved
// Bit 27:16 RW, hs_lead_vs_odd_max: Criteria for HW detecting odd/even Field internally: max clock cycles allowed for HS
//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
// Bit 15:12 Reserved
// Bit 11: 0 RW, hs_lead_vs_odd_min: Criteria for HW detecting odd/even Field internally -- min clock cycles allowed for HS
//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
#define DVIN_HS_LEAD_VS_ODD                        0x12e1
// Bit 31:28 Reserved
// Bit 27:16 RW, active_start_pix_fo
// Bit 15:12 Reserved
// Bit 11: 0 RW, active_start_pix_fe
#define DVIN_ACTIVE_START_PIX                      0x12e2
// Bit 31:28 Reserved
// Bit 27:16 RW, active_start_line_fo
// Bit 15:12 Reserved
// Bit 11: 0 RW, active_start_line_fe
#define DVIN_ACTIVE_START_LINE                     0x12e3
// Bit 31:28 Reserved
// Bit 27:16 RW, field_height_m1
// Bit 15:12 Reserved
// Bit 11: 0 RW, line_width_m1
#define DVIN_DISPLAY_SIZE                          0x12e4
// Bit    31 Rsrv
// Bit    30 R,  vs_in_polarity: 0=active high; 1=active low.
// Bit    29 R,  hs_in_polarity: 0=active high; 1=active low.
// Bit    28 R,  field_odd
// Bit 27:16 R,  hs_lead_vs_cnt
// Bit 15: 4 Rsrv
// Bit  3: 1 RW, data_comp_map: Re-map input data to form YCbCr.
//                              0=YCbCr is {[29:20], [19:10], [ 9: 0]};
//                              1=YCbCr is {[29:20], [ 9: 0], [19:10]};
//                              2=YCbCr is {[ 9: 0], [29:20], [19:10]};
//                              3=YCbCr is {[19:10], [29:20], [ 9: 0]};
//                              4=YCbCr is {[19:10], [ 9: 0], [29:20]};
//                              5=YCbCr is {[ 9: 0], [19:10], [29:20]};
//                              6,7=Rsrv
// Bit     0 RW, dvin_enable
#define DVIN_CTRL_STAT                             0x12e5
//========================================================================
//  DOS registers				    APB allocation from 32'hd0050000
//
//========================================================================
//=======================================================================
// XIF module
// `include "xregs.h"
    #define X_INT_ADR           0x400
    #define GPIO_ADR            0x401
    #define GPIO_ADR_H8         0x402 
    #define WFIFO_DEPTH         8          
    #define WFIFO_PointerWidth  3
    #define WFIFO_WORDSIZE      32
// MAC module
// move them to cpu domain.
//`define CLR_ACC_MAC         12'h410   
//`define CLR_ACC_MAC2        12'h411   
//`define ACC_0               12'h412
//`define ACC_1               12'h413
//`define ACC_2               12'h414
//`define ACC_3               12'h415
//========================================================================
//  Audio Interface				    (12'h500 - 12'h5ff)
//
//========================================================================
//
// Reading file:  aregs.h
//
//========================================================================
//  Audio Interface                                 (8'h00 - 8'hff)
//  Modified : Xuyun Chen Jan 2001
//========================================================================
// Number of bytes expected per NON-PCM frame, including the header.
// 16 bits.  
// -----------------------------------------------
// CBUS_BASE:  AIU_CBUS_BASE = 0x15
// -----------------------------------------------
#define AIU_958_BPF                                0x1500
// Value of burst_info used in IEC958 preamble for a NON-PCM frame. See
// ATSC AC-3 spec Annex B. 16 bits.
#define AIU_958_BRST                               0x1501
// Value of length_code used in IEC958 preamble for an NON-PCM frame. See
// ATSC AC-3 spec Annex B. 16 bits.
#define AIU_958_LENGTH                             0x1502
// How many subframes to padd around the NON-PCM frame. This will 
// be set to 'd3072 if it is a AC-3 audio stream.
// 16 bits
#define AIU_958_PADDSIZE                           0x1503
// 16'd3072
// Misc. control settings for IEC958 interface
// Bit 15:14 pcm_sample_ctl, 00-pcm_no_sample, 01-pcm_sample_up, 10-pcm_sample_down, 11-pcm_sample_down_drop
// Bit 13: if true, force each audio data to left or right according to the bit attached with the audio data
//         This bit should be used with Register AIU_958_force_left(0x505) together
// Bit 12: if true, the U(user data) is from the stream otherwise it is filled by 
//                   zero while encoding iec958 frame
// Bit 11   : if true big endian(highword,lowword) otherwise little endian(lowword,highword)
//            for 32bit mode 
// Bit 10:8 : shift number for 32 bit mode
// Bit 7  : 32 bit mode turn on while This bit is true and Bit 1 is true 
// Bit 6:5 : Specifies output alignment for 16 bit pcm data.
//          00 : dout = {8'b0, din};
//          01 : dout = {4'b0, din, 4'b0};
//          10 : dout = {      din, 8'b0};
// Bit 4  : True if data should be sent out MSB first. LSB first is the
//          default in the spec.
// Bit 3  : True if msb should be extended (only used with 16 bit pcm data.)
// Bit 2  : True if msb of PCM data should be inverted.
// Bit 1  : True if PCM data is 16 bits wide. False if 24 bit or 32bit mode.
// Bit 0  : True if source data is non-PCM data. False if it is PCM data.
#define AIU_958_MISC                               0x1504
// 14'b0_0_0_000_0_0000001
// A write to this register specifies that the next pcm sample sent out
// of the iec958 interface should go into the _left_ channel.
#define AIU_958_FORCE_LEFT                         0x1505
//Read Only
//bit 6:0  how many data discarded in the last dma after one frame data finish transfering to AIU 
// should used together with register AIU_958_dcu_ff_ctrl
#define AIU_958_DISCARD_NUM                        0x1506
//bit 15:8  : A read from this register indicates the IEC958 FIFO count value 
//bit 7 :  ai_958_req_size if ture, set to 8 bits interface, used to handle odd frame continous read  
//bit 6 :  continue seeking and dont discard the rest data in one dma after frame end
//bit 5 :  if true, byte by byte seeking, otherwise word by word seeking
//bit 4 :  if true, the function for sync head seeking is enabled
//bit 3:2 :	IEC958 interrupt mode
// There are two conditions to generate interrupt. The First condition is that one frame data
// have been finished writing into FIFO. The second condition is at least some data of the current 
// frame have been read out(refer to Register AIU_958_ffrdout_thd)
//			00: interrupt is not generated
//			10:	interrupt is generated if the first condition is true 
//			01:	interrupt is generated if the second condition is true 
//			11:	interrupt is generated if both of the conditions are true 
//bit 1: fifo auto disable, High means after one frame data put into the FIFO, the FIFO
//					will automatically disabled
//bit 0: fifo enable
#define AIU_958_DCU_FF_CTRL                        0x1507
// 'b0_0_1_11_1_0
// channel status registers for Left channel
// chstat_l0[15:0] contains bits 15:0 of the channel status word. Note
// that bit zero of the channel status word is sent out first.
// chstat_l1[15:0] contains bits 31:16 of the channel status word.
#define AIU_958_CHSTAT_L0                          0x1508
#define AIU_958_CHSTAT_L1                          0x1509
// Control register for IEC958 interface
// Bit 9:8 what to do if there is a fifo underrun
//         00 => insert 24'h000000
//         01 => insert mute constant as defined below
//         10 => repeat last l/r samples
// Bit 7:5 mute constant
//         000 => 24'h000000
//         001 => 24'h800000
//         010 => 24'h080000
//         011 => 24'h008000
//         100 => 24'h000001
//         101 => 24'h000010
//         110 => 24'h000100
// Bit 4   mute left speaker
// Bit 3   mute right speaker
// Bit 2:1 swap channels
//         00 : L R => L R
//         01 : L R => L L
//         10 : L R => R R
//         11 : L R => R L
// Bit 0   Set this bit to hold iec958 interface after the current
//         subframe has been completely transmitted.
#define AIU_958_CTRL                               0x150a
// 10'b00_000_00_00_0
// A write operation to this register will cause one of the output samples
// to be repeated. This can be used to switch the left and the right
// channels.
#define AIU_958_RPT                                0x150b
// Channel swap and mute control register.
// Bit 15: Mute extra left channel
// Bit 14: Mute extra right channel
// Bit 13: Mute center
// Bit 12: Mute subwoofer
// Bit 11: Mute surround left
// Bit 10: Mute surround right
// Bit  9: Mute left
// Bit  8: Mute right
// Bit 7:6 Channel swap for xtra dac
// Bit 5:4 Channel swap for sub/center dac
// Bit 3:2 Channel swap for surround dac
// Bit 1:0 Channel swap for main l/r dac
// Channel swap possibilities:
// 00 : L R => L R
// 01 : L R => L L
// 10 : L R => R R
// 11 : L R => R L
#define AIU_I2S_MUTE_SWAP                          0x150c
// 16'b0
// Bit 0 : 0=> single two channel stream
//         1=> four two channel streams
#define AIU_I2S_SOURCE_DESC                        0x150d
// Median filter control register
// Bit 1:  0=> data is offset binary
//         1=> data is signed
// Bit 0:  enable median filter
#define AIU_I2S_MED_CTRL                           0x150e
// 2'b10
// Median filter threshold constant
// 16 bits
#define AIU_I2S_MED_THRESH                         0x150f
// 16'h8000
// Describes dac's connected to I2S interface
// Bit 7:  sign extend sample before downshift.
// Bit 6:4 payload downshift constant
// Bit 3:  mute constant
//         0 => 'h0000000
//         1 => 'h800000
// Bit 2:  send msb first
// Bit 1:0 Size of payload
//         Note that this parameter used to be called "size of dacs"
//         It is now called the payload size since a 24 bit payload can
//         actually be connected to any size of dac. The dac will simply
//         disregard the extra bits.
//         00 => 16 bit, alrclk = aoclk/32 
//         01 => 20 bit, alrclk = aoclk/40 
//         10 => 24 bit, alrclk = aoclk/48 
//		   11 => 24 bit, but alrclk = aoclk/64 
#define AIU_I2S_DAC_CFG                            0x1510
// 8'b0_000_1_1_10
// A write to this register will cause the interface to repeat the current
// sample. Can be used to regain synchronization.
// A read from this register indicates that the next sample to be sent
// out of the interface should go into the _left_ channel of the dac.
#define AIU_I2S_SYNC                               0x1511
// Misc regs
// Bit 4 if true, force each audio data to left or right according to the bit attached with the audio data
//         This bit should be used with Register AIU_i2s_sync(0x511) together
// Bit 3:  Same Audio source for IEC958 and I2s stream 0, both from i2s buffer 
// Bit 2:  Set this bit to put i2s interface in hold mode
// Bit 1:0 How to handle underruns
//         00 => send zeros
//         01 => send 'h800000
//         10 => repeat last samples
#define AIU_I2S_MISC                               0x1512
// 5'b0
// Bit 7:0 Audio output config.
//			2 bits for each dac, 7:6 for dac3, 5:4 for dac2,
//								 3:2 for dac1, 1:0 for dac0
//			For each 2bits: 00: connect channel0-1 to the dac
//							01: connect channel2-3 to the dac
//							10: connect channel4-5 to the dac
//							11: connect channel6-7 to the dac
#define AIU_I2S_OUT_CFG                            0x1513
// 8'b0_000000_0
#define AIU_I2S_FF_CTRL                            0x1514
// A write to this register resets the AIU
//Bit 3 reset slow domain iec958
//Bit 2 soft reset iec958 fast domain
//Bit 1 reset slow domain i2s
//Bit 0 soft reset i2s fast domain
#define AIU_RST_SOFT                               0x1515
// Clock generation control register
// Bit 15: enable_ddr_arb, set low to reset
// Bit 14:13 parser_A_addr_sel  00-A_addr_aififo2, 01-A_addr_iec958, 10-A_addr_aififo, 11-A_addr_i2s
// Bit 12: 958 divisor more, if true, divided by 2, 4, 6, 8
// Bit 11: amclk output divisor
//			0 => dont divide
//			1 => divide by 2		
// Bit 10: clock source selection
//        0 => aiclk from pin
//        1 => ai_pll_clk from pll
// Bit 9:8 alrclk skew
//         00 => alrclk transitions at the same time msb is sent
//         01 => alrclk transitions on the cycle before msb is sent
//         10 => alrclk transitions on the cycle after msb is sent
// Bit 7: invert alrclk
// Bit 6: invert aoclk
// Bit 5:4 958 divisor
//        00 => divide by 1
//        01 => divide by 2
//		  10 => divide by 3
//		  11 => divide by 4
// Bit 3:2 i2s divisor. NOTE: this value is ignored if AIU_clk_ctrl_more[5:0] != 0 
//         00 => divide by 1
//         01 => divide by 2
//         10 => divide by 4
//         11 => divide by 8
// Bit 1: enable 958 divider
// Bit 0: enable i2s divider
#define AIU_CLK_CTRL                               0x1516
// 13'b0_0_1_01_1_1_10_11_0_0
// Misc settings that determine the type of adc that is
// connected to the AIU. Reverb mode is deleted.
// Bit 12:  selects adc input
// Bit 11:10 adc size
//           00 => 16 bits
//           01 => 18 bits
//           10 => 20 bits
//           11 => 24 bits
// Bit 9:8   adc l/r swap mode
//           00 => stereo
//           01 => send the right adc input to both l and r speakers
//           01 => send the left adc input to both l and r speakers
//           11 => sum the left and right inputs and forward to
//                both speakers
// Bit 7:5 adata/lrclk skew mode
// Bit 4   1=>invert the adc's lrclk (This is the lrclk going _out_
//         of the chip.
// Bit 3   1=>Latch the data on the positive edge of the _internal_
//         aoclk.
// Bit 2   1=>adc data is in signed 2's complement mode
#define AIU_MIX_ADCCFG                             0x1517
// 12'b01_00_001_1_0_1_00
// Control register that can be changed dynamically. These control
// signals are synchronized internally.
// Bit 12:  if true, toggle each mixed audio data to left or right channel
// Bit 11:  abuf din left selection, if true, select bit 24 of the data from abuf
//		    otherwise select bit 25 of the data from abuf
// Bit 10:9  mix sync select, when music, mic and abuf are mixed togather, the main
//			 sync source can be selected
//     00: not sync source
//	   01: music data is the main sync source
//	   10: abuf input data is the main sync source
//	   11: music and abuf togather as the sync source
// Bit 8:  0=> data from abuf is offset binary
//         1=> data from abuf is signed
// Bit 7:6 the source for data from aiu to abuf 
//           00 => mic
//           01 => mic saled + abuf scaled 
//           10 => mic scaled + abuf scaled + music scaled
//			 11 => music
// Bit 5   channel from aiu to abuf is on
// Bit 4   channel from abuf to aiu is on
// Bit 3   mic is on
// Bit 2   music is on
// Bit 1   if true the mixed data are outputed to i2s dac channel,
//			otherwise the mixed data are outputed to IEC958 output 
// Bit 0   if true music source for mixing is from i2s buffer, 
//			otherwise music source is from iec958 buffer
#define AIU_MIX_CTRL                               0x1518
// 11'b01_1_01_0_0_0_1_1_1
// Bit    15 invert_audin_sclk.
// Bit    14 enable_adc_sclk.
// Bit 13: 8 divisor_adc_sclk.
// Bit     7 invert_acodec_adc_sclk.
// Bit     6 hdmitx_sel_aoclkx2: 0=Select cts_clk_i958 as AIU clk to hdmi_tx_audio_master_clk; 1=Select cts_aoclkx2_int as AIU clk to hdmi_tx_audio_master_clk;
// Bit  5: 0 More control on i2s divisor. For backward compatiblity, this value is ignored if is 0,
//           if non-zero, it takes effect over AIU_clk_ctrl[3:2].
//           0=i2s divisor will use the old value in AIU_clk_ctrl[3:2] (divide by 1/2/4/8)
//           1=divide by 2;
//           2=divide by 3;
//           3=divide by 4;
//           ... and so on ...
//           63=divide by 64.
#define AIU_CLK_CTRL_MORE                          0x1519
// A read from this register pops 16 bits of data off the 958
// fifo. A write has no effect.
#define AIU_958_POP                                0x151a
//gain register for mixing
// for each gain, 
//			 00000: x 0
//			 00001: x 1
//			 00010: x 2
//           00011: x 3
//			 00100: x 4
//			 00101: x 5
//			 00110: x 6
//			......
//           01110: x14
//           01111: x15
//           10000: x 0
//           10001: x 1/16
//           10010: x 2/16
//           10011: x 3/16
//           10100: x 4/16
//			......
//           11110: x 14/16
//           11111: x 15/16
//Bit 14:10 mic gain
//Bit 9:5 	abuf gain
//Bit 4:0 music gain
#define AIU_MIX_GAIN                               0x151b
// 15'b00001_00001_00001
//sync head seeking is supported. The  maxinium length of sync head is
//48-bit-wide.(in byte by byte seeking mode, the maximium is 44-bit-wide).
//It is consisted of 3 words (synword1_synword2_syncword3).
//You can configure the sync head pattern by using sync mask(mask1_mask2_mask3).  
//For example. AC-3 sync head is a 16-bit word(0b77), so syncword1 is set as 0b77, 
//mask1 is 0000(not set), mask2 and mask3 is all masked.
#define AIU_958_SYNWORD1                           0x151c
//16'h0b77  //ac-3 sync head
#define AIU_958_SYNWORD2                           0x151d
//16'h0000  
#define AIU_958_SYNWORD3                           0x151e
//16'h0000
#define AIU_958_SYNWORD1_MASK                      0x151f
//16'h0000 //16-bit ac-3 sync_head
#define AIU_958_SYNWORD2_MASK                      0x1520
//16'hffff
#define AIU_958_SYNWORD3_MASK                      0x1521
//16'hffff
//fifo read-out threshold, one condition to generate interrupt is met after fifo readout counter
//reach this value in a frame, please refer to register AIU_958_dcu_ff_ctrl
#define AIU_958_FFRDOUT_THD                        0x1522
//'h0004
//For pause burst sequence adding, one pause burst sequence is consist of a serious
// pause burst.
//This register defines the length of each pause burst in a pause burst sequence. The size of the
//preamble(Pa, Pb, Pc, Pd) is not counted, but the size of stuff data is counted.
#define AIU_958_LENGTH_PER_PAUSE                   0x1523
//'h0000
//This reigster defines the number of pause burst in a pause burst sequence.
//Bit 15  if true, one pause burst sequence will be added 
//Bit 14:0 the number of pause burst in a pause burst sequence
#define AIU_958_PAUSE_NUM                          0x1524
//'h0000
//The first 16-bit in the payload of pause burst sequence (gap_length)
#define AIU_958_PAUSE_PAYLOAD                      0x1525
//'h0000
//For auto pause function, when enabled, pause burst sequence will be automatically added if the data in
// 958 fifo is less than auto_pause threshold and if fifo is disabled.
//Bit 15   if true, auto pause function enable
//Bit 14   pause pack option, just for debugging and adding one option
//Bit 7:0  auto_pause threshold
#define AIU_958_AUTO_PAUSE                         0x1526
//'h0000
//pause burst sequence payload length( = AIU_958_pause_num * AIU_958_length_per_pause)
#define AIU_958_PAUSE_PD_LENGTH                    0x1527
//'h0000
// Bit 15:12 Rsrv.
// Bit 11: 0 dac_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
#define AIU_CODEC_DAC_LRCLK_CTRL                   0x1528
//'h002f
// Bit 15:14 Rsrv.
// Bit    13 inv_audin_lrclk: whether to invert lrclk before output to Audin
// Bit    12 inv_acodec_adc_lrclk: whether to invert lrclk before output to Audio Codec
// Bit 11: 0 adc_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
#define AIU_CODEC_ADC_LRCLK_CTRL                   0x1529
//'h002f
// Bit 15:6 Rsrv.
// Bit  5: 4 hdmi_data_sel: 00=output 0, disable hdmi data; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
// Bit  3: 2 Rsrv.
// Bit  1: 0 hdmi_clk_sel: 00=Disable output hdmi clock; 01=Select pcm clock; 10=Select AIU clk; 11=Not allowed.
#define AIU_HDMI_CLK_DATA_CTRL                     0x152a
//'h0000
// Bit 15:6 Rsrv.
// Bit  5: 4 acodec_data_sel: 00=output 0, disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
// Bit  3: 2 Rsrv.
// Bit  1: 0 acodec_clk_sel: 00=Disable output acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
#define AIU_CODEC_CLK_DATA_CTRL                    0x152b
//'h0000
// channel status registers for right channel
// chstat_r0[15:0] contains bits 15:0 of the channel status word. Note
// that bit zero of the channel status word is sent out first.
// chstat_r1[15:0] contains bits 31:16 of the channel status word.
#define AIU_958_CHSTAT_R0                          0x1530
#define AIU_958_CHSTAT_R1                          0x1531
//Bit 1 	if true, turn on Digital output Valid control
//Bit 0		0: output 0, 1: output 1 to the valid bit in audio digital output when Bit 1 is true
#define AIU_958_VALID_CTRL                         0x1532
//-----------------------------------------------------------------------------
// Audio Amplifier controls
//-----------------------------------------------------------------------------
#define AIU_AUDIO_AMP_REG0                         0x153c
#define AIU_AUDIO_AMP_REG1                         0x153d
#define AIU_AUDIO_AMP_REG2                         0x153e
#define AIU_AUDIO_AMP_REG3                         0x153f
//-----------------------------------------------------------------------------
//add for AIFIFO2 channel
//-----------------------------------------------------------------------------
//Bit 3 	CRC pop aififo2 enable
//Bit 2		writing to this bit to 1 causes CRC module reset
//Bit 1		unused
//Bit 0		writing to this bit to 1 causes AIFIFO2 soft reset
#define AIU_AIFIFO2_CTRL                           0x1540
//'h0000
//AIFIFO2 status register
//Bit 4:0		//how many bits left in the first pop register
#define AIU_AIFIFO2_STATUS                         0x1541
//Same fucntion as the AIGBIT of AIFIFO in CDROM module
//write to this register how many bits wanna pop, 
//and reading this register gets the corresponding bits data
#define AIU_AIFIFO2_GBIT                           0x1542
//Same function as the AICLB of AIFIFO in CDROM module
//return the leading zeros by reading this registers
#define AIU_AIFIFO2_CLB                            0x1543
//CRC control register, read/write
//Bit 0		CRC caculation start
//Bit 1		CRC core soft reset
//Bit 2		CRC input register clear
//Bit 3		CRC pop data from FIFO enable
//Bit 13:8	CRC polynomial equation order, between 1 to 32
#define AIU_CRC_CTRL                               0x1544
//16'h1000
//CRC status register, read only
//Bit 7:4	CRC internal shift register bit select, just for debug purpose
//Bit 3		CRC internal shift register data valid, just for debug purpose
//Bit 2		CRC input register data valid
//Bit 1		CRC result, 1: CRC not correct, 0: CRC correct
//Bit 0		CRC state,  1: CRC busy, 0: CRC idle
#define AIU_CRC_STATUS                             0x1545
//CRC internal shift register, read only, for debug purpose
#define AIU_CRC_SHIFT_REG                          0x1546
//CRC data input register, read/write
#define AIU_CRC_IREG                               0x1547
//16'h0000
//CRC calculation register high-bit part [31:16], read/write
#define AIU_CRC_CAL_REG1                           0x1548
//CRC calculation register low-bit part [15:0], read/write
#define AIU_CRC_CAL_REG0                           0x1549
//32'h00000000
//CRC polynomial coefficient high-bit part [31:16], read/write
#define AIU_CRC_POLY_COEF1                         0x154a
//CRC polynomial coefficient low-bit part [15:0], read/write
#define AIU_CRC_POLY_COEF0                         0x154b
//32'h80050000			default CRC-16
//CRC frame size, high-bit part [19:16], read/write
#define AIU_CRC_BIT_SIZE1                          0x154c
//CRC frame size, low-bit part [15:0],	 read/write
#define AIU_CRC_BIT_SIZE0                          0x154d
//20'hfffff
//how many bits have been processed right now in the current frame, read only
//high-bit part [19:16]
#define AIU_CRC_BIT_CNT1                           0x154e
//low-bit part [15:0]
#define AIU_CRC_BIT_CNT0                           0x154f
// -------------------------------------
// AMCLK Measurement
// -------------------------------------
// Used to measure the amclk frequency
#define AIU_AMCLK_GATE_HI                          0x1550
#define AIU_AMCLK_GATE_LO                          0x1551
#define AIU_AMCLK_MSR                              0x1552
#define AIU_AUDAC_CTRL0                            0x1553
// -------------------------------------
// Super Simple Delta Sigma DAC
// -------------------------------------
// bit 15   1 = invert the clock to the analog filter
// bit 14   1 = digital mute
// bit 13   1 = enable analog mute (in the analog block)
// bit 12   1 = enable Right channel 3 in the analog block
// bit 11   1 = enable Left  channel 3 in the analog block
// bit 10   1 = enable Right channel 2 in the analog block
// bit  9   1 = enable Left  channel 2 in the analog block
// bit  8   1 = enable Right channel 1 in the analog block
// bit  7   1 = enable Left  channel 1 in the analog block
// bit  6   1 = enable Right channel 0 in the analog block
// bit  5   1 = enable Left  channel 0 in the analog block
// bit  4:  bit select for serial input data
// bit  3:  invert alrclk used by the delta-sigma DAC
// bit  2:  1 = use serial I2S data.  0 = use parallel audio data
// bits 1:0 Which data to send to the delta-sigma DAC
//              11 = use channel 3 data
//              10 = use channel 2 data
//              01 = use channel 1 data
//              00 = use channel 0 data
#define AIU_DELTA_SIGMA0                           0x1555
// Delta Sigma MUTE Value
#define AIU_DELTA_SIGMA1                           0x1556
// Additional Audio filter controls
#define AIU_DELTA_SIGMA2                           0x1557
//Bit 14, left channel Delta Sigma modulator soft reset
//Bit 13, right channel Delta Sigma modulator soft reset
//Bit 12, left channel Delta Sigma modulator internal state clear enable when it is unstable
//Bit 11, right channel Delta Sigma modulator internal state clear enable when it is unstable
//Bit 10, left channel Delta Sigma detect unstable state enable
//Bit  9, right channel Delta Sigma detect unstable state enable
//Bit  8, dither high pass filter enable in the Delta Sigma loop
//Bit 7:6, reserved
//Bit 5:0, Delta Sigma input data gain  0/32 ~ 63/32
//default: 16'h3
#define AIU_DELTA_SIGMA3                           0x1558
//15:8, Added Delta Sigma DC level, range:+-1/2, minimium: +-1/128 (assume max is -1 ~ +1)
//7:0, max same sequence number, used for unstable detection
//default: 16'h0
#define AIU_DELTA_SIGMA4                           0x1559
//Bit 15:8, square wave divide num
//Bit 7:0, square wave amplitude, -1/4 ~ 1/4, minimium: +-1/1024
//default: 16'h0
#define AIU_DELTA_SIGMA5                           0x155a
//Bit 11:8, loop dither amplitude2, 0/32 ~ 15/32
//Bit 7:4,  loop dither amplitude1, 0/32 ~ 15/32
//Bit 3:0,  loop dither amplitude0, 0/32 ~ 15/32
//default: 16'h0
#define AIU_DELTA_SIGMA6                           0x155b
//Bit 15:8, loop dithering threshold1   0, 1/512, 2/512 ... 1/2
//Bit 7:0,  loop dithering threshold0   0, 1/512, 2/512 ... 1/2
//default: 16'h0
#define AIU_DELTA_SIGMA7                           0x155c
//read only
//Bit 15:8  left channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
//          It will saturate to 255, if more than 255 time
//Bit 7:0   left channel max same sequence number
#define AIU_DELTA_SIGMA_LCNTS                      0x155d
//read only
//Bit 15:8  right channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
//          It will saturate to 255, if more than 255 time
//Bit 7:0   right channel max same sequence number
#define AIU_DELTA_SIGMA_RCNTS                      0x155e
// --------------------------------------------
// I2S DDR Interface
// --------------------------------------------
// The I2S start pointer into DDR memory is a 32-bit number
#define AIU_MEM_I2S_START_PTR                      0x1560
#define AIU_MEM_I2S_RD_PTR                         0x1561
#define AIU_MEM_I2S_END_PTR                        0x1562
// There are two masks that control how data is read:
// [31:16] IRQ block.
// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
#define AIU_MEM_I2S_MASKS                          0x1563
// I2S FIFO Control
// bits [11:10] Select which hardware pointer to use to control the buffer
//              level:
//                  00 = parser 
//                  01 = audin_fifo0_wrpt 
//                  1x = audin_fifo1_wrpt 
// bit  [9]     Use level control: 1 = use buffer level control
// bit  [8]     Read Only.  This bit is 1 when there is data available for reading
// bit  [7]     Read only.  This bit will be high when we're fetching data from the DDR memory
//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//              After that you can pulse cntl_init to start over
// bit  [6]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR
// bits [5:3]   endian:  see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading data from the FIFO
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
#define AIU_MEM_I2S_CONTROL                        0x1564
// --------------------------------------------
// IEC958 DDR Interface
// --------------------------------------------
// The IEC958 start pointer into DDR memory is a 32-bit number
#define AIU_MEM_IEC958_START_PTR                   0x1565
#define AIU_MEM_IEC958_RD_PTR                      0x1566
#define AIU_MEM_IEC958_END_PTR                     0x1567
// There are two masks that control how data is read:
// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
#define AIU_MEM_IEC958_MASKS                       0x1568
// IEC958 FIFO Control
// bit  [31]    A_urgent
// bit  [30]    ch_always_8
// bit  [29:24] rdata_rd_base_begin ( used for select from different channel ) 
// bit  [23:14] reserved
// bit  [13]    cntl_sim_en
// bit  [12]    cntl_use_level
// bit  [11]    Read only.      This bit will be set to 1 when there is data in the FIFO to process
// bit  [10]    Read only.  This bit will be high when we're fetching data from the DDR memory
//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//              After that you can pulse cntl_init to start over
// bit  [9]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to the rest of the IEC958 logic
// bit  [8]     mode_raw:       Set this bit to 1 to tell the IEC958 FIFO to read
//                              and process data linearly for raw data.  
// bit  [7]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR.  Only valid when mode_raw = 0
// bit  [6]     cntl_rd_ddr     Set this bit to read if you want AIU_MEM_IEC958_RD_PTR and
//                              AIU_MEM_IEC958_RD_PTR_HIGH to refer to the pointer into DDR memory.
//                              Otherwise, the curr_ptr registers refer to the byte address of the data
//                              at the output of the FIFO to the rest of the IEC958 logic
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
#define AIU_MEM_IEC958_CONTROL                     0x1569
// --------------------------------------------
// AIFIFO2 DDR Interface
// --------------------------------------------
// The AIFIFO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define AIU_MEM_AIFIFO2_START_PTR                  0x156a
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define AIU_MEM_AIFIFO2_CURR_PTR                   0x156b
#define AIU_MEM_AIFIFO2_END_PTR                    0x156c
#define AIU_MEM_AIFIFO2_BYTES_AVAIL                0x156d
// AIFIFO2 FIFO Control
// bit  [15:11] unused
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to getbit
// bit  [6]     unused  
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define AIU_MEM_AIFIFO2_CONTROL                    0x156e
// --------------------------------------------
// AIFIFO2 Buffer Level Manager
// --------------------------------------------
#define AIU_MEM_AIFIFO2_MAN_WP                     0x156f
#define AIU_MEM_AIFIFO2_MAN_RP                     0x1570
#define AIU_MEM_AIFIFO2_LEVEL                      0x1571
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define AIU_MEM_AIFIFO2_BUF_CNTL                   0x1572
// --------------------------------------------
// I2S Buffer Level Manager
// --------------------------------------------
#define AIU_MEM_I2S_MAN_WP                         0x1573
#define AIU_MEM_I2S_MAN_RP                         0x1574
#define AIU_MEM_I2S_LEVEL                          0x1575
//
// bit  [1]     mode            0 = parser (or audin_fifo0 or audin_fifo1), 
//                              1 for manual write pointer 
// bit  [0]     Init            Set high then low after everything has been initialized
#define AIU_MEM_I2S_BUF_CNTL                       0x1576
#define AIU_MEM_I2S_BUF_WRAP_COUNT                 0x1577
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define AIU_MEM_I2S_MEM_CTL                        0x1578
//-----------------------------------------------------------------------------
// Additional IEC958 registers (new feature)
//-----------------------------------------------------------------------------
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define AIU_MEM_IEC958_MEM_CTL                     0x1579
#define AIU_MEM_IEC958_WRAP_COUNT                  0x157a
#define AIU_MEM_IEC958_IRQ_LEVEL                   0x157b
#define AIU_MEM_IEC958_MAN_WP                      0x157c
#define AIU_MEM_IEC958_MAN_RP                      0x157d
#define AIU_MEM_IEC958_LEVEL                       0x157e
#define AIU_MEM_IEC958_BUF_CNTL                    0x157f
//-----------------------------------------------------------------------------
// add for AIFIFO channel (old $cdrom/rtl/cdr_top/getbit)
//-----------------------------------------------------------------------------
// Bit 3 	CRC pop aififo enable
// Bit 2		writing to this bit to 1 causes CRC module reset
// Bit 1		enable aififo
// Bit 0		writing to this bit to 1 causes aififo soft reset
#define AIU_AIFIFO_CTRL                            0x1580
//'h0000
// AIFIFO status register
// Bit 13		//aififo request to dcu status
// Bit 12		//dcu select status
// Bit 11:5		//aififo word counter number 
// Bit 4:0		//how many bits left in the first pop register
#define AIU_AIFIFO_STATUS                          0x1581
// Same fucntion as the AIGBIT of AIFIFO in CDROM module
// write to this register how many bits wanna pop, 
// and reading this register gets the corresponding bits data
#define AIU_AIFIFO_GBIT                            0x1582
// Same function as the AICLB of AIFIFO in CDROM module
// return the leading zeros by reading this registers
#define AIU_AIFIFO_CLB                             0x1583
// --------------------------------------------
// AIFIFO DDR Interface
// --------------------------------------------
// The AIFIFO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define AIU_MEM_AIFIFO_START_PTR                   0x1584
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define AIU_MEM_AIFIFO_CURR_PTR                    0x1585
#define AIU_MEM_AIFIFO_END_PTR                     0x1586
#define AIU_MEM_AIFIFO_BYTES_AVAIL                 0x1587
// AIFIFO FIFO Control
// bit  [15:11] unused
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to getbit
// bit  [6]     unused  
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define AIU_MEM_AIFIFO_CONTROL                     0x1588
// --------------------------------------------
// AIFIFO Buffer Level Manager
// --------------------------------------------
#define AIU_MEM_AIFIFO_MAN_WP                      0x1589
#define AIU_MEM_AIFIFO_MAN_RP                      0x158a
#define AIU_MEM_AIFIFO_LEVEL                       0x158b
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define AIU_MEM_AIFIFO_BUF_CNTL                    0x158c
#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT              0x158d
#define AIU_MEM_AIFIFO2_BUF_WRAP_COUNT             0x158e
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define AIU_MEM_AIFIFO_MEM_CTL                     0x158f
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define AIFIFO_TIME_STAMP_CNTL                     0x1590
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define AIFIFO_TIME_STAMP_SYNC_0                   0x1591
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define AIFIFO_TIME_STAMP_SYNC_1                   0x1592
// bit 31:0 TIME_STAMP_0
#define AIFIFO_TIME_STAMP_0                        0x1593
// bit 31:0 TIME_STAMP_1
#define AIFIFO_TIME_STAMP_1                        0x1594
// bit 31:0 TIME_STAMP_2
#define AIFIFO_TIME_STAMP_2                        0x1595
// bit 31:0 TIME_STAMP_3
#define AIFIFO_TIME_STAMP_3                        0x1596
// bit 31:0 TIME_STAMP_LENGTH
#define AIFIFO_TIME_STAMP_LENGTH                   0x1597
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define AIFIFO2_TIME_STAMP_CNTL                    0x1598
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define AIFIFO2_TIME_STAMP_SYNC_0                  0x1599
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define AIFIFO2_TIME_STAMP_SYNC_1                  0x159a
// bit 31:0 TIME_STAMP_0
#define AIFIFO2_TIME_STAMP_0                       0x159b
// bit 31:0 TIME_STAMP_1
#define AIFIFO2_TIME_STAMP_1                       0x159c
// bit 31:0 TIME_STAMP_2
#define AIFIFO2_TIME_STAMP_2                       0x159d
// bit 31:0 TIME_STAMP_3
#define AIFIFO2_TIME_STAMP_3                       0x159e
// bit 31:0 TIME_STAMP_LENGTH
#define AIFIFO2_TIME_STAMP_LENGTH                  0x159f
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define IEC958_TIME_STAMP_CNTL                     0x15a0
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define IEC958_TIME_STAMP_SYNC_0                   0x15a1
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define IEC958_TIME_STAMP_SYNC_1                   0x15a2
// bit 31:0 TIME_STAMP_0
#define IEC958_TIME_STAMP_0                        0x15a3
// bit 31:0 TIME_STAMP_1
#define IEC958_TIME_STAMP_1                        0x15a4
// bit 31:0 TIME_STAMP_2
#define IEC958_TIME_STAMP_2                        0x15a5
// bit 31:0 TIME_STAMP_3
#define IEC958_TIME_STAMP_3                        0x15a6
// bit 31:0 TIME_STAMP_LENGTH
#define IEC958_TIME_STAMP_LENGTH                   0x15a7
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define AIU_MEM_AIFIFO2_MEM_CTL                    0x15a8
// --------------------------------------------
// CBUS_DDR interface for I2S_FAST
// --------------------------------------------
// bit[31:26] unused
// bit[25]      A_req       level
// bit[24]      data_req    If this bit is 1, then (a_req_cnt != 'h0)
// bit[23:16]   a_req_cnt   This value corresponds to the number of 32-bit words 
//                          requested by the i2s_fast() module
// bit[15:7]    unused
// bit[6]                   Set this bit to mux in the cbus_ddr_interface
// bit[5]                   Set this bit to allow back to back A_req's to be serviced
// bit[4]                   Set this bit to generate an IRQ on the first A_req
//                          If this bit is 0, then an IRQ is generated after all requests 
//                          are completed and how many 32-bit words to send is calculated.
// bit[3:1]                 Endian
// bit[0]                   Set this bit enable the cbus_ddr_interface
#define AIU_I2S_CBUS_DDR_CNTL                      0x15a9
// 32-bit data to write to the cbus_ddr interface
#define AIU_I2S_CBUS_DDR_WDATA                     0x15aa
// First address associated with the first request by the i2s_fast() to read DDR data
#define AIU_I2S_CBUS_DDR_ADDR                      0x15ab
//
// Closing file:  aregs.h
//
//========================================================================
//  CDROM Interface                                 (12'h600 - 12'h6ff)
//
//========================================================================
//========================================================================
//	registers for ge2d (12'h8a0 - 12'h8ff)
//========================================================================
//
// Reading file:  ge2d_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// GE2D Registers    0x8a0 - 0x8ff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  GE2D_CBUS_BASE = 0x18
// -----------------------------------------------
//Bit 31, destination bytemask only if destination bitmask is enable
//Bit 30, destination bitmask enable
//Bit 29, source2 key  enable
//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 27, source1 key  enable
//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 25:24, dst1 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
//Bit 22:17,  reserved
//Bit 16:15, src2 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
//Bit 9:7    reserved
//Bit 6:5,   src1  8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
//Bit 3      src1 lookup table enable
//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
//Bit 0      src1 separate buffer enable
#define GE2D_GEN_CTRL0                             0x18a0
//Bit 31, soft rst
//Bit 30, dst write response counter reset  
//Bit 29, disable adding dst write response count to busy bit 
//Bit 28:26, reserved
//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
//Bit 23:22 src2 burst size control
//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords  
//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
//Bit 11, dst2 request urgent enable
//Bit 10, src1 request urgent enable
//Bit 9,  src2 request urgent enable
//Bit 8,  dst1 request urgent enable
//Bit 7:0 src1 global alpha
#define GE2D_GEN_CTRL1                             0x18a1
//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0; 
//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
//                 otherwise, color_out = (color < 128) ? color: color + 1;
//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs 
//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs 
//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs 
//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs 
//Bit 23     if true, dst little endian, otherwise big endian
//Bit 22:19 dst1 color_map
//        dst1_format=0                  : output 8-bit;
//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15    if true, src2 little endian, otherwise big endian
//Bit 14:11  src2 color_map
//        src2_format=0                 : output 8-bit;
//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
//Bit 7     if true, src1 little endian, otherwise big endian
//Bit 6:3   src1 color_map
//        src1_format=0                 : output 8-bit;
//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.     
//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit 
#define GE2D_GEN_CTRL2                             0x18a2
//Bit 9     if true, all src2 data use default color
//Bit 8     if true, all src1 data use default color
//Bit 7     if true, dst x/y swap 
//Bit 6     if true, dst x direction reversely read
//Bit 5     if true, dst y direction reversely read
//Bit 4     if true, src2 x direction reversely read
//Bit 3     if true, src2 y direction reversely read
//Bit 2     if true, src1 x direction reversely read
//Bit 1     if true, src1 y direction reversely read
//Bit 0     cmd write
#define GE2D_CMD_CTRL                              0x18a3
//Read only
//Bit 28:17 dst write response counter, for debug only
//Bit 16:7  ge2d_dp status, for debug only
//Bit 6     read src1 cmd ready
//Bit 5     read src2 cmd ready
//Bit 4     pre dpcmd ready
//Bit 3     ge2d dpcmd ready
//Bit 2     ge2d buffer command valid
//Bit 1     ge2d current command valid
//Bit 0     ge2d busy
#define GE2D_STATUS0                               0x18a4
//
//Read only
// Bit 29:16 ge2d_dst1_status, for debug only
// Bit    15 ge2d_rd_src2 core.fifo_empty
// Bit    14 ge2d_rd_src2 core.fifo_overflow
// Bit 13:12 ge2d_rd_src2 core.req_st
// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
#define GE2D_STATUS1                               0x18a5
//SRC1 default clolor
//{Y,Cb,Cr,A}/{R,G,B,A}
#define GE2D_SRC1_DEF_COLOR                        0x18a6
//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip x start
//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip x end
#define GE2D_SRC1_CLIPX_START_END                  0x18a7
//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip y start
//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip y end
#define GE2D_SRC1_CLIPY_START_END                  0x18a8
//Bit 31:24, SRC1 canvas address0
//Bit 23:16, SRC1 canvas address1
//Bit 15:8, SRC1 canvas address2
#define GE2D_SRC1_CANVAS                           0x18a9
//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
//             or x even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 29:16, SRC1 x start, signed data
//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
//             or x even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
//Bit 13:0, SRC1 x end, signed data
#define GE2D_SRC1_X_START_END                      0x18aa
//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
//             or y even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 28:16, SRC1 y start
//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
//             or y even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
//Bit 12:0, SRC1 y end
#define GE2D_SRC1_Y_START_END                      0x18ab
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define GE2D_SRC1_LUT_ADDR                         0x18ac
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define GE2D_SRC1_LUT_DAT                          0x18ad
//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
//Bit 18, horizontal formatter en
//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
//Bit 16, vertical formatter en
//Bit 15:8 X direction chroma phase,  
//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
//                or start/end even/odd chroma phase  when y/c ratio = 1 
//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
//Bit 7:0  Y direction chroma phase, 
//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
//          or start/end even/odd chroma phase  when y/c ratio = 1 
//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2 
#define GE2D_SRC1_FMT_CTRL                         0x18ae
//SRC2 default clolor
//{Y,Cb,Cr,A}/{R,G,B,A}
#define GE2D_SRC2_DEF_COLOR                        0x18af
//Bit 28:16, SRC2 clip x start
//Bit 12:0, SRC2 clip x end
#define GE2D_SRC2_CLIPX_START_END                  0x18b0
//Bit 28:16, SRC2 clip y start
//Bit 12:0, SRC2 clip y end
#define GE2D_SRC2_CLIPY_START_END                  0x18b1
//Bit 28:16, SRC2 x start
//Bit 12:0, SRC2 x end
#define GE2D_SRC2_X_START_END                      0x18b2
//Bit 28:16, SRC2 y start
//Bit 12:0, SRC2 y end
#define GE2D_SRC2_Y_START_END                      0x18b3
//Bit 28:16, DST clip x start
//Bit 12:0, DST clip x end
#define GE2D_DST_CLIPX_START_END                   0x18b4
//
//Bit 28:16, DST clip y start
//Bit 12:0, DST clip y end
#define GE2D_DST_CLIPY_START_END                   0x18b5
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define GE2D_DST_X_START_END                       0x18b6
//
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define GE2D_DST_Y_START_END                       0x18b7
//Bit 23:16 DST2 canvas address
//Bit 15:8 SRC2 canvas address
//Bit 7:0 DST1 canvas address
#define GE2D_SRC2_DST_CANVAS                       0x18b8
//vertical scaler phase step
//Bit 28:0,  5.24 format
#define GE2D_VSC_START_PHASE_STEP                  0x18b9
//phase slope 
//Bit 24:0, bit 24 signed bit
#define GE2D_VSC_PHASE_SLOPE                       0x18ba
//Bit 30:29, vertical repeat line0 number 
//Bit 23:0, vertical scaler initial phase
#define GE2D_VSC_INI_CTRL                          0x18bb
//horizontal scaler phase step
//Bit 28:0,  5.24 format
#define GE2D_HSC_START_PHASE_STEP                  0x18bc
//phase slope 
//Bit 24:0, bit 24 signed bit
#define GE2D_HSC_PHASE_SLOPE                       0x18bd
//Bit 30:29, horizontal repeat line0 number 
//Bit 23:0, horizontal scaler initial phase
#define GE2D_HSC_INI_CTRL                          0x18be
//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode 
#define GE2D_HSC_ADV_CTRL                          0x18bf
//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4 
//Bit 28, horizontal scaler dividing mode enable
//Bit 27:15, horizontal dividing length, if bit 28 is enable
//Bit 14, pre horizontal scaler enable 
//Bit 13, pre vertical scale enable
//Bit 12, vertical scale enable
//Bit 11, horizontal scaler enable
//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line, 
//        otherwise using treat horizontal repeat line number as minus line number. 
//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line, 
//        otherwise using treat vertical repeat line number as minus line number. 
//Bit 7, if true, always use phase0 in vertical scaler
//Bit 6:4, vertical scaler bank length
//Bit 3, if true, always use phase0 in horizontal scaler
//Bit 2:0, horizontal scaler bank length
#define GE2D_SC_MISC_CTRL                          0x18c0
//Read only
//vertical scaler next round integer pixel pointer, signed data
//Bit 13:0
#define GE2D_VSC_NRND_POINT                        0x18c1
//Read only
//vertical scaler next round phase
//bit 23:0
#define GE2D_VSC_NRND_PHASE                        0x18c2
//Read only
//horizontal scaler next round integer pixel pointer, signed data
//Bit 13:0
#define GE2D_HSC_NRND_POINT                        0x18c3
//Read only
//horizontal scaler next round phase
//bit 23:0
#define GE2D_HSC_NRND_PHASE                        0x18c4
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1 
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX_PRE_OFFSET                     0x18c5
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX_COEF00_01                      0x18c6
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX_COEF02_10                      0x18c7
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX_COEF11_12                      0x18c8
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX_COEF20_21                      0x18c9
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX_COEF22_CTRL                    0x18ca
//Bit 28:20, offset0
//Bit 18:10, offset1 
//Bit 8:0,   offset2
#define GE2D_MATRIX_OFFSET                         0x18cb
//Bit 26:25, SRC1 color multiplier alpha selection
//           if 00, Cs = Csr
//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
//           if 10, Cs = Csr * Ag (if source is premultipied)
//Bit 24    SRC2 color multiplier alpha selection 
//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.   
//Bit 22:12 ALU color operation
//          bit10:8 Blending Mode Parameter
//            3'b000: ADD               Cs*Fs + Cd*Fd
//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
//            3'b101: LOGIC OP          Cs op Cd
//          bit7:4 Source Color Blending Factor CFs
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 logic operations, when bit10:8 == LOGIC OP
//            4'b0000: CLEAR                       0
//            4'b0001: COPY                        s
//            4'b0010: NOOP                        d
//            4'b0011: SET                         1
//            4'b0100: COPY_INVERT                 ~s
//            4'b0101: INVERT                      ~d
//            4'b0110: AND_REVERSE                 s & ~d
//            4'b0111: OR_REVERSE                  s | ~d
//            4'b1000: AND                         s & d
//            4'b1001: OR                          s | d
//            4'b1010: NAND                        ~(s & d)
//            4'b1011: NOR                         ~(s | d)
//            4'b1100: XOR                         s ^ d
//            4'b1101: EQUIV                       ~(s ^ d)
//            4'b1110: AND_INVERTED                ~s & d
//            4'b1111: OR_INVERTED                 ~s | d
//Bit 10:0  ALU alpha operation
//            bit10:8 Blending Equation Math Operation
//              3'b000: ADD               As*Fs + Ad*Fd
//              3'b001: SUBTRACT          As*Fs - Ad*Fd
//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
//              3'b011: MIN               min(As*Fs, Ad*Fd)
//              3'b100: MAX               max(As*Fs, Ad*Fd)
//              3'b101: LOGIC OP          As op Ad
//            bit7:4 Source alpha Blending Factor AFs
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 logic operations, when bit10:8 == LOGIC OP
//              4'b0000: CLEAR                       0
//              4'b0001: COPY                        s
//              4'b0010: NOOP                        d
//              4'b0011: SET                         1
//              4'b0100: COPY_INVERT                 ~s
//              4'b0101: INVERT                      ~d
//              4'b0110: AND_REVERSE                 s & ~d
//              4'b0111: OR_REVERSE                  s | ~d
//              4'b1000: AND                         s & d
//              4'b1001: OR                          s | d
//              4'b1010: NAND                        ~(s & d)
//              4'b1011: NOR                         ~(s | d)
//              4'b1100: XOR                         s ^ d
//              4'b1101: EQUIV                       ~(s ^ d)
//              4'b1110: AND_INVERTED                ~s & d
//              4'b1111: OR_INVERTED                 ~s | d
#define GE2D_ALU_OP_CTRL                           0x18cc
//bit 31:0 (RGBA,YCBCRA)
#define GE2D_ALU_CONST_COLOR                       0x18cd
//SRC1 Key
//31:0 
#define GE2D_SRC1_KEY                              0x18ce
//SRC1 Key Mask
//31:0 
#define GE2D_SRC1_KEY_MASK                         0x18cf
//SRC2 Key
//31:0 
#define GE2D_SRC2_KEY                              0x18d0
//SRC2 Key Mask
//31:0 
#define GE2D_SRC2_KEY_MASK                         0x18d1
//Destination Bit Mask
//31:0 
#define GE2D_DST_BITMASK                           0x18d2
//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
//Bit 30:16     DP on counter
//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
//Bit 14:0      DP off counter
#define GE2D_DP_ONOFF_CTRL                         0x18d3
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define GE2D_SCALE_COEF_IDX                        0x18d4
//coefficients for vertical filter and horizontal filter
#define GE2D_SCALE_COEF                            0x18d5
//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
//                                for the area outside the clipping window. As below:
//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
//Bit 23:16 src2 outside alpha
//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above. 
//Bit 7:0   src1 outside alpha
#define GE2D_SRC_OUTSIDE_ALPHA                     0x18d6
//Bit 31       antiflick enable
//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha 
//Bit 23:16     register value for the first line alpha when bit 24 is 1 
//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha 
//Bit 7:0      register value for the last line alpha when bit 8 is 1 
#define GE2D_ANTIFLICK_CTRL0                       0x18d8
//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA 
//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
//Bit 23:16, R mult coef for converting RGB to Y
//Bit 15:8,  G mult coef for converting RGB to Y
//Bit 7:0,   B mult coef for converting RGB to Y
//Y = (R * y_r + G * y_g + B * y_b) / 256
#define GE2D_ANTIFLICK_CTRL1                       0x18d9
//Bit 31:24, Y threhold1, when   0<Y<=th1, use filter0;
//Bit 23:16, color antiflick filter0 n3
//Bit 15:8,  color antiflick filter0 n2
//Bit 7:0,   color antiflick filter0 n1
//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define GE2D_ANTIFLICK_COLOR_FILT0                 0x18da
//Bit 31:24, Y threhold2, when th1<Y<=th2, use filter1;
//Bit 23:16, color antiflick filter1 n3
//Bit 15:8,  color antiflick filter1 n2
//Bit 7:0,   color antiflick filter1 n1
#define GE2D_ANTIFLICK_COLOR_FILT1                 0x18db
//Bit 31:24, Y threhold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
//Bit 23:16, color antiflick filter2 n3
//Bit 15:8,  color antiflick filter2 n2
//Bit 7:0,   color antiflick filter2 n1
#define GE2D_ANTIFLICK_COLOR_FILT2                 0x18dc
//Bit 23:16, color antiflick filter3 n3
//Bit 15:8,  color antiflick filter3 n2
//Bit 7:0,   color antiflick filter3 n1
#define GE2D_ANTIFLICK_COLOR_FILT3                 0x18dd
//Bit 31:24, Alpha threhold1, when   0<Alpha<=th1, use filter0;
//Bit 23:16, Alpha antiflick filter0 n3
//Bit 15:8,  Alpha antiflick filter0 n2
//Bit 7:0,   Alpha antiflick filter0 n1
//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define GE2D_ANTIFLICK_ALPHA_FILT0                 0x18de
//Bit 31:24, Alpha threhold2, when th1<Alpha<=th2, use filter1;
//Bit 23:16, Alpha antiflick filter1 n3
//Bit 15:8,  Alpha antiflick filter1 n2
//Bit 7:0,   Alpha antiflick filter1 n1
#define GE2D_ANTIFLICK_ALPHA_FILT1                 0x18df
//Bit 31:24, Alpha threhold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
//Bit 23:16, Alpha antiflick filter2 n3
//Bit 15:8,  Alpha antiflick filter2 n2
//Bit 7:0,   Alpha antiflick filter2 n1
#define GE2D_ANTIFLICK_ALPHA_FILT2                 0x18e0
//Bit 23:16, Alpha antiflick filter3 n3
//Bit 15:8,  Alpha antiflick filter3 n2
//Bit 7:0,   Alpha antiflick filter3 n1
#define GE2D_ANTIFLICK_ALPHA_FILT3                 0x18e1
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_Y_CTRL                 0x18e3
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_CB_CTRL                0x18e4
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_CR_CTRL                0x18e5
//Bit 21:16     src1 prearbitor burst number
//Bit 13:8      src2 prearbitor burst number
//Bit 5:0       dst prearbitor burst number
#define GE2D_ARB_BURST_NUM                         0x18e6
//each 6bit ID, high 4bit are thread ID, low 2bits are the token
//Bit 21:16 src1 ID
//Bit 13:8 src2 ID
//Bit 5:0  dst ID
#define GE2D_TID_TOKEN                             0x18e7
//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
//Bit 25:24, dst2 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 22:19 dst2 color_map
//        dst2_format=0                  : output 8-bit;
//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15     reserved
//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     9 reserved
//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
//Bit  7: 6 reserved
//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     1 reserved
//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
#define GE2D_GEN_CTRL3                             0x18e8
//Read only
// Bit 13:0 ge2d_dst2_status, for debug only
#define GE2D_STATUS2                               0x18e9
//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
#define GE2D_GEN_CTRL4                             0x18ea
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ge2d_regs.h
//
//========================================================================
//  DSP Co-Processor Registers			    ( 8'he00 - 12'hfff)
//
//========================================================================
// Duplicate Address:  When actually used
// please move to a different address
// `define AUDIO_COP_CTL1      12'hf00  // r & w; r-> 6'h00,bsmod[2:0],acmod[2:0],lfeon,nfchans[2:0]
#define AUDIO_COP_CTL2                             0x1f01
//  f02 -f0d are special regs , not in ac3_reg.h, but used by CPU for AC3 operations
#define OPERAND_M_CTL                              0x1f02
#define OPERAND1_ADDR                              0x1f03
#define OPERAND2_ADDR                              0x1f04
#define RESULT_M_CTL                               0x1f05
#define RESULT1_ADDR                               0x1f06
#define RESULT2_ADDR                               0x1f07
#define ADD_SHFT_CTL                               0x1f08
#define OPERAND_ONE_H                              0x1f09
#define OPERAND_ONE_L                              0x1f0a
#define OPERAND_TWO_H                              0x1f0b
#define OPERAND_TWO_L                              0x1f0c
#define RESULT_H                                   0x1f0d
#define RESULT_M                                   0x1f0e
// special reg 
#define RESULT_L                                   0x1f0f
// 
#define WMEM_R_PTR                                 0x1f10
#define WMEM_W_PTR                                 0x1f11
#define AUDIO_LAYER                                0x1f20
#define AC3_DECODING                               0x1f21
#define AC3_DYNAMIC                                0x1f22
#define AC3_MELODY                                 0x1f23
#define AC3_VOCAL                                  0x1f24
//======================================
//  CPU Assist module
//
//======================================
// -----------------------------------------------
// CBUS_BASE:  ASSIST_CBUS_BASE = 0x1f
// -----------------------------------------------
//`define ASSIST_AMR_MBOX1_INT          8'h4d
//`define ASSIST_AMR_MBOX2_INT          8'h4e
#define ASSIST_AMR_SCRATCH0                        0x1f4f
#define ASSIST_AMR_SCRATCH1                        0x1f50
#define ASSIST_AMR_SCRATCH2                        0x1f51
#define ASSIST_AMR_SCRATCH3                        0x1f52
#define ASSIST_HW_REV                              0x1f53
//`define ASSIST_CBUS_ARB               8'h54
#define ASSIST_POR_CONFIG                          0x1f55
#define ASSIST_SPARE16_REG1                        0x1f56
#define ASSIST_SPARE16_REG2                        0x1f57
#define ASSIST_SPARE8_REG1                         0x1f58
#define ASSIST_SPARE8_REG2                         0x1f59
// Duplicate Address...when used please move to a new address
// `define TO_AMRISC_REG                 8'h59 // for amrisc
#define ASSIST_SPARE8_REG3                         0x1f5a
// Duplicate Address...when used please move to a new address
// `define FROM_AMRISC_REG               8'h5a // for amrisc
// Duplicate Address...when used please move to a new address
// `define MPEG2_DECODER_CONTROL         8'h5b // for amrisc
#define AC3_CTRL_REG1                              0x1f5b
#define AC3_CTRL_REG2                              0x1f5c
#define AC3_CTRL_REG3                              0x1f5d
#define AC3_CTRL_REG4                              0x1f5e
//`define ASSIST_PMEM_SPLIT             8'h5f
#define ASSIST_GEN_CNTL                            0x1f68
#define EE_ASSIST_MBOX0_IRQ_REG                    0x1f70
#define EE_ASSIST_MBOX0_CLR_REG                    0x1f71
#define EE_ASSIST_MBOX0_MASK                       0x1f72
#define EE_ASSIST_MBOX0_FIQ_SEL                    0x1f73
#define EE_ASSIST_MBOX1_IRQ_REG                    0x1f74
#define EE_ASSIST_MBOX1_CLR_REG                    0x1f75
#define EE_ASSIST_MBOX1_MASK                       0x1f76
#define EE_ASSIST_MBOX1_FIQ_SEL                    0x1f77
#define EE_ASSIST_MBOX2_IRQ_REG                    0x1f78
#define EE_ASSIST_MBOX2_CLR_REG                    0x1f79
#define EE_ASSIST_MBOX2_MASK                       0x1f7a
#define EE_ASSIST_MBOX2_FIQ_SEL                    0x1f7b
#define EE_ASSIST_MBOX3_IRQ_REG                    0x1f7c
#define EE_ASSIST_MBOX3_CLR_REG                    0x1f7d
#define EE_ASSIST_MBOX3_MASK                       0x1f7e
#define EE_ASSIST_MBOX3_FIQ_SEL                    0x1f7f
// -----------------------------------------------
// CBUS_BASE:  AUD_CBUS_BASE = 0x28
// -----------------------------------------------
// ----------------------------
// AUDIN (64)
// ----------------------------
#define AUDIN_SPDIF_MODE                           0x2800
    #define SPDIF_EN                31
    #define SPDIF_INT_EN            30
    #define SPDIF_BURST_PRE_INT_EN  29
    #define SPDIF_TIE_0             24
    #define SPDIF_SAMPLE_SEL        23
    #define SPDIF_REVERSE_EN        22
    #define SPDIF_BIT_ORDER         20
    #define SPDIF_CHNL_ORDER        19
    #define SPDIF_DATA_TYPE_SEL     18
    #define SPDIF_XTDCLK_UPD_ITVL   14   //16:14
    #define SPDIF_CLKNUM_54U        0     //13:0 
#define AUDIN_SPDIF_FS_CLK_RLTN                    0x2801
    #define SPDIF_CLKNUM_192K  24     //29:24 
    #define SPDIF_CLKNUM_96K   18     //23:18 
    #define SPDIF_CLKNUM_48K   12     //17:12 
    #define SPDIF_CLKNUM_44K   6     // 11:6
    #define SPDIF_CLKNUM_32K   0     // 5:0
#define AUDIN_SPDIF_CHNL_STS_A                     0x2802
#define AUDIN_SPDIF_CHNL_STS_B                     0x2803
#define AUDIN_SPDIF_MISC                           0x2804
#define AUDIN_SPDIF_NPCM_PCPD                      0x2805
#define AUDIN_SPDIF_END                            0x280f
#define AUDIN_I2SIN_CTRL                           0x2810
    #define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
    #define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
    #define I2SIN_LRCLK_SEL 2
    #define I2SIN_POS_SYNC  3
    #define I2SIN_LRCLK_SKEW 4    // 6:4
    #define I2SIN_LRCLK_INVT 7
    #define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
    #define I2SIN_CHAN_EN   10    //13:10. 
    #define I2SIN_EN        15
// Bit 31:15    Rsrv.
// Bit 14:12 RW HDMI-RX SPDIF channel status select to report on AUDIN_DECODE_CHANNEL_STATUS_A_*: 0=select channel 1; 1=channel 2; ...; 7=channel 8.
// Bit 11: 8 RW HDMI-RX SPDIF channel status extraction enable, 1-bit per channel pair. To enable, SPDIF input source also must select 1.
// Bit  7: 6    Rsrv.
// Bit  5: 4 RW SPDIF input source select. 0=Default, select chip external; 1=select HDMI RX output; 2/3=Rsrv.
// Bit  3: 2    Rsrv.
// Bit  1: 0 RW I2S input source select. 0=Default, select chip external; 1=select audio codec output; 2=select HDMI RX output; 3=Rsrv.
#define AUDIN_SOURCE_SEL                           0x2811
// The following registers control the new alternative decoder -- hdmi_tx_audio_decoder, in audin module
// Bit 31:25    Rsrv.
// Bit    24 RW SPDIF enable.
// Bit 23:22    Rsrv.
// Bit 21:20 RW i2s_block_start_src: 0=left channel 0 is approved as block start generator, ..., 3=left channel 3 is the block start generator.
// Bit 19:17    Rsrv.
// Bit    16 RW I2S enable.
// Bit 15: 8 RW audio_channel_alloc: Usage indication of up to 8 channels. If the correspoinding bit is 1, then this channel is used.
//                                   E.g.: In 2-channel audio, it is 00000011
// Bit     7 RW hdmi_tx_audio_decoder input sel: 0=SPDIF; 1=I2S.
// Bit     6 RW i2s_channel_config: 0=2-channel; 1=8-channel.
// Bit  5: 4 RW i2s_format_select: 0=left-justify; 1=right-justify; 2=I2S format; 3=DSP format.
// Bit  3: 2 RW i2s_bit_width: 0=16-bit; 1=18-bit; 2=20-bit; 3=24-bit.
// Bit     1 RW ws polarity: 0=0 is left, 1 is right; 1=1 is left, 0 is right.
// Bit     0 RW For SPDIF mode, 0=use channel status from input data; 1=use channel status from registers;
//              For I2S mode, 0=one-bit audio; 1=I2S.
#define AUDIN_DECODE_FORMAT                        0x2812
// Bit 31:25    Rsrv.
// Bit    24 R  channel_status stablility indicator.
// Bit 23:16 RW Valid bits for audio sample packet. [7] for valid_sp3_right, [6] for valid_sp3_left, ..., [1] for valid_sp0_right, [0] for valid_sp0_left.
// Bit 15: 8 RW User bits for audio sample packet. [7] for user_sp3_right, [6] for user_sp3_left, ..., [1] for user_sp0_right, [0] for user_sp0_left.
// Bit  7: 4 RW cntl_init_discard: Number of initial hdmi_tx_audio_decoder samples to discard from reset.
// Bit     3 RW cntl_invert_i2s_lrclk: Invert WS before input to hdmi_tx_audio_decoder.
// Bit     2 RW audio_valid_overwrite: Valid bit selection in audio packet. 0=use input data; 1=use
// Bit     1 RW audio_user_overwrite: User bit selection in audio packet. 0=use input data; 1=use
// Bit     0 RW audio_sample_valid: sample non-flat indication. 0=flat, non-valid; 1=non-flat, valid.
#define AUDIN_DECODE_CONTROL_STATUS                0x2813
// IEC958 192-bit channel status: muxed between 8 channels, channel selection by AUDIN_SOURCE_SEL[14:12]
#define AUDIN_DECODE_CHANNEL_STATUS_A_0            0x2814
#define AUDIN_DECODE_CHANNEL_STATUS_A_1            0x2815
#define AUDIN_DECODE_CHANNEL_STATUS_A_2            0x2816
#define AUDIN_DECODE_CHANNEL_STATUS_A_3            0x2817
#define AUDIN_DECODE_CHANNEL_STATUS_A_4            0x2818
#define AUDIN_DECODE_CHANNEL_STATUS_A_5            0x2819
#define AUDIN_FIFO0_START                          0x2820
#define AUDIN_FIFO0_END                            0x2821
#define AUDIN_FIFO0_PTR                            0x2822
#define AUDIN_FIFO0_INTR                           0x2823
#define AUDIN_FIFO0_RDPTR                          0x2824
#define AUDIN_FIFO0_CTRL                           0x2825
    #define AUDIN_FIFO0_EN       0
    #define AUDIN_FIFO0_RST      1
    #define AUDIN_FIFO0_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
         
    #define AUDIN_FIFO0_DIN_SEL  3
            // 0     spdifIN
            // 1     i2Sin
            // 2     PCMIN
            // 3     HDMI in
            // 4     DEMODULATOR IN
    #define AUDIN_FIFO0_ENDIAN   8    //10:8   data endian control.
    #define AUDIN_FIFO0_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
    #define AUDIN_FIFO0_UG       15    // urgent request enable.
    #define AUDIN_FIFO0_HOLD0_EN  19  
    #define AUDIN_FIFO0_HOLD1_EN  20
    #define AUDIN_FIFO0_HOLD2_EN  21
    #define AUDIN_FIFO0_HOLD0_SEL 22   // 23:22
    #define AUDIN_FIFO0_HOLD1_SEL 24   // 25:24
    #define AUDIN_FIFO0_HOLD2_SEL 26   // 27:26
    #define AUDIN_FIFO0_HOLD_LVL  28   // 27:26


#define AUDIN_FIFO0_CTRL1                          0x2826
#define AUDIN_FIFO0_LVL0                           0x2827
#define AUDIN_FIFO0_LVL1                           0x2828
#define AUDIN_FIFO0_LVL2                           0x2829
#define AUDIN_FIFO0_REQID                          0x2830
#define AUDIN_FIFO0_WRAP                           0x2831
#define AUDIN_FIFO1_START                          0x2833
#define AUDIN_FIFO1_END                            0x2834
#define AUDIN_FIFO1_PTR                            0x2835
#define AUDIN_FIFO1_INTR                           0x2836
#define AUDIN_FIFO1_RDPTR                          0x2837
#define AUDIN_FIFO1_CTRL                           0x2838
    #define AUDIN_FIFO1_EN       0
    #define AUDIN_FIFO1_RST      1
    #define AUDIN_FIFO1_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
         
    #define AUDIN_FIFO1_DIN_SEL  3
            // 0     spdifIN
            // 1     i2Sin
            // 2     PCMIN
            // 3     HDMI in
            // 4     DEMODULATOR IN
    #define AUDIN_FIFO1_ENDIAN   8    //10:8   data endian control.
    #define AUDIN_FIFO1_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
    #define AUDIN_FIFO1_UG       15    // urgent request enable.
    #define AUDIN_FIFO1_HOLD0_EN  19  
    #define AUDIN_FIFO1_HOLD1_EN  20
    #define AUDIN_FIFO1_HOLD2_EN  21
    #define AUDIN_FIFO1_HOLD0_SEL 22   // 23:22
    #define AUDIN_FIFO1_HOLD1_SEL 24   // 25:24
    #define AUDIN_FIFO1_HOLD2_SEL 26   // 27:26
    #define AUDIN_FIFO1_HOLD_LVL  28   // 27:26
#define AUDIN_FIFO1_CTRL1                          0x2839
#define AUDIN_FIFO1_LVL0                           0x2840
#define AUDIN_FIFO1_LVL1                           0x2841
#define AUDIN_FIFO1_LVL2                           0x2842
#define AUDIN_FIFO1_REQID                          0x2843
#define AUDIN_FIFO1_WRAP                           0x2844
#define AUDIN_FIFO2_START                          0x2845
#define AUDIN_FIFO2_END                            0x2846
#define AUDIN_FIFO2_PTR                            0x2847
#define AUDIN_FIFO2_INTR                           0x2848
#define AUDIN_FIFO2_RDPTR                          0x2849
#define AUDIN_FIFO2_CTRL                           0x284a
#define AUDIN_FIFO2_CTRL1                          0x284b
#define AUDIN_FIFO2_LVL0                           0x284c
#define AUDIN_FIFO2_LVL1                           0x284d
#define AUDIN_FIFO2_LVL2                           0x284e
#define AUDIN_FIFO2_REQID                          0x284f
#define AUDIN_FIFO2_WRAP                           0x2850
#define AUDIN_INT_CTRL                             0x2851
#define AUDIN_FIFO_INT                             0x2852
#define PCMIN_CTRL0                                0x2860
#define PCMIN_CTRL1                                0x2861
//`define PCMIN1_CTRL0                     8'h62 
//`define PCMIN1_CTRL1                     8'h63 
#define PCMOUT_CTRL0                               0x2870
#define PCMOUT_CTRL1                               0x2871
#define PCMOUT_CTRL2                               0x2872
#define PCMOUT_CTRL3                               0x2873
//`define PCMOUT1_CTRL0                    8'h74
//`define PCMOUT1_CTRL1                    8'h75
//`define PCMOUT1_CTRL2                    8'h76
//`define PCMOUT1_CTRL3                    8'h77
#define AUDOUT_CTRL                                0x2880
#define AUDOUT_CTRL1                               0x2881
#define AUDOUT_BUF0_STA                            0x2882
#define AUDOUT_BUF0_EDA                            0x2883
#define AUDOUT_BUF0_WPTR                           0x2884
#define AUDOUT_BUF1_STA                            0x2885
#define AUDOUT_BUF1_EDA                            0x2886
#define AUDOUT_BUF1_WPTR                           0x2887
#define AUDOUT_FIFO_RPTR                           0x2888
#define AUDOUT_INTR_PTR                            0x2889
#define AUDOUT_FIFO_STS                            0x288a
//`define AUDOUT1_CTRL                     8'h90
//`define AUDOUT1_CTRL1                    8'h91
//`define AUDOUT1_BUF0_STA                 8'h92
//`define AUDOUT1_BUF0_EDA                 8'h93
//`define AUDOUT1_BUF0_WPTR                8'h94
//`define AUDOUT1_BUF1_STA                 8'h95
//`define AUDOUT1_BUF1_EDA                 8'h96
//`define AUDOUT1_BUF1_WPTR                8'h97
//`define AUDOUT1_FIFO_RPTR                8'h98
//`define AUDOUT1_INTR_PTR                 8'h99
//`define AUDOUT1_FIFO_STS                 8'h9a
//// Bit 31: 0 RW cntl_mute_val: Use this value during mute, if cntl_mute_mode=2.
//`define AUDIN_MUTE_VAL                 8'h35
#define AUDIN_HDMI_MEAS_CTRL                       0x28a0
#define AUDIN_HDMI_MEAS_CYCLES_M1                  0x28a1
#define AUDIN_HDMI_MEAS_INTR_MASKN                 0x28a2
#define AUDIN_HDMI_MEAS_INTR_STAT                  0x28a3
#define AUDIN_HDMI_REF_CYCLES_STAT_0               0x28a4
#define AUDIN_HDMI_REF_CYCLES_STAT_1               0x28a5
#define AUDIN_HDMIRX_AFIFO_STAT                    0x28a6
#define AUDIN_FIFO0_PIO_STS                        0x28b0
#define AUDIN_FIFO0_PIO_RDL                        0x28b1
#define AUDIN_FIFO0_PIO_RDH                        0x28b2
#define AUDIN_FIFO1_PIO_STS                        0x28b3
#define AUDIN_FIFO1_PIO_RDL                        0x28b4
#define AUDIN_FIFO1_PIO_RDH                        0x28b5
#define AUDIN_FIFO2_PIO_STS                        0x28b6
#define AUDIN_FIFO2_PIO_RDL                        0x28b7
#define AUDIN_FIFO2_PIO_RDH                        0x28b8
#define AUDOUT_FIFO_PIO_STS                        0x28b9
#define AUDOUT_FIFO_PIO_WRL                        0x28ba
#define AUDOUT_FIFO_PIO_WRH                        0x28bb
//`define AUDOUT1_FIFO_PIO_STS		8'hbc
//`define AUDOUT1_FIFO_PIO_WRL        	8'hbd
//`define AUDOUT1_FIFO_PIO_WRH        	8'hbe
#define AUD_RESAMPLE_CTRL0                         0x28bf
#define AUD_RESAMPLE_CTRL1                         0x28c0
#define AUD_RESAMPLE_STATUS                        0x28c1
#define AUDIN_ADDR_END                             0x28c2
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./register_map.h
//
//
// Reading file:  ./vcbus_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN   
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VDIN_VCBUS_BASE = 0x12
// -----------------------------------------------
//VDIN0        8'h00 - 8'h6f
//VDIN1        8'h70 - 8'hdf
#define VDIN0_OFFSET            0x00
#define VDIN1_OFFSET            0x70

#define VDIN_SCALE_COEF_IDX                        0x1200
#define VDIN_SCALE_COEF                            0x1201
//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
//bit 30,   mpeg_field info which can be written by software
//Bit 29,   force go_field, pulse signal
//Bit 28,   force go_line, pulse signal
//Bit 27,   enable mpeg_go_field input signal
//Bit 26:20, hold lines
//Bit 19,   delay go_field function enable
//Bit 18:12, delay go_field line number 
//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 5,   input window selection function enable
//Bit 4, enable VDIN common data input, otherwise there will be no video data input
//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: bt656 input, 3: component input, 4: tvdecoder input, 5: hdmi rx input, 6: digtial video input, 7: loopback from Viu1, 8: MIPI.
#define VDIN_COM_CTRL0                             0x1202
//Bit 28:16 active_max_pix_cnt, readonly
//Bit 12:0  active_max_pix_cnt_shadow, readonly
#define VDIN_ACTIVE_MAX_PIX_CNT_STATUS             0x1203
//Bit 28:16 go_line_cnt, readonly
//Bit 12:0  active_line_cnt, readonly
#define VDIN_LCNT_STATUS                           0x1204
//Readonly
//Bit [14:3] lfifo_buf_cnt
//Bit 2, vdin_direct_done status
//Bit 1, vdin_nr_done status
//Bit 0, field
#define VDIN_COM_STATUS0                           0x1205
//Readonly
//Bit 31, vdi4 fifo overflow
//Bit 29:24, vdi3_asfifo_cnt
//Bit 23, vdi3 fifo overflow
//Bit 21:16, vdi3_asfifo_cnt
//Bit 15, vdi2 fifo overflow
//Bit 13:8, vdi2_asfifo_cnt
//Bit 7, vdi1 fifo overflow
//Bit 5:0, vdi1_asfifo_cnt
#define VDIN_COM_STATUS1                           0x1206
//Bit 28:16 go_line_cnt_shadow, readonly
//Bit 12:0  active_line_cnt_shadow, readonly
#define VDIN_LCNT_SHADOW_STATUS                    0x1207
//each 8bit asfifo_ctrl is following:
//Bit 7, DE  enable 
//Bit 6, go field enable 
//Bit 5, go line enable 
//Bit 4, if true, negative active input vsync
//Bit 3, if true, negative active input hsync
//Bit 2, vsync soft reset fifo enable
//Bit 1, overflow status clear
//Bit 0 asfifo soft reset, level signal
//Bit 7:0 vdi1 asfifo_ctrl 
//Bit 23:16 vdi2 asfifo_ctrl 
#define VDIN_ASFIFO_CTRL0                          0x1208
//Bit 7:0 vdi3 asfifo_ctrl 
//Bit 23:16 vdi4 asfifo_ctrl 
#define VDIN_ASFIFO_CTRL1                          0x1209
//Bit 28:16 input width minus 1, after the window function
//Bit 12:0  output width minus 1
#define VDIN_WIDTHM1I_WIDTHM1O                     0x120a
//Bit 20:17 prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 16:15 sp422_mode, special mode for the component1 and component2, 00: normal case, 01: 32 64 32, 10: 0 64 64 0, 11: 16 96 16
//Bit 14:8, hsc_ini_pixi_ptr, signed data, only useful when short_lineo_en is true
//Bit 7, prehsc_en
//Bit 6, hsc_en,
//Bit 5, hsc_short_lineo_en, short line output enable
//Bit 4, hsc_nearest_en
//Bit 3, hsc_phase0_always_en
//Bit 2:0, hsc_bank_length
#define VDIN_SC_MISC_CTRL                          0x120b
//Bit 28:24, integer portion
//Bit 23:0, fraction portion
#define VDIN_HSC_PHASE_STEP                        0x120c
//Bit 30:29    hscale rpt_p0_num
//Bit 28:24    hscale ini_rcv_num
//Bit 23:0     hscale ini_phase
#define VDIN_HSC_INI_CTRL                          0x120d
//Read only
//Bit 23, vdi7 fifo overflow
//Bit 21:16, vdi7_asfifo_cnt
//Bit 15, vdi6 fifo overflow
//Bit 13:8, vdi6_asfifo_cnt
//Bit 7, vdi5 fifo overflow
//Bit 5:0, vdi5_asfifo_cnt
#define VDIN_COM_STATUS2                           0x120e
//Bit 25:16 asfifo decimate control
//Bit 25, if true, decimation counter sync with first valid DE in the field, 
//otherwise the decimation counter is not sync with external signal 
//Bit 24, decimation de enable
//Bit 23:20, decimation phase, which counter value use to decimate, 
//Bit 19:16, decimation number, 0: not decimation, 1: decimation 2, 2: decimation 3 .... 
//Bit 7:0 vdi5 asfifo_ctrl 
#define VDIN_ASFIFO_CTRL2                          0x120f
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing 
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing 
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define VDIN_MATRIX_CTRL                           0x1210
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VDIN_MATRIX_COEF00_01                      0x1211
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define VDIN_MATRIX_COEF02_10                      0x1212
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VDIN_MATRIX_COEF11_12                      0x1213
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VDIN_MATRIX_COEF20_21                      0x1214
#define VDIN_MATRIX_COEF22                         0x1215
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VDIN_MATRIX_OFFSET0_1                      0x1216
//Bit 10:0  offset2
#define VDIN_MATRIX_OFFSET2                        0x1217
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VDIN_MATRIX_PRE_OFFSET0_1                  0x1218
//Bit 10:0  pre_offset2
#define VDIN_MATRIX_PRE_OFFSET2                    0x1219
//12:0 lfifo_buf_size
#define VDIN_LFIFO_CTRL                            0x121a
#define VDIN_COM_GCLK_CTRL                         0x121b
//12:0 VDIN input interface width minus 1, before the window function, after the de decimation
#define VDIN_INTF_WIDTHM1                          0x121c
//Bit 15          //default== 0, urgent_ctrl_en
//Bit 14          //default== 0, urgent_wr, if true for write buffer
//Bit 13          //default== 0, out_inv_en
//Bit 12          //default == 0, urgent_ini_value
//Bit 11:6        //default == 0, up_th  up threshold
//Bit 5:0         //default == 0, dn_th  dn threshold
#define VDIN_LFIFO_URG_CTRL                        0x121e
//Bit 8, 1: discard data before line fifo, 0: normal mode
//Bit 7:0 Write chroma canvas address
#define VDIN_WR_CTRL2                              0x121f
//Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2. 0: Output every even pixels' CbCr;
//                                                            1: Output every odd pixels' CbCr;
//                                                            2: Output an average value per even&odd pair of pixels;
//                                                            3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
//Bit 29 no_clk_gate: disable vid_wr_mif clock gating function.
//Bit 28 clear write response counter in the vdin write memory interface 
//Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line end indication in the vdin write memory interface
//Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 23 vdin frame reset enble, if true, it will provide frame reset during go_field(vsync) to the modules after that 
//Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will reset during go_field (vsync)
//Bit 21 vdin direct write done status clear bit 
//Bit 20 vdin NR write done status clear bit 
//Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12); 1: Output CrCb (NV21).
//Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even lines' CbCr;
//                                                       1: Output every odd lines' CbCr;
//                                                       2: Reserved;
//                                                       3: Output all CbCr.
//Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4 to luma canvas,
//                             2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit 31:30, 17:16, and bit 18.
//Bit 11 vdin write canvas double buffer enable, means the canvas address will be latched by vsync before using 
//Bit 10 1: disable ctrl_reg write pulse which will reset internal counter. when bit 11 is 1, this bit should be 1.
//Bit 9 vdin write request urgent
//Bit 8 vdin write request enable
//Bit 7:0 Write luma canvas address
#define VDIN_WR_CTRL                               0x1220
//Bit 29, if true, horizontal reverse
//Bit 28:16 start
//Bit 12:0  end
#define VDIN_WR_H_START_END                        0x1221
//Bit 29, if true, vertical reverse
//Bit 28:16 start
//Bit 12:0  end
#define VDIN_WR_V_START_END                        0x1222
//Bit 24:20, integer portion
//Bit 19:0, fraction portion
#define VDIN_VSC_PHASE_STEP                        0x1223
//Bit 23, vsc_en, vertical scaler enable
//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
//Bit 20:16 ini skip_line_num
//Bit 15:0 vscaler ini_phase 
#define VDIN_VSC_INI_CTRL                          0x1224
//Bit 12:0, scaler input height minus 1
#define VDIN_SCIN_HEIGHTM1                         0x1225
//Bit 23:16, dummy component 0
//Bit 15:8, dummy component 1
//Bit 7:0, dummy component 2
#define VDIN_DUMMY_DATA                            0x1226
//Read only 
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VDIN_MATRIX_PROBE_COLOR                    0x1228
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VDIN_MATRIX_HL_COLOR                       0x1229
//28:16 probe x, postion
//12:0  probe y, position  
#define VDIN_MATRIX_PROBE_POS                      0x122a
#define VDIN_CHROMA_ADDR_PORT                      0x122b
#define VDIN_CHROMA_DATA_PORT                      0x122c
//
#define VDIN_CM_BRI_CON_CTRL                       0x122d
//Bit 17  clk_cyc_cnt_clr, if true, clear this register
//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt 
//Bit 15:0   line width using vpu clk
#define VDIN_GO_LINE_CTRL                          0x122f
//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din 
//Bit 8     ldim_stts_en
//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define VDIN_HIST_CTRL                             0x1230
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define VDIN_HIST_H_START_END                      0x1231
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define VDIN_HIST_V_START_END                      0x1232
//Bit 15:8  hist_max    maximum value 
//Bit 7:0   hist_min    minimum value 
//read only
#define VDIN_HIST_MAX_MIN                          0x1233
//Bit 31:0  hist_spl_rd
//counts for the total luma value 
//read only
#define VDIN_HIST_SPL_VAL                          0x1234
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define VDIN_HIST_SPL_PIX_CNT                      0x1235
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value 
//read only
#define VDIN_HIST_CHROMA_SUM                       0x1236
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
//VDIN_DNLP_HIST00[31:16] counts for the second bin
//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define VDIN_DNLP_HIST00                           0x1237
#define VDIN_DNLP_HIST01                           0x1238
#define VDIN_DNLP_HIST02                           0x1239
#define VDIN_DNLP_HIST03                           0x123a
#define VDIN_DNLP_HIST04                           0x123b
#define VDIN_DNLP_HIST05                           0x123c
#define VDIN_DNLP_HIST06                           0x123d
#define VDIN_DNLP_HIST07                           0x123e
#define VDIN_DNLP_HIST08                           0x123f
#define VDIN_DNLP_HIST09                           0x1240
#define VDIN_DNLP_HIST10                           0x1241
#define VDIN_DNLP_HIST11                           0x1242
#define VDIN_DNLP_HIST12                           0x1243
#define VDIN_DNLP_HIST13                           0x1244
#define VDIN_DNLP_HIST14                           0x1245
#define VDIN_DNLP_HIST15                           0x1246
#define VDIN_DNLP_HIST16                           0x1247
#define VDIN_DNLP_HIST17                           0x1248
#define VDIN_DNLP_HIST18                           0x1249
#define VDIN_DNLP_HIST19                           0x124a
#define VDIN_DNLP_HIST20                           0x124b
#define VDIN_DNLP_HIST21                           0x124c
#define VDIN_DNLP_HIST22                           0x124d
#define VDIN_DNLP_HIST23                           0x124e
#define VDIN_DNLP_HIST24                           0x124f
#define VDIN_DNLP_HIST25                           0x1250
#define VDIN_DNLP_HIST26                           0x1251
#define VDIN_DNLP_HIST27                           0x1252
#define VDIN_DNLP_HIST28                           0x1253
#define VDIN_DNLP_HIST29                           0x1254
#define VDIN_DNLP_HIST30                           0x1255
#define VDIN_DNLP_HIST31                           0x1256
//Bit 31, local dimming statistic enable
//Bit 28, eol enable
//Bit 27:25, vertical line overlap number for max finding
//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION 
//Bit 6:0, region read index
#define VDIN_LDIM_STTS_HIST_REGION_IDX             0x1257
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
#define VDIN_LDIM_STTS_HIST_SET_REGION             0x1258
//REGION STATISTIC DATA READ OUT PORT, bit 29:20 max_comp2, bit 19:10 max_comp1, bit 9:0 max_comp0
#define VDIN_LDIM_STTS_HIST_READ_REGION            0x1259
//Bit 18, reset bit, high active
//Bit 17, if true, widen hs/vs pulse
//Bit 16  vsync total counter always accumulating enable
//Bit 14:12, select hs/vs of video input channel to measure, 0: no selection, 1: vdi1, 2: vid2, 3: vid3, 4:vid4, 5:vdi5, 6:vid6, 7:vdi7, 8: vdi8
//Bit 11:4, vsync_span, define how many vsync span need to measure 
//Bit 2:0  meas_hs_index, index to select which HS counter/range
#define VDIN_MEAS_CTRL0                            0x125a
//Read only
//19:16     meas_ind_total_count_n, every number of sync_span vsyncs, this count add 1
//15:0      high bit portion of vsync total counter
#define VDIN_MEAS_VS_COUNT_HI                      0x125b
//Read only
//31:0, low bit portion of vsync total counter 
#define VDIN_MEAS_VS_COUNT_LO                      0x125c
//according to the meas_hs_index in register VDIN_MEAS_CTRL0
//meas_hs_index == 0, first hs range
//meas_hs_index == 1, second hs range
//meas_hs_index == 2, third hs range
//meas_hs_index == 3, fourth hs range 
//bit 28:16 count_start
//bit 12:0 count_end
#define VDIN_MEAS_HS_RANGE                         0x125d
//Read only
//according to the meas_hs_index in register VDIN_MEAS_CTRL0,
//meas_hs_index == 0, first range hs counter,
//meas_hs_index == 1, second range hs coutner
//meas_hs_index == 2, third range hs coutner
//meas_hs_index == 3, fourth range hs coutner
//23:0
#define VDIN_MEAS_HS_COUNT                         0x125e
//Bit 8      white_enable
//Bit 7:0    blkbar_white_level
#define VDIN_BLKBAR_CTRL1                          0x125f
// Bit 31:24 blkbar_black_level    threshold to judge a black point
// Bit 23:21 Reserved
// Bit 20:8  blkbar_hwidth         left and right region width
// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
// Bit 3     blkbar_det_en       
// Bit 2:1   blkbar_din_sel        
// bit blkbar_det_top_en
#define VDIN_BLKBAR_CTRL0                          0x1260
// Bit 31:29 Reserved
// Bit 28:16 blkbar_hstart.        Left region start
// Bit 15:13 Reserved
// Bit 12:0  blkbar_hend.          Right region end
#define VDIN_BLKBAR_H_START_END                    0x1261
// Bit 31:29 Reserved
// Bit 28:16 blkbar_vstart        
// Bit 15:13 Reserved
// Bit 12:0  blkbar_vend
#define VDIN_BLKBAR_V_START_END                    0x1262
// Bit 31:20 Reserved
// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black  
#define VDIN_BLKBAR_CNT_THRESHOLD                  0x1263
// Bit 31:29 Reserved
// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
// Bit 15:13 Reserved
// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
#define VDIN_BLKBAR_ROW_TH1_TH2                    0x1264
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
#define VDIN_BLKBAR_IND_LEFT_START_END             0x1265
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
#define VDIN_BLKBAR_IND_RIGHT_START_END            0x1266
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
#define VDIN_BLKBAR_IND_LEFT1_CNT                  0x1267
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. right part of the left region
#define VDIN_BLKBAR_IND_LEFT2_CNT                  0x1268
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
#define VDIN_BLKBAR_IND_RIGHT1_CNT                 0x1269
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
#define VDIN_BLKBAR_IND_RIGHT2_CNT                 0x126a
//Readonly
// Bit 31:30 Resersed
// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
// Bit 28:16 blkbar_top_pos.            Top black bar position
// Bit 15:13 Reserved.
// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
#define VDIN_BLKBAR_STATUS0                        0x126b
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_left_pos.       Left black bar posiont
// Bit 15:13 Reserved
// Bit 12:0  blkbar_right_pos.      Right black bar position
#define VDIN_BLKBAR_STATUS1                        0x126c
//Bit 28:16 input window H start
//Bit 12:0  input window H end
#define VDIN_WIN_H_START_END                       0x126d
//Bit 28:16 input window H start
//Bit 12:0  input window V start
#define VDIN_WIN_V_START_END                       0x126e
//Bit 23:16 vdi8 asfifo_ctrl 
//Bit 15:8 vdi7 asfifo_ctrl 
//Bit 7:0 vdi6 asfifo_ctrl 
#define VDIN_ASFIFO_CTRL3                          0x126f

//VDIN0        8'h00 - 8'h7f
#define VDIN0_SCALE_COEF_IDX                    ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
#define VDIN0_SCALE_COEF                        ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF                   )
#define VDIN0_COM_CTRL0                         ((VDIN0_OFFSET << 2) + VDIN_COM_CTRL0                    )
#define VDIN0_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN0_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN0_LCNT_STATUS                       ((VDIN0_OFFSET << 2) + VDIN_LCNT_STATUS                  )
#define VDIN0_COM_STATUS0                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS0                  )
#define VDIN0_COM_STATUS1                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS1                  )
#define VDIN0_LCNT_SHADOW_STATUS                ((VDIN0_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
#define VDIN0_ASFIFO_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
#define VDIN0_ASFIFO_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
#define VDIN0_WIDTHM1I_WIDTHM1O                 ((VDIN0_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN0_SC_MISC_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
#define VDIN0_HSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
#define VDIN0_HSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
#define VDIN0_COM_STATUS2                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS2                  )
#define VDIN0_ASFIFO_CTRL2                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
#define VDIN0_MATRIX_CTRL                       ((VDIN0_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
#define VDIN0_MATRIX_COEF00_01                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
#define VDIN0_MATRIX_COEF02_10                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
#define VDIN0_MATRIX_COEF11_12                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
#define VDIN0_MATRIX_COEF20_21                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
#define VDIN0_MATRIX_COEF22                     ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF22                )
#define VDIN0_MATRIX_OFFSET0_1                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
#define VDIN0_MATRIX_OFFSET2                    ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
#define VDIN0_MATRIX_PRE_OFFSET0_1              ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN0_MATRIX_PRE_OFFSET2                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN0_LFIFO_CTRL                        ((VDIN0_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
#define VDIN0_COM_GCLK_CTRL                     ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
#define VDIN0_INTF_WIDTHM1                      ((VDIN0_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
#define VDIN0_WR_CTRL2                          ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL2                     )
#define VDIN0_WR_CTRL                           ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL                      )
#define VDIN0_WR_H_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_H_START_END               )
#define VDIN0_WR_V_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_V_START_END               )
#define VDIN0_VSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
#define VDIN0_VSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
#define VDIN0_SCIN_HEIGHTM1                     ((VDIN0_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
#define VDIN0_DUMMY_DATA                        ((VDIN0_OFFSET << 2) + VDIN_DUMMY_DATA                   )
#define VDIN0_MATRIX_PROBE_COLOR                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
#define VDIN0_MATRIX_HL_COLOR                   ((VDIN0_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
#define VDIN0_MATRIX_PROBE_POS                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
#define VDIN0_CHROMA_ADDR_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
#define VDIN0_CHROMA_DATA_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
#define VDIN0_CM_BRI_CON_CTRL                   ((VDIN0_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
#define VDIN0_HIST_CTRL                         ((VDIN0_OFFSET << 2) + VDIN_HIST_CTRL                    )
#define VDIN0_HIST_H_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_H_START_END             )
#define VDIN0_HIST_V_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_V_START_END             )
#define VDIN0_HIST_MAX_MIN                      ((VDIN0_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
#define VDIN0_HIST_SPL_VAL                      ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
#define VDIN0_HIST_SPL_PIX_CNT                  ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
#define VDIN0_HIST_CHROMA_SUM                   ((VDIN0_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
#define VDIN0_DNLP_HIST00                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST00                  )
#define VDIN0_DNLP_HIST01                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST01                  )
#define VDIN0_DNLP_HIST02                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST02                  )
#define VDIN0_DNLP_HIST03                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST03                  )
#define VDIN0_DNLP_HIST04                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST04                  )
#define VDIN0_DNLP_HIST05                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST05                  )
#define VDIN0_DNLP_HIST06                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST06                  )
#define VDIN0_DNLP_HIST07                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST07                  )
#define VDIN0_DNLP_HIST08                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST08                  )
#define VDIN0_DNLP_HIST09                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST09                  )
#define VDIN0_DNLP_HIST10                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST10                  )
#define VDIN0_DNLP_HIST11                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST11                  )
#define VDIN0_DNLP_HIST12                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST12                  )
#define VDIN0_DNLP_HIST13                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST13                  )
#define VDIN0_DNLP_HIST14                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST14                  )
#define VDIN0_DNLP_HIST15                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST15                  )
#define VDIN0_DNLP_HIST16                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST16                  )
#define VDIN0_DNLP_HIST17                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST17                  )
#define VDIN0_DNLP_HIST18                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST18                  )
#define VDIN0_DNLP_HIST19                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST19                  )
#define VDIN0_DNLP_HIST20                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST20                  )
#define VDIN0_DNLP_HIST21                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST21                  )
#define VDIN0_DNLP_HIST22                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST22                  )
#define VDIN0_DNLP_HIST23                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST23                  )
#define VDIN0_DNLP_HIST24                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST24                  )
#define VDIN0_DNLP_HIST25                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST25                  )
#define VDIN0_DNLP_HIST26                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST26                  )
#define VDIN0_DNLP_HIST27                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST27                  )
#define VDIN0_DNLP_HIST28                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST28                  )
#define VDIN0_DNLP_HIST29                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST29                  )
#define VDIN0_DNLP_HIST30                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST30                  )
#define VDIN0_DNLP_HIST31                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST31                  )
#define VDIN0_LDIM_STTS_HIST_REGION_IDX         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
#define VDIN0_LDIM_STTS_HIST_SET_REGION         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
#define VDIN0_LDIM_STTS_HIST_READ_REGION        ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
#define VDIN0_MEAS_CTRL0                        ((VDIN0_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
#define VDIN0_MEAS_VS_COUNT_HI                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
#define VDIN0_MEAS_VS_COUNT_LO                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
#define VDIN0_MEAS_HS_RANGE                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
#define VDIN0_MEAS_HS_COUNT                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
#define VDIN0_BLKBAR_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
#define VDIN0_BLKBAR_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
#define VDIN0_BLKBAR_H_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
#define VDIN0_BLKBAR_V_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
#define VDIN0_BLKBAR_CNT_THRESHOLD              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN0_BLKBAR_ROW_TH1_TH2                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN0_BLKBAR_IND_LEFT_START_END         ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN0_BLKBAR_IND_RIGHT_START_END        ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN0_BLKBAR_IND_LEFT1_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN0_BLKBAR_IND_LEFT2_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN0_BLKBAR_IND_RIGHT1_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN0_BLKBAR_IND_RIGHT2_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN0_BLKBAR_STATUS0                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
#define VDIN0_BLKBAR_STATUS1                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
#define VDIN0_WIN_H_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_H_START_END              )
#define VDIN0_WIN_V_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_V_START_END              )
#define VDIN0_ASFIFO_CTRL3                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )

//VDIN1        8'h70 - 8'hdf
#define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
#define VDIN1_SCALE_COEF                        ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF                   )
#define VDIN1_COM_CTRL0                         ((VDIN1_OFFSET << 2) + VDIN_COM_CTRL0                    )
#define VDIN1_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN1_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN1_LCNT_STATUS                       ((VDIN1_OFFSET << 2) + VDIN_LCNT_STATUS                  )
#define VDIN1_COM_STATUS0                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS0                  )
#define VDIN1_COM_STATUS1                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS1                  )
#define VDIN1_LCNT_SHADOW_STATUS                ((VDIN1_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
#define VDIN1_ASFIFO_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
#define VDIN1_ASFIFO_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
#define VDIN1_WIDTHM1I_WIDTHM1O                 ((VDIN1_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN1_SC_MISC_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
#define VDIN1_HSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
#define VDIN1_HSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
#define VDIN1_COM_STATUS2                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS2                  )
#define VDIN1_ASFIFO_CTRL2                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
#define VDIN1_MATRIX_CTRL                       ((VDIN1_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
#define VDIN1_MATRIX_COEF00_01                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
#define VDIN1_MATRIX_COEF02_10                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
#define VDIN1_MATRIX_COEF11_12                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
#define VDIN1_MATRIX_COEF20_21                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
#define VDIN1_MATRIX_COEF22                     ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF22                )
#define VDIN1_MATRIX_OFFSET0_1                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
#define VDIN1_MATRIX_OFFSET2                    ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
#define VDIN1_MATRIX_PRE_OFFSET0_1              ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN1_MATRIX_PRE_OFFSET2                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN1_LFIFO_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
#define VDIN1_COM_GCLK_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
#define VDIN1_INTF_WIDTHM1                      ((VDIN1_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
#define VDIN1_WR_CTRL2                          ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL2                     )
#define VDIN1_WR_CTRL                           ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL                      )
#define VDIN1_WR_H_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_H_START_END               )
#define VDIN1_WR_V_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_V_START_END               )
#define VDIN1_VSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
#define VDIN1_VSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
#define VDIN1_SCIN_HEIGHTM1                     ((VDIN1_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
#define VDIN1_DUMMY_DATA                        ((VDIN1_OFFSET << 2) + VDIN_DUMMY_DATA                   )
#define VDIN1_MATRIX_PROBE_COLOR                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
#define VDIN1_MATRIX_HL_COLOR                   ((VDIN1_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
#define VDIN1_MATRIX_PROBE_POS                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
#define VDIN1_CHROMA_ADDR_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
#define VDIN1_CHROMA_DATA_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
#define VDIN1_CM_BRI_CON_CTRL                   ((VDIN1_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
#define VDIN1_HIST_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HIST_CTRL                    )
#define VDIN1_HIST_H_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_H_START_END             )
#define VDIN1_HIST_V_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_V_START_END             )
#define VDIN1_HIST_MAX_MIN                      ((VDIN1_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
#define VDIN1_HIST_SPL_VAL                      ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
#define VDIN1_HIST_SPL_PIX_CNT                  ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
#define VDIN1_HIST_CHROMA_SUM                   ((VDIN1_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
#define VDIN1_DNLP_HIST00                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST00                  )
#define VDIN1_DNLP_HIST01                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST01                  )
#define VDIN1_DNLP_HIST02                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST02                  )
#define VDIN1_DNLP_HIST03                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST03                  )
#define VDIN1_DNLP_HIST04                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST04                  )
#define VDIN1_DNLP_HIST05                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST05                  )
#define VDIN1_DNLP_HIST06                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST06                  )
#define VDIN1_DNLP_HIST07                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST07                  )
#define VDIN1_DNLP_HIST08                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST08                  )
#define VDIN1_DNLP_HIST09                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST09                  )
#define VDIN1_DNLP_HIST10                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST10                  )
#define VDIN1_DNLP_HIST11                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST11                  )
#define VDIN1_DNLP_HIST12                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST12                  )
#define VDIN1_DNLP_HIST13                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST13                  )
#define VDIN1_DNLP_HIST14                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST14                  )
#define VDIN1_DNLP_HIST15                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST15                  )
#define VDIN1_DNLP_HIST16                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST16                  )
#define VDIN1_DNLP_HIST17                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST17                  )
#define VDIN1_DNLP_HIST18                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST18                  )
#define VDIN1_DNLP_HIST19                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST19                  )
#define VDIN1_DNLP_HIST20                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST20                  )
#define VDIN1_DNLP_HIST21                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST21                  )
#define VDIN1_DNLP_HIST22                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST22                  )
#define VDIN1_DNLP_HIST23                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST23                  )
#define VDIN1_DNLP_HIST24                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST24                  )
#define VDIN1_DNLP_HIST25                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST25                  )
#define VDIN1_DNLP_HIST26                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST26                  )
#define VDIN1_DNLP_HIST27                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST27                  )
#define VDIN1_DNLP_HIST28                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST28                  )
#define VDIN1_DNLP_HIST29                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST29                  )
#define VDIN1_DNLP_HIST30                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST30                  )
#define VDIN1_DNLP_HIST31                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST31                  )
#define VDIN1_LDIM_STTS_HIST_REGION_IDX         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
#define VDIN1_LDIM_STTS_HIST_SET_REGION         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
#define VDIN1_LDIM_STTS_HIST_READ_REGION        ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
#define VDIN1_MEAS_CTRL0                        ((VDIN1_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
#define VDIN1_MEAS_VS_COUNT_HI                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
#define VDIN1_MEAS_VS_COUNT_LO                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
#define VDIN1_MEAS_HS_RANGE                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
#define VDIN1_MEAS_HS_COUNT                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
#define VDIN1_BLKBAR_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
#define VDIN1_BLKBAR_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
#define VDIN1_BLKBAR_H_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
#define VDIN1_BLKBAR_V_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
#define VDIN1_BLKBAR_CNT_THRESHOLD              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN1_BLKBAR_ROW_TH1_TH2                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN1_BLKBAR_IND_LEFT_START_END         ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN1_BLKBAR_IND_RIGHT_START_END        ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN1_BLKBAR_IND_LEFT1_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN1_BLKBAR_IND_LEFT2_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN1_BLKBAR_IND_RIGHT1_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN1_BLKBAR_IND_RIGHT2_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN1_BLKBAR_STATUS0                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
#define VDIN1_BLKBAR_STATUS1                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
#define VDIN1_WIN_H_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_H_START_END              )
#define VDIN1_WIN_V_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_V_START_END              )
#define VDIN1_ASFIFO_CTRL3                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )

//`define LCD_VCBUS_BASE               8'h14
//
// Reading file:  lcd_regs.h
//
// -----------------------------------------------
// CBUS_BASE:  LCD_VCBUS_BASE = 0x14
// -----------------------------------------------
//========================================================================
//LCD DRV     12'h480~12'h4ef
//=======================================================================
#define L_GAMMA_CNTL_PORT                          0x1400
#define L_GAMMA_DATA_PORT                          0x1401
#define L_GAMMA_ADDR_PORT                          0x1402
#define L_GAMMA_VCOM_HSWITCH_ADDR                  0x1403
#define L_RGB_BASE_ADDR                            0x1405
#define L_RGB_COEFF_ADDR                           0x1406
#define L_POL_CNTL_ADDR                            0x1407
#define L_DITH_CNTL_ADDR                           0x1408
#define L_GAMMA_PROBE_CTRL                         0x1409
//read only
#define L_GAMMA_PROBE_COLOR_L                      0x140a
#define L_GAMMA_PROBE_COLOR_H                      0x140b
#define L_GAMMA_PROBE_HL_COLOR                     0x140c
#define L_GAMMA_PROBE_POS_X                        0x140d
#define L_GAMMA_PROBE_POS_Y                        0x140e
#define L_STH1_HS_ADDR                             0x1410
#define L_STH1_HE_ADDR                             0x1411
#define L_STH1_VS_ADDR                             0x1412
#define L_STH1_VE_ADDR                             0x1413
#define L_STH2_HS_ADDR                             0x1414
#define L_STH2_HE_ADDR                             0x1415
#define L_STH2_VS_ADDR                             0x1416
#define L_STH2_VE_ADDR                             0x1417
#define L_OEH_HS_ADDR                              0x1418
#define L_OEH_HE_ADDR                              0x1419
#define L_OEH_VS_ADDR                              0x141a
#define L_OEH_VE_ADDR                              0x141b
#define L_VCOM_HSWITCH_ADDR                        0x141c
#define L_VCOM_VS_ADDR                             0x141d
#define L_VCOM_VE_ADDR                             0x141e
#define L_CPV1_HS_ADDR                             0x141f
#define L_CPV1_HE_ADDR                             0x1420
#define L_CPV1_VS_ADDR                             0x1421
#define L_CPV1_VE_ADDR                             0x1422
#define L_CPV2_HS_ADDR                             0x1423
#define L_CPV2_HE_ADDR                             0x1424
#define L_CPV2_VS_ADDR                             0x1425
#define L_CPV2_VE_ADDR                             0x1426
#define L_STV1_HS_ADDR                             0x1427
#define L_STV1_HE_ADDR                             0x1428
#define L_STV1_VS_ADDR                             0x1429
#define L_STV1_VE_ADDR                             0x142a
#define L_STV2_HS_ADDR                             0x142b
#define L_STV2_HE_ADDR                             0x142c
#define L_STV2_VS_ADDR                             0x142d
#define L_STV2_VE_ADDR                             0x142e
#define L_OEV1_HS_ADDR                             0x142f
#define L_OEV1_HE_ADDR                             0x1430
#define L_OEV1_VS_ADDR                             0x1431
#define L_OEV1_VE_ADDR                             0x1432
#define L_OEV2_HS_ADDR                             0x1433
#define L_OEV2_HE_ADDR                             0x1434
#define L_OEV2_VS_ADDR                             0x1435
#define L_OEV2_VE_ADDR                             0x1436
#define L_OEV3_HS_ADDR                             0x1437
#define L_OEV3_HE_ADDR                             0x1438
#define L_OEV3_VS_ADDR                             0x1439
#define L_OEV3_VE_ADDR                             0x143a
#define L_LCD_PWR_ADDR                             0x143b
#define L_LCD_PWM0_LO_ADDR                         0x143c
#define L_LCD_PWM0_HI_ADDR                         0x143d
#define L_LCD_PWM1_LO_ADDR                         0x143e
#define L_LCD_PWM1_HI_ADDR                         0x143f
#define L_INV_CNT_ADDR                             0x1440
#define L_TCON_MISC_SEL_ADDR                       0x1441
#define L_DUAL_PORT_CNTL_ADDR                      0x1442
#define MLVDS_CLK_CTL1_HI                          0x1443
#define MLVDS_CLK_CTL1_LO                          0x1444
//  [31:30] enable mlvds clocks
//  [24]    mlvds_clk_half_delay       24 // Bit 0
//  [23:0]  mlvds_clk_pattern           0 // Bit 23:0
#define L_TCON_DOUBLE_CTL                          0x1449
#define L_TCON_PATTERN_HI                          0x144a
#define L_TCON_PATTERN_LO                          0x144b
#define LDIM_BL_ADDR_PORT                          0x144e
#define LDIM_BL_DATA_PORT                          0x144f
#define L_DE_HS_ADDR                               0x1451
#define L_DE_HE_ADDR                               0x1452
#define L_DE_VS_ADDR                               0x1453
#define L_DE_VE_ADDR                               0x1454
#define L_HSYNC_HS_ADDR                            0x1455
#define L_HSYNC_HE_ADDR                            0x1456
#define L_HSYNC_VS_ADDR                            0x1457
#define L_HSYNC_VE_ADDR                            0x1458
#define L_VSYNC_HS_ADDR                            0x1459
#define L_VSYNC_HE_ADDR                            0x145a
#define L_VSYNC_VS_ADDR                            0x145b
#define L_VSYNC_VE_ADDR                            0x145c
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define L_LCD_MCU_CTL                              0x145d
//**************************************************************************
//*  Dual port mLVDS registers
//**************************************************************************
// bit 3 - enable_u_dual_mlvds_dp_clk
// bit 2 - enable_u_map_mlvds_r_clk
// bit 1 - enable_u_map_mlvds_l_clk
// bit 0 - dual_mlvds_en
//`define DUAL_MLVDS_CTL                8'h60  
// bit[12:0] - dual_mlvds_line_start 
//`define DUAL_MLVDS_LINE_START         8'h61 
// bit[12:0] - dual_mlvds_line_end 
//`define DUAL_MLVDS_LINE_END           8'h62 
// bit[12:0] - dual_mlvds_w_pixel_start_l 
//`define DUAL_MLVDS_PIXEL_W_START_L    8'h63 
// bit[12:0] - dual_mlvds_w_pixel_end_l 
//`define DUAL_MLVDS_PIXEL_W_END_L      8'h64 
// bit[12:0] - dual_mlvds_w_pixel_start_r 
//`define DUAL_MLVDS_PIXEL_W_START_R    8'h65 
// bit[12:0] - dual_mlvds_w_pixel_end_r 
//`define DUAL_MLVDS_PIXEL_W_END_R      8'h66 
// bit[12:0] - dual_mlvds_r_pixel_start_l 
//`define DUAL_MLVDS_PIXEL_R_START_L    8'h67 
// bit[12:0] - dual_mlvds_r_pixel_cnt_l 
//`define DUAL_MLVDS_PIXEL_R_CNT_L      8'h68 
// bit[12:0] - dual_mlvds_r_pixel_start_r 
//`define DUAL_MLVDS_PIXEL_R_START_R    8'h69 
// bit[12:0] - dual_mlvds_r_pixel_cnt_r 
//`define DUAL_MLVDS_PIXEL_R_CNT_R      8'h6a
// bit[15]   - v_inversion_en
// bit[12:0] - v_inversion_pixel
//`define V_INVERSION_PIXEL             8'h70
// bit[15]   - v_inversion_sync_en
// bit[12:0] - v_inversion_line 
//`define V_INVERSION_LINE              8'h71
// bit[15:12]  - v_loop_r
// bit[11:10]  - v_pattern_1_r
// bit[9:8]    - v_pattern_0_r
// bit[7:4]    - v_loop_l
// bit[3:2]    - v_pattern_1_l
// bit[1:0]    - v_pattern_0_l
//`define V_INVERSION_CONTROL           8'h72
//`define MLVDS2_CONTROL           8'h74
   #define     mLVDS2_RESERVED  15    // 15
   #define     mLVDS2_double_pattern  14    // 14
   #define     mLVDS2_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS2_dual_gate  7
   #define     mLVDS2_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS2_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS2_msb_first  4
   #define     mLVDS2_PORT_SWAP  3
   #define     mLVDS2_MLSB_SWAP  2
   #define     mLVDS2_PN_SWAP    1
   #define     mLVDS2_en         0
//`define MLVDS2_CONFIG_HI         8'h75
//`define MLVDS2_CONFIG_LO         8'h76
   #define     mLVDS2_reset_offset         29 // Bit 31:29 
   #define     mLVDS2_reset_length         23 // Bit 28:23
   #define     mLVDS2_config_reserved      20 // Bit 22:20
   #define     mLVDS2_reset_start_bit12    19 // Bit 19
   #define     mLVDS2_data_write_toggle    18
   #define     mLVDS2_data_write_ini       17
   #define     mLVDS2_data_latch_1_toggle  16
   #define     mLVDS2_data_latch_1_ini     15
   #define     mLVDS2_data_latch_0_toggle  14
   #define     mLVDS2_data_latch_0_ini     13
   #define     mLVDS2_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS2_reset_start           0 // Bit 11:0
#define MLVDS2_DUAL_GATE_WR_START                  0x1477
   #define     mlvds2_dual_gate_wr_start    0 // Bit 12:0
#define MLVDS2_DUAL_GATE_WR_END                    0x1478
   #define     mlvds2_dual_gate_wr_end      0 // Bit 12:0
#define MLVDS2_DUAL_GATE_RD_START                  0x1479
   #define     mlvds2_dual_gate_rd_start    0 // Bit 12:0
#define MLVDS2_DUAL_GATE_RD_END                    0x147a
   #define     mlvds2_dual_gate_rd_end      0 // Bit 12:0
#define MLVDS2_SECOND_RESET_CTL                    0x147b
   #define     mLVDS2_2nd_reset_start       0 // Bit 12:0
#define MLVDS2_DUAL_GATE_CTL_HI                    0x147c
#define MLVDS2_DUAL_GATE_CTL_LO                    0x147d
   #define     mlvds2_tcon_field_en        24 // Bit 7:0
   #define     mlvds2_dual_gate_reserved   21 // Bit 2:0
   #define     mlvds2_scan_mode_start_line_bit12 20 // Bit 0
   #define     mlvds2_scan_mode_odd        16 // Bit 3:0
   #define     mlvds2_scan_mode_even       12 // Bit 3:0
   #define     mlvds2_scan_mode_start_line  0 // Bit 11:0
#define MLVDS2_RESET_CONFIG_HI                     0x147e
#define MLVDS2_RESET_CONFIG_LO                     0x147f
   #define     mLVDS2_reset_range_enable   31 // Bit 0
   #define     mLVDS2_reset_range_inv      30 // Bit 0
   #define     mLVDS2_reset_config_res1    29 // Bit 0
   #define     mLVDS2_reset_range_line_0   16 // Bit 11:0
   #define     mLVDS2_reset_config_res3    13 // Bit 2:0
   #define     mLVDS2_reset_range_line_1    0 // Bit 11:0
//
//**************************************************************************
//*  Vbyone registers  (Note: no MinLVDS in G9tv, share the register)
//**************************************************************************
#define VBO_CTRL_L                                 0x1460
#define VBO_CTRL_H                                 0x1461
#define VBO_SOFT_RST                               0x1462
#define VBO_LANES                                  0x1463
#define VBO_VIN_CTRL                               0x1464
#define VBO_ACT_VSIZE                              0x1465
#define VBO_REGION_00                              0x1466
#define VBO_REGION_01                              0x1467
#define VBO_REGION_02                              0x1468
#define VBO_REGION_03                              0x1469
#define VBO_VBK_CTRL_0                             0x146a
#define VBO_VBK_CTRL_1                             0x146b
#define VBO_HBK_CTRL                               0x146c
#define VBO_PXL_CTRL                               0x146d
#define VBO_LANE_SKEW_L                            0x146e
#define VBO_LANE_SKEW_H                            0x146f
#define VBO_GCLK_LANE_L                            0x1470
#define VBO_GCLK_LANE_H                            0x1471
#define VBO_GCLK_MAIN                              0x1472
#define VBO_STATUS_L                               0x1473
#define VBO_STATUS_H                               0x1474
#define VBO_LANE_OUTPUT                            0x1475
#define LCD_PORT_SWAP                              0x1476
//**************************************************************************
//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
//**************************************************************************
#define GAMMA_CNTL_PORT                            0x1480
   #define  GAMMA_VCOM_POL    7     //RW
   #define  GAMMA_RVS_OUT     6     //RW
   #define  ADR_RDY           5     //Read Only
   #define  WR_RDY            4     //Read Only
   #define  RD_RDY            3     //Read Only
   #define  GAMMA_TR          2     //RW
   #define  GAMMA_SET         1     //RW
   #define  GAMMA_EN          0     //RW
#define GAMMA_DATA_PORT                            0x1481
#define GAMMA_ADDR_PORT                            0x1482
   #define  H_RD              12
   #define  H_AUTO_INC        11
   #define  H_SEL_R           10
   #define  H_SEL_G           9
   #define  H_SEL_B           8
   #define  HADR_MSB          7            //7:0
   #define  HADR              0            //7:0
#define GAMMA_VCOM_HSWITCH_ADDR                    0x1483
#define RGB_BASE_ADDR                              0x1485
#define RGB_COEFF_ADDR                             0x1486
#define POL_CNTL_ADDR                              0x1487
   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
   #define   CPH3_POL         8
   #define   CPH2_POL         7
   #define   CPH1_POL         6
   #define   TCON_DE_SEL      5
   #define   TCON_VS_SEL      4
   #define   TCON_HS_SEL      3
   #define   DE_POL           2
   #define   VS_POL           1
   #define   HS_POL           0
#define DITH_CNTL_ADDR                             0x1488
   #define  DITH10_EN         10
   #define  DITH8_EN          9
   #define  DITH_MD           8
   #define  DITH10_CNTL_MSB   7          //7:4
   #define  DITH10_CNTL       4          //7:4
   #define  DITH8_CNTL_MSB    3          //3:0
   #define  DITH8_CNTL        0          //3:0
//Bit 1 highlight_en 
//Bit 0 probe_en
#define GAMMA_PROBE_CTRL                           0x1489
//read only
//Bit [15:0]  probe_color[15:0]
#define GAMMA_PROBE_COLOR_L                        0x148a
//Read only
//Bit 15: if true valid probed color
//Bit [13:0]  probe_color[29:16]
#define GAMMA_PROBE_COLOR_H                        0x148b
//bit 15:0, 5:6:5 color
#define GAMMA_PROBE_HL_COLOR                       0x148c
//12:0 pos_x
#define GAMMA_PROBE_POS_X                          0x148d
//12:0 pos_y
#define GAMMA_PROBE_POS_Y                          0x148e
#define STH1_HS_ADDR                               0x1490
#define STH1_HE_ADDR                               0x1491
#define STH1_VS_ADDR                               0x1492
#define STH1_VE_ADDR                               0x1493
#define STH2_HS_ADDR                               0x1494
#define STH2_HE_ADDR                               0x1495
#define STH2_VS_ADDR                               0x1496
#define STH2_VE_ADDR                               0x1497
#define OEH_HS_ADDR                                0x1498
#define OEH_HE_ADDR                                0x1499
#define OEH_VS_ADDR                                0x149a
#define OEH_VE_ADDR                                0x149b
#define VCOM_HSWITCH_ADDR                          0x149c
#define VCOM_VS_ADDR                               0x149d
#define VCOM_VE_ADDR                               0x149e
#define CPV1_HS_ADDR                               0x149f
#define CPV1_HE_ADDR                               0x14a0
#define CPV1_VS_ADDR                               0x14a1
#define CPV1_VE_ADDR                               0x14a2
#define CPV2_HS_ADDR                               0x14a3
#define CPV2_HE_ADDR                               0x14a4
#define CPV2_VS_ADDR                               0x14a5
#define CPV2_VE_ADDR                               0x14a6
#define STV1_HS_ADDR                               0x14a7
#define STV1_HE_ADDR                               0x14a8
#define STV1_VS_ADDR                               0x14a9
#define STV1_VE_ADDR                               0x14aa
#define STV2_HS_ADDR                               0x14ab
#define STV2_HE_ADDR                               0x14ac
#define STV2_VS_ADDR                               0x14ad
#define STV2_VE_ADDR                               0x14ae
#define OEV1_HS_ADDR                               0x14af
#define OEV1_HE_ADDR                               0x14b0
#define OEV1_VS_ADDR                               0x14b1
#define OEV1_VE_ADDR                               0x14b2
#define OEV2_HS_ADDR                               0x14b3
#define OEV2_HE_ADDR                               0x14b4
#define OEV2_VS_ADDR                               0x14b5
#define OEV2_VE_ADDR                               0x14b6
#define OEV3_HS_ADDR                               0x14b7
#define OEV3_HE_ADDR                               0x14b8
#define OEV3_VS_ADDR                               0x14b9
#define OEV3_VE_ADDR                               0x14ba
#define LCD_PWR_ADDR                               0x14bb
   #define      LCD_VDD        5
   #define      LCD_VBL        4
   #define      LCD_GPI_MSB    3
   #define      LCD_GPIO       0
#define LCD_PWM0_LO_ADDR                           0x14bc
#define LCD_PWM0_HI_ADDR                           0x14bd
#define LCD_PWM1_LO_ADDR                           0x14be
#define LCD_PWM1_HI_ADDR                           0x14bf
#define INV_CNT_ADDR                               0x14c0
   #define     INV_EN          4
   #define     INV_CNT_MSB     3
   #define     INV_CNT         0
#define TCON_MISC_SEL_ADDR                         0x14c1
   #define     STH2_SEL        12
   #define     STH1_SEL        11
   #define     OEH_SEL         10
   #define     VCOM_SEL         9
   #define     DB_LINE_SW       8
   #define     CPV2_SEL         7
   #define     CPV1_SEL         6
   #define     STV2_SEL         5
   #define     STV1_SEL         4
   #define     OEV_UNITE        3
   #define     OEV3_SEL         2
   #define     OEV2_SEL         1
   #define     OEV1_SEL         0
#define DUAL_PORT_CNTL_ADDR                        0x14c2
   #define     OUTPUT_YUV       15
   #define     DUAL_IDF         12   // 14:12
   #define     DUAL_ISF         9    // 11:9
   #define     LCD_ANALOG_SEL_CPH3   8
   #define     LCD_ANALOG_3PHI_CLK_SEL   7
   #define     LCD_LVDS_SEL54   6
   #define     LCD_LVDS_SEL27   5
   #define     LCD_TTL_SEL      4
   #define     DUAL_LVDC_EN     3
   #define     PORT_SWP         2
   #define     RGB_SWP          1
   #define     BIT_SWP          0
#define MLVDS_CONTROL                              0x14c3
   #define     mLVDS_RESERVED  15    // 15
   #define     mLVDS_double_pattern  14    // 14
   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS_dual_gate  7
   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS_msb_first  4
   #define     mLVDS_PORT_SWAP  3
   #define     mLVDS_MLSB_SWAP  2
   #define     mLVDS_PN_SWAP    1
   #define     mLVDS_en         0
#define MLVDS_RESET_PATTERN_HI                     0x14c4
#define MLVDS_RESET_PATTERN_LO                     0x14c5
   #define     mLVDS_reset_pattern  0 // Bit 47:16
#define MLVDS_RESET_PATTERN_EXT                    0x14c6
   #define     mLVDS_reset_pattern_ext  0 // Bit 15:0
#define MLVDS_CONFIG_HI                            0x14c7
#define MLVDS_CONFIG_LO                            0x14c8
   #define     mLVDS_reset_offset         29 // Bit 31:29 
   #define     mLVDS_reset_length         23 // Bit 28:23
   #define     mLVDS_config_reserved      20 // Bit 22:20
   #define     mLVDS_reset_start_bit12    19 // Bit 19
   #define     mLVDS_data_write_toggle    18
   #define     mLVDS_data_write_ini       17
   #define     mLVDS_data_latch_1_toggle  16
   #define     mLVDS_data_latch_1_ini     15
   #define     mLVDS_data_latch_0_toggle  14
   #define     mLVDS_data_latch_0_ini     13
   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS_reset_start           0 // Bit 11:0
#define TCON_DOUBLE_CTL                            0x14c9
   #define     tcon_double_ini          8 // Bit 7:0
   #define     tcon_double_inv          0 // Bit 7:0
#define TCON_PATTERN_HI                            0x14ca
#define TCON_PATTERN_LO                            0x14cb
   #define     tcon_pattern_loop_data     16 // Bit 15:0
   #define     tcon_pattern_loop_start    12 // Bit 3:0
   #define     tcon_pattern_loop_end       8 // Bit 3:0
   #define     tcon_pattern_enable         0 // Bit 7:0
#define TCON_CONTROL_HI                            0x14cc
#define TCON_CONTROL_LO                            0x14cd
   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
#define LVDS_BLANK_DATA_HI                         0x14ce
#define LVDS_BLANK_DATA_LO                         0x14cf
   #define     LVDS_blank_data_reserved 30  // 31:30
   #define     LVDS_blank_data_r        20  // 29:20
   #define     LVDS_blank_data_g        10  // 19:10
   #define     LVDS_blank_data_b         0  //  9:0
#define LVDS_PACK_CNTL_ADDR                        0x14d0
   #define     LVDS_USE_TCON    7
   #define     LVDS_DUAL        6
   #define     PN_SWP           5
   #define     LSB_FIRST        4
   #define     LVDS_RESV        3
   #define     ODD_EVEN_SWP     2
   #define     LVDS_REPACK      0
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN7-TCON4)
// Bit 11:0 -- de_hs(old tcon) second offset_hs (new tcon)
#define DE_HS_ADDR                                 0x14d1
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN3-TCON0)
#define DE_HE_ADDR                                 0x14d2
#define DE_VS_ADDR                                 0x14d3
#define DE_VE_ADDR                                 0x14d4
#define HSYNC_HS_ADDR                              0x14d5
#define HSYNC_HE_ADDR                              0x14d6
#define HSYNC_VS_ADDR                              0x14d7
#define HSYNC_VE_ADDR                              0x14d8
#define VSYNC_HS_ADDR                              0x14d9
#define VSYNC_HE_ADDR                              0x14da
#define VSYNC_VS_ADDR                              0x14db
#define VSYNC_VE_ADDR                              0x14dc
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define LCD_MCU_CTL                                0x14dd
// ReadOnly 
//   R5G6B5 when R5G6B5_format
//   G8R8   when R8G8B8_format
//   G5R10  Other
#define LCD_MCU_DATA_0                             0x14de
// ReadOnly
//   G8B8   when R8G8B8_format
//   G5B10  Other
#define LCD_MCU_DATA_1                             0x14df
// LVDS
#define LVDS_GEN_CNTL                              0x14e0
#define LVDS_PHY_CNTL0                             0x14e1
#define LVDS_PHY_CNTL1                             0x14e2
#define LVDS_PHY_CNTL2                             0x14e3
#define LVDS_PHY_CNTL3                             0x14e4
#define LVDS_PHY_CNTL4                             0x14e5
#define LVDS_PHY_CNTL5                             0x14e6
#define LVDS_SRG_TEST                              0x14e8
#define LVDS_BIST_MUX0                             0x14e9
#define LVDS_BIST_MUX1                             0x14ea
#define LVDS_BIST_FIXED0                           0x14eb
#define LVDS_BIST_FIXED1                           0x14ec
#define LVDS_BIST_CNTL0                            0x14ed
#define LVDS_CLKB_CLKA                             0x14ee
#define LVDS_PHY_CLK_CNTL                          0x14ef
#define LVDS_SER_EN                                0x14f0
#define LVDS_PHY_CNTL6                             0x14f1
#define LVDS_PHY_CNTL7                             0x14f2
#define LVDS_PHY_CNTL8                             0x14f3
#define MLVDS_CLK_CTL0_HI                          0x14f4
#define MLVDS_CLK_CTL0_LO                          0x14f5
   #define     mlvds_clk_pattern_reserved 31 // Bit 31
   #define     mpclk_dly                  28 // Bit 2:0 
   #define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
   #define     use_mpclk                  25 // Bit 0
   #define     mlvds_clk_half_delay       24 // Bit 0
   #define     mlvds_clk_pattern           0 // Bit 23:0
#define MLVDS_DUAL_GATE_WR_START                   0x14f6
   #define     mlvds_dual_gate_wr_start    0 // Bit 12:0
#define MLVDS_DUAL_GATE_WR_END                     0x14f7
   #define     mlvds_dual_gate_wr_end      0 // Bit 12:0
#define MLVDS_DUAL_GATE_RD_START                   0x14f8
   #define     mlvds_dual_gate_rd_start    0 // Bit 12:0
#define MLVDS_DUAL_GATE_RD_END                     0x14f9
   #define     mlvds_dual_gate_rd_end      0 // Bit 12:0
#define MLVDS_SECOND_RESET_CTL                     0x14fa
   #define     mLVDS_2nd_reset_start       0 // Bit 12:0
#define MLVDS_DUAL_GATE_CTL_HI                     0x14fb
#define MLVDS_DUAL_GATE_CTL_LO                     0x14fc
   #define     mlvds_tcon_field_en        24 // Bit 7:0
   #define     mlvds_dual_gate_reserved   21 // Bit 2:0
   #define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
   #define     mlvds_scan_mode_odd        16 // Bit 3:0
   #define     mlvds_scan_mode_even       12 // Bit 3:0
   #define     mlvds_scan_mode_start_line  0 // Bit 11:0
#define MLVDS_RESET_CONFIG_HI                      0x14fd
#define MLVDS_RESET_CONFIG_LO                      0x14fe
   #define     mLVDS_reset_range_enable   31 // Bit 0
   #define     mLVDS_reset_range_inv      30 // Bit 0
   #define     mLVDS_reset_config_res1    29 // Bit 0
   #define     mLVDS_reset_range_line_0   16 // Bit 11:0
   #define     mLVDS_reset_config_res3    13 // Bit 2:0
   #define     mLVDS_reset_range_line_1    0 // Bit 11:0
//===============================================================
//LCD DRIVER BASE   END
//===============================================================
//
// Closing file:  lcd_regs.h
//
//`define VPP2_VCBUS_BASE              8'h19
//
// Reading file:  vpp2_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPP2_VCBUS_BASE = 0x19
// -----------------------------------------------
//===========================================================================
// Video postprocesing Registers 
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    
// Bit 15:8     CB
// Bit 7:0      CR 
#define VPP2_DUMMY_DATA                            0x1900
//input line length used in VPP
#define VPP2_LINE_IN_LENGTH                        0x1901
//input Picture height used in VPP
#define VPP2_PIC_IN_HEIGHT                         0x1902
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15    index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)  
//Bit 14    1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered 
//Bit 6:0   coef index
#define VPP2_SCALE_COEF_IDX                        0x1903
//coefficients for vertical filter and horizontal filter
#define VPP2_SCALE_COEF                            0x1904
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//      . 
//      .
//      .           region0        <---------- nonlinear region or nonscaling region    
//      .
//  ---------------------------  
//  ---------------------------  <------ region1_startp 
//      .
//      .           region1         <---------- nonlinear region
//      .
//      .
//  ---------------------------  
//  ---------------------------  <------ region2_startp
//      .
//      .           region2         <---------- linear region
//      .
//      .
//  ---------------------------  
//  ---------------------------  <------ region3_startp
//      .
//      .           region3         <---------- nonlinear region
//      .
//      .
//  ---------------------------  
//  ---------------------------  <------ region4_startp
//      .
//      .           region4         <---------- nonlinear region or nonoscaling region
//      .
//      .
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define VPP2_VSC_REGION12_STARTP                   0x1905
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define VPP2_VSC_REGION34_STARTP                   0x1906
#define VPP2_VSC_REGION4_ENDP                      0x1907
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0  fraction part
#define VPP2_VSC_START_PHASE_STEP                  0x1908
//vertical scaler region0 phase slope, Bit24 signed bit
#define VPP2_VSC_REGION0_PHASE_SLOPE               0x1909
//vertical scaler region1 phase slope, Bit24 signed bit
#define VPP2_VSC_REGION1_PHASE_SLOPE               0x190a
//vertical scaler region3 phase slope, Bit24 signed bit
#define VPP2_VSC_REGION3_PHASE_SLOPE               0x190b
//vertical scaler region4 phase slope, Bit24 signed bit
#define VPP2_VSC_REGION4_PHASE_SLOPE               0x190c
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X, 
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field   
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field   
#define VPP2_VSC_PHASE_CTRL                        0x190d
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define VPP2_VSC_INI_PHASE                         0x190e
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define VPP2_HSC_REGION12_STARTP                   0x1910
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define VPP2_HSC_REGION34_STARTP                   0x1911
#define VPP2_HSC_REGION4_ENDP                      0x1912
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0  fraction part
#define VPP2_HSC_START_PHASE_STEP                  0x1913
//horizontal scaler region0 phase slope, Bit24 signed bit
#define VPP2_HSC_REGION0_PHASE_SLOPE               0x1914
//horizontal scaler region1 phase slope, Bit24 signed bit
#define VPP2_HSC_REGION1_PHASE_SLOPE               0x1915
//horizontal scaler region3 phase slope, Bit24 signed bit
#define VPP2_HSC_REGION3_PHASE_SLOPE               0x1916
//horizontal scaler region4 phase slope, Bit24 signed bit
#define VPP2_HSC_REGION4_PHASE_SLOPE               0x1917
//Bit 22:21   horizontal scaler initial repeat pixel0 number
//Bit 19:16   horizontal scaler initial receiving number   
//Bit 15:0    horizontal scaler top field initial phase
#define VPP2_HSC_PHASE_CTRL                        0x1918
// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
// Bit 2:0 vertical scaler bank length
#define VPP2_SC_MISC                               0x1919
// preblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_PREBLEND_VD1_H_START_END              0x191a
// preblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_PREBLEND_VD1_V_START_END              0x191b
// postblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_POSTBLEND_VD1_H_START_END             0x191c
// postblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_POSTBLEND_VD1_V_START_END             0x191d
// preblend horizontal size
#define VPP2_PREBLEND_H_SIZE                       0x1920
// postblend horizontal size
#define VPP2_POSTBLEND_H_SIZE                      0x1921
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 15:8     preblend hold lines
//Bit 7:0      postblend hold lines
#define VPP2_HOLD_LINES                            0x1922
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define VPP2_BLEND_ONECOLOR_CTRL                   0x1923
//Read Only, VPP preblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define VPP2_PREBLEND_CURRENT_XY                   0x1924
//Read Only, VPP postblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define VPP2_POSTBLEND_CURRENT_XY                  0x1925
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// bit 28   color management enable
// Bit 27,  reserved 
// Bit 26:18, reserved
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, reserved
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, reserved
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultipiled 
// Bit 8,  if true, osd2 is alpha premultipiled 
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,  
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//           the aync fifo will be reseted.
// Bit 1,     
// Bit 0    if true, the output result of VPP is saturated
#define VPP2_MISC                                  0x1926
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define VPP2_OFIFO_SIZE                            0x1927
//Read only
//Bit 28:17 current scale out fifo counter
//Bit 16:12 current afifo counter
//Bit 11:0 current ofifo counter
#define VPP2_FIFO_STATUS                           0x1928
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
#define VPP2_SMOKE_CTRL                            0x1929
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 chanel
//smoke2 for OSD2 chanel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define VPP2_SMOKE1_VAL                            0x192a
#define VPP2_SMOKE2_VAL                            0x192b
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_SMOKE1_H_START_END                    0x192d
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_SMOKE1_V_START_END                    0x192e
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_SMOKE2_H_START_END                    0x192f
//Bit 28:16 start
//Bit 12:0 end
#define VPP2_SMOKE2_V_START_END                    0x1930
//Bit 27:16 scale out fifo line length minus 1
//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
#define VPP2_SCO_FIFO_CTRL                         0x1933
//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 23 horizontal scaler double pixel mode
//Bit 22:21   horizontal scaler initial repeat pixel0 number1
//Bit 19:16   horizontal scaler initial receiving number1   
//Bit 15:0    horizontal scaler top field initial phase1
#define VPP2_HSC_PHASE_CTRL1                       0x1934
//for 3D quincunx sub-sampling
//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
//22:20  prehsc pattern start
//18:16 prehsc pattern end
//15:8 pattern, each patten 1 bit, from lsb -> msb
//6:4  pattern start
//2:0  pattern end
#define VPP2_HSC_INI_PAT_CTRL                      0x1935
//Bit 3         minus black level enable for vadj2
//Bit 2         Video adjustment enable for vadj2
//Bit 1         minus black level enable for vadj1
//Bit 0         Video adjustment enable for vadj1
#define VPP2_VADJ_CTRL                             0x1940
//Bit 16:8  brightness, signed value
//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
#define VPP2_VADJ1_Y                               0x1941
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define VPP2_VADJ1_MA_MB                           0x1942
#define VPP2_VADJ1_MC_MD                           0x1943
//Bit 16:8  brightness, signed value
//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
#define VPP2_VADJ2_Y                               0x1944
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define VPP2_VADJ2_MA_MB                           0x1945
#define VPP2_VADJ2_MC_MD                           0x1946
//Read only 
//Bit 31, if it is true, it means this probe is valid in the last field/frame
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VPP2_MATRIX_PROBE_COLOR                    0x195c
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VPP2_MATRIX_HL_COLOR                       0x195d
//28:16 probe x, postion
//12:0  probe y, position  
#define VPP2_MATRIX_PROBE_POS                      0x195e
//Bit 16,  highlight_en
//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix,
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    reserved
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define VPP2_MATRIX_CTRL                           0x195f
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VPP2_MATRIX_COEF00_01                      0x1960
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define VPP2_MATRIX_COEF02_10                      0x1961
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VPP2_MATRIX_COEF11_12                      0x1962
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VPP2_MATRIX_COEF20_21                      0x1963
#define VPP2_MATRIX_COEF22                         0x1964
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VPP2_MATRIX_OFFSET0_1                      0x1965
//Bit 10:0  offset2
#define VPP2_MATRIX_OFFSET2                        0x1966
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VPP2_MATRIX_PRE_OFFSET0_1                  0x1967
//Bit 10:0  pre_offset2
#define VPP2_MATRIX_PRE_OFFSET2                    0x1968
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define VPP2_DUMMY_DATA1                           0x1969
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define VPP2_GAINOFF_CTRL0                         0x196a
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define VPP2_GAINOFF_CTRL1                         0x196b
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define VPP2_GAINOFF_CTRL2                         0x196c
//Bit 26:16, pre_offset0, signed data 
//Bit 10:0, pre_offset1, signed data 
#define VPP2_GAINOFF_CTRL3                         0x196d
//Bit 10:0, pre_offset2, signed data 
#define VPP2_GAINOFF_CTRL4                         0x196e
//only two registers used in the color management, which are defined in the chroma_reg.h
#define VPP2_CHROMA_ADDR_PORT                      0x1970
#define VPP2_CHROMA_DATA_PORT                      0x1971
//`include "chroma_reg.h"       //defined inside is the indirect addressed registers
//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
//because the register itself canot be set again without clk
//Bit 31:0
#define VPP2_GCLK_CTRL0                            0x1972
//Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
//Bit 9:0
#define VPP2_GCLK_CTRL1                            0x1973
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
#define VPP2_SC_GCLK_CTRL                          0x1974
//Bit 17:9 VD1 alpha for preblend
//Bit 8:0 VD1 alpha for postblend
#define VPP2_MISC1                                 0x1976
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define VPP2_DNLP_CTRL_00                          0x1981
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define VPP2_DNLP_CTRL_01                          0x1982
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define VPP2_DNLP_CTRL_02                          0x1983
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define VPP2_DNLP_CTRL_03                          0x1984
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define VPP2_DNLP_CTRL_04                          0x1985
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define VPP2_DNLP_CTRL_05                          0x1986
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define VPP2_DNLP_CTRL_06                          0x1987
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define VPP2_DNLP_CTRL_07                          0x1988
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define VPP2_DNLP_CTRL_08                          0x1989
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define VPP2_DNLP_CTRL_09                          0x198a
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define VPP2_DNLP_CTRL_10                          0x198b
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define VPP2_DNLP_CTRL_11                          0x198c
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define VPP2_DNLP_CTRL_12                          0x198d
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define VPP2_DNLP_CTRL_13                          0x198e
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define VPP2_DNLP_CTRL_14                          0x198f
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define VPP2_DNLP_CTRL_15                          0x1990
//Bit 20 reserved
//Bit 19 reserved
//Bit 18 demo dynamic nonlinear luma processing enable
//Bit 17 reserved
//Bit 16 reserved
//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
//Bit 4 reserved
//Bit 3 reserved
//Bit 2 dynamic nonlinear luma processing enable
//Bit 1 reserved
//Bit 0 reserved
#define VPP2_VE_ENABLE_CTRL                        0x19a1
//Bit 12:0, demo left or top screen width
#define VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH         0x19a2
#define VPP2_VE_DEMO_CENTER_BAR                    0x19a3
//28:16  ve_line_length
//12:0   ve_pic_height
#define VPP2_VE_H_V_SIZE                           0x19a4
//Bit 10   reset bit, high active
//Bit 9    0: measuring rising edge, 1: measuring falling edge
//Bit 8    if true, accumulate the counter number, otherwise not
//Bit 7:0  vsync_span, define how many vsync span need to measure 
#define VPP2_VDO_MEAS_CTRL                         0x19a8
//Read only
//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
//15:0, high bit portion of counter
#define VPP2_VDO_MEAS_VS_COUNT_HI                  0x19a9
//Read only
//31:0, low bit portion of counter
#define VPP2_VDO_MEAS_VS_COUNT_LO                  0x19aa
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define VPP2_OSD_VSC_PHASE_STEP                    0x19c0
//Bit 31:16, botttom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define VPP2_OSD_VSC_INI_PHASE                     0x19c1
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length 
#define VPP2_OSD_VSC_CTRL0                         0x19c2
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define VPP2_OSD_HSC_PHASE_STEP                    0x19c3
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define VPP2_OSD_HSC_INI_PHASE                     0x19c4
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define VPP2_OSD_HSC_CTRL0                         0x19c5
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define VPP2_OSD_HSC_INI_PAT_CTRL                  0x19c6
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define VPP2_OSD_SC_DUMMY_DATA                     0x19c7
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable 
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define VPP2_OSD_SC_CTRL0                          0x19c8
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define VPP2_OSD_SCI_WH_M1                         0x19c9
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define VPP2_OSD_SCO_H_START_END                   0x19ca
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define VPP2_OSD_SCO_V_START_END                   0x19cb
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define VPP2_OSD_SCALE_COEF_IDX                    0x19cc
//coefficients for vertical filter and horizontal filter
#define VPP2_OSD_SCALE_COEF                        0x19cd
//Bit 12:0 line number use to generate interrupt when line == this number
#define VPP2_INT_LINE_NUM                          0x19ce
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp2_regs.h
//
//`define VIU_VCBUS_BASE                8'h1a    
//
// Reading file:  vregs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VIU_VCBUS_BASE = 0x1a
// -----------------------------------------------
#define VIU_ADDR_START                             0x1a00
#define VIU_ADDR_END                               0x1aff
//`define TRACE_REG 8'ff
//------------------------------------------------------------------------------
// VIU top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  4 RW, vd2_reset
// Bit  5 RW, vd2_fmt_reset
// Bit  6 RW, di_dsr1to2_reset
// Bit  7 RW, vpp_reset
// Bit  8 RW, di_if1_reset
// Bit  9 RW, di_if1_fmt_reset
// Bit 10 RW, di_inp_reset
// Bit 11 RW, di_inp_fmt_reset
// Bit 12 RW, di_mem_reset
// Bit 13 RW, di_mem_fmt_reset
// Bit 14 RW, di_nr_wr_mif_reset
// Bit 15 RW, dein_wr_mif_reset
// Bit 16 RW, di_chan2_mif_reset
// Bit 17 RW, di_mtn_wr_mif_reset
// Bit 18 RW, di_mtn_rd_mif_reset
// Bit 19 RW, di_mad_reset
// Bit 20 RW, vdin0_reset
// Bit 21 RW, vdin1_reset
// Bit 22 RW, nrin_mux_reset
// Bit 23 RW, vdin0_wr_reset
// Bit 24 RW, vdin1_wr_reset
// Bit 25 RW, reserved
// Bit 26 RW, d2d3_reset
// Bit 27 RW, di_cont_wr_mif_reset
// Bit 28 RW, di_cont_rd_mif_reset
#define VIU_SW_RESET                               0x1a01
#define VIU_SW_RESET0                              0x1a02
// Bit 0 RW, software reset for mcvecrd_mif
// Bit 1 RW, software reset for mcinfowr_mif
// Bit 2 RW, software reset for mcinford_mif
//7:0 fix_disable
#define VIU_MISC_CTRL0                             0x1a06
#define D2D3_INTF_LENGTH                           0x1a08
// Bit 31:30 vdin0 dout splitter, bit 0 turns on vdin0 to old path, bit 1 turns on vdin0 to d2d3_intf vdin0 input path        
// Bit 29:28 vdin1 dout splitter, bit 0 turns on vdin1 to old path, bit 1 turns on vdin1 to d2d3_intf vdin1 input path  
// Bit 27:26 NR write dout splitter, bit 0 turns on NR write to old path, bit 1 turns on NR WR to d2d3_intf NR WR input path  
// Bit 23 if true, turn on clk_d2d3_reg (register clock)
// Bit 22 if true, turn on clk_d2d3
// Bit 21 reg_v1_go_line
// Bit 20 reg_v1_go_field   
// Bit 19 reg_v0_go_field
// Bit 18:16 v1_gofld_sel, 000: display go_field/go_line, 001: DI pre_frame_rst/go_line, 010: vdin0 go_field/go_line, 
//011: vdin1 go_field/go_line, otherwise: force go_field by reg_v1_go_field(bit20), force go_line by reg_v1_go_line(bit21)
// Bit 15:13 v0_gofld_sel, 000: display go_field, 001: DI pre_frame_rst, 010: vdin0 go_field, 011: vdin1 go_field, otherwise: force go_field by
// reg_v0_go_field(bit19)
// Bit 12:6 hole_lines for d2d3 depth read interface
// Bit 5:4 d2d3_v1_sel, 2'b01: video display read interface(DI or vd1 fomart output), 2'b10: scale output, otherwise nothing as v1
// Bit 3 use_vdin_eol, if true, use vdin eol as the v0_eol, otherwise using length to get the v0_eol
// Bit 2:0  d2d3_v0_sel  001: vdin0, 010: vdin1, 011: NRW, 100: video display read interface(DI or vd1 fomart output), 101: vpp scale output
//
#define D2D3_INTF_CTRL0                            0x1a09
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define VIU_OSD1_CTRL_STAT                         0x1a10
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define VIU_OSD1_CTRL_STAT2                        0x1a2d
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define VIU_OSD1_COLOR_ADDR                        0x1a11
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD1_COLOR                             0x1a12
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD1_TCOLOR_AG0                        0x1a17
#define VIU_OSD1_TCOLOR_AG1                        0x1a18
#define VIU_OSD1_TCOLOR_AG2                        0x1a19
#define VIU_OSD1_TCOLOR_AG3                        0x1a1a
// Bit 31:30 Reserved
// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
// Bit 27:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define VIU_OSD1_BLK0_CFG_W0                       0x1a1b
#define VIU_OSD1_BLK1_CFG_W0                       0x1a1f
#define VIU_OSD1_BLK2_CFG_W0                       0x1a23
#define VIU_OSD1_BLK3_CFG_W0                       0x1a27
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define VIU_OSD1_BLK0_CFG_W1                       0x1a1c
#define VIU_OSD1_BLK1_CFG_W1                       0x1a20
#define VIU_OSD1_BLK2_CFG_W1                       0x1a24
#define VIU_OSD1_BLK3_CFG_W1                       0x1a28
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define VIU_OSD1_BLK0_CFG_W2                       0x1a1d
#define VIU_OSD1_BLK1_CFG_W2                       0x1a21
#define VIU_OSD1_BLK2_CFG_W2                       0x1a25
#define VIU_OSD1_BLK3_CFG_W2                       0x1a29
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define VIU_OSD1_BLK0_CFG_W3                       0x1a1e
#define VIU_OSD1_BLK1_CFG_W3                       0x1a22
#define VIU_OSD1_BLK2_CFG_W3                       0x1a26
#define VIU_OSD1_BLK3_CFG_W3                       0x1a2a
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define VIU_OSD1_BLK0_CFG_W4                       0x1a13
#define VIU_OSD1_BLK1_CFG_W4                       0x1a14
#define VIU_OSD1_BLK2_CFG_W4                       0x1a15
#define VIU_OSD1_BLK3_CFG_W4                       0x1a16
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define VIU_OSD1_FIFO_CTRL_STAT                    0x1a2b
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define VIU_OSD1_TEST_RDDATA                       0x1a2c
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define VIU_OSD1_PROT_CTRL                         0x1a2e
//------------------------------------------------------------------------------
// OSD2 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define VIU_OSD2_CTRL_STAT                         0x1a30
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define VIU_OSD2_CTRL_STAT2                        0x1a4d
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define VIU_OSD2_COLOR_ADDR                        0x1a31
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD2_COLOR                             0x1a32
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define VIU_OSD2_HL1_H_START_END                   0x1a33
#define VIU_OSD2_HL1_V_START_END                   0x1a34
#define VIU_OSD2_HL2_H_START_END                   0x1a35
#define VIU_OSD2_HL2_V_START_END                   0x1a36
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD2_TCOLOR_AG0                        0x1a37
#define VIU_OSD2_TCOLOR_AG1                        0x1a38
#define VIU_OSD2_TCOLOR_AG2                        0x1a39
#define VIU_OSD2_TCOLOR_AG3                        0x1a3a
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define VIU_OSD2_BLK0_CFG_W0                       0x1a3b
#define VIU_OSD2_BLK1_CFG_W0                       0x1a3f
#define VIU_OSD2_BLK2_CFG_W0                       0x1a43
#define VIU_OSD2_BLK3_CFG_W0                       0x1a47
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define VIU_OSD2_BLK0_CFG_W1                       0x1a3c
#define VIU_OSD2_BLK1_CFG_W1                       0x1a40
#define VIU_OSD2_BLK2_CFG_W1                       0x1a44
#define VIU_OSD2_BLK3_CFG_W1                       0x1a48
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define VIU_OSD2_BLK0_CFG_W2                       0x1a3d
#define VIU_OSD2_BLK1_CFG_W2                       0x1a41
#define VIU_OSD2_BLK2_CFG_W2                       0x1a45
#define VIU_OSD2_BLK3_CFG_W2                       0x1a49
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define VIU_OSD2_BLK0_CFG_W3                       0x1a3e
#define VIU_OSD2_BLK1_CFG_W3                       0x1a42
#define VIU_OSD2_BLK2_CFG_W3                       0x1a46
#define VIU_OSD2_BLK3_CFG_W3                       0x1a4a
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define VIU_OSD2_BLK0_CFG_W4                       0x1a64
#define VIU_OSD2_BLK1_CFG_W4                       0x1a65
#define VIU_OSD2_BLK2_CFG_W4                       0x1a66
#define VIU_OSD2_BLK3_CFG_W4                       0x1a67
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define VIU_OSD2_FIFO_CTRL_STAT                    0x1a4b
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define VIU_OSD2_TEST_RDDATA                       0x1a4c
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define VIU_OSD2_PROT_CTRL                         0x1a4e
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
#define VD1_IF0_GEN_REG                            0x1a50
#define VD1_IF0_CANVAS0                            0x1a51
#define VD1_IF0_CANVAS1                            0x1a52
#define VD1_IF0_LUMA_X0                            0x1a53
#define VD1_IF0_LUMA_Y0                            0x1a54
#define VD1_IF0_CHROMA_X0                          0x1a55
#define VD1_IF0_CHROMA_Y0                          0x1a56
#define VD1_IF0_LUMA_X1                            0x1a57
#define VD1_IF0_LUMA_Y1                            0x1a58
#define VD1_IF0_CHROMA_X1                          0x1a59
#define VD1_IF0_CHROMA_Y1                          0x1a5a
#define VD1_IF0_RPT_LOOP                           0x1a5b
#define VD1_IF0_LUMA0_RPT_PAT                      0x1a5c
#define VD1_IF0_CHROMA0_RPT_PAT                    0x1a5d
#define VD1_IF0_LUMA1_RPT_PAT                      0x1a5e
#define VD1_IF0_CHROMA1_RPT_PAT                    0x1a5f
#define VD1_IF0_LUMA_PSEL                          0x1a60
#define VD1_IF0_CHROMA_PSEL                        0x1a61
#define VD1_IF0_DUMMY_PIXEL                        0x1a62
#define VD1_IF0_LUMA_FIFO_SIZE                     0x1a63
#define VD1_IF0_RANGE_MAP_Y                        0x1a6a
#define VD1_IF0_RANGE_MAP_CB                       0x1a6b
#define VD1_IF0_RANGE_MAP_CR                       0x1a6c
#define VD1_IF0_GEN_REG2                           0x1a6d
#define VD1_IF0_PROT_CNTL                          0x1a6e
#define VD1_IF0_URGENT_CTRL                        0x1a6f
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define VIU_VD1_FMT_CTRL                           0x1a68
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define VIU_VD1_FMT_W                              0x1a69
//------------------------------------------------------------------------------
// VD2 path
//------------------------------------------------------------------------------
#define VD2_IF0_GEN_REG                            0x1a70
#define VD2_IF0_CANVAS0                            0x1a71
#define VD2_IF0_CANVAS1                            0x1a72
#define VD2_IF0_LUMA_X0                            0x1a73
#define VD2_IF0_LUMA_Y0                            0x1a74
#define VD2_IF0_CHROMA_X0                          0x1a75
#define VD2_IF0_CHROMA_Y0                          0x1a76
#define VD2_IF0_LUMA_X1                            0x1a77
#define VD2_IF0_LUMA_Y1                            0x1a78
#define VD2_IF0_CHROMA_X1                          0x1a79
#define VD2_IF0_CHROMA_Y1                          0x1a7a
#define VD2_IF0_RPT_LOOP                           0x1a7b
#define VD2_IF0_LUMA0_RPT_PAT                      0x1a7c
#define VD2_IF0_CHROMA0_RPT_PAT                    0x1a7d
#define VD2_IF0_LUMA1_RPT_PAT                      0x1a7e
#define VD2_IF0_CHROMA1_RPT_PAT                    0x1a7f
#define VD2_IF0_LUMA_PSEL                          0x1a80
#define VD2_IF0_CHROMA_PSEL                        0x1a81
#define VD2_IF0_DUMMY_PIXEL                        0x1a82
#define VD2_IF0_LUMA_FIFO_SIZE                     0x1a83
#define VD2_IF0_RANGE_MAP_Y                        0x1a8a
#define VD2_IF0_RANGE_MAP_CB                       0x1a8b
#define VD2_IF0_RANGE_MAP_CR                       0x1a8c
#define VD2_IF0_GEN_REG2                           0x1a8d
#define VD2_IF0_PROT_CNTL                          0x1a8e
#define VD2_IF0_URGENT_CTRL                        0x1a8f
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define VIU_VD2_FMT_CTRL                           0x1a88
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define VIU_VD2_FMT_W                              0x1a89
//todo add comment
#define LDIM_STTS_GCLK_CTRL0                       0x1a90
#define LDIM_STTS_CTRL0                            0x1a91
#define LDIM_STTS_WIDTHM1_HEIGHTM1                 0x1a92
#define LDIM_STTS_MATRIX_COEF00_01                 0x1a93
#define LDIM_STTS_MATRIX_COEF02_10                 0x1a94
#define LDIM_STTS_MATRIX_COEF11_12                 0x1a95
#define LDIM_STTS_MATRIX_COEF20_21                 0x1a96
#define LDIM_STTS_MATRIX_COEF22                    0x1a97
#define LDIM_STTS_MATRIX_OFFSET0_1                 0x1a98
#define LDIM_STTS_MATRIX_OFFSET2                   0x1a99
#define LDIM_STTS_MATRIX_PRE_OFFSET0_1             0x1a9a
#define LDIM_STTS_MATRIX_PRE_OFFSET2               0x1a9b
#define LDIM_STTS_MATRIX_HL_COLOR                  0x1a9c
#define LDIM_STTS_MATRIX_PROBE_POS                 0x1a9d
//read only
#define LDIM_STTS_MATRIX_PROBE_COLOR               0x1a9e
//Bit 31, local dimming statistic enable
//Bit 29, 1: output region histogram 16bit 0:output region histogram 20bit 
//Bit 28, eol enable
//Bit 27:25, vertical line overlap number for max finding
//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//Bit 15:14, 1: region read index auto increase per block read finished to VDIN_LDIM_STTS_HIST_READ_REGION 
//			 2: region read index auto increase per read finished to VDIN_LDIM_STTS_HIST_READ_REGION
//			 0/3: disable read index self increase
//Bit 13:8, region read sub index, which mux the hist & max-finding result to cbus port, refer to LDIM_STTS_HIST_READ_REGION
//Bit 6:0, region read index
#define LDIM_STTS_HIST_REGION_IDX                  0x1aa0
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
#define LDIM_STTS_HIST_SET_REGION                  0x1aa1
//if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data. 
//if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0. 
//output sequence as rd_sub_idx from 0~47: {max_comp2, comp0_hist0}, {max_comp1, comp0_hist1}, {max_comp0, comp0_hist2}, 
//										   comp0_hist3 ... comp2_hist16
//if LDIM_STTS_HIST_REGION_IDX[29] == 1, that is output hist with 16bit data. 
//if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0. 
//output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//										   comp0_hist3 ... comp2_hist16
//if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data. 
//if LDIM_STTS_HIST_REGION_IDX[21] == 1, that is output 32hist bins in comp 0. 
//output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//										   comp0_hist3 ...comp0_hist31 ... comp1_hist16
#define LDIM_STTS_HIST_READ_REGION                 0x1aa2
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di if1 chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di if1 luma path
#define DI_IF1_URGENT_CTRL                         0x1aa3
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
#define DI_INP_URGENT_CTRL                         0x1aa4
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di mem chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di mem luma path
#define DI_MEM_URGENT_CTRL                         0x1aa5
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di chan2 chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di chan2 luma path
#define DI_CHAN2_URGENT_CTRL                       0x1aa6
//DEINTERLACE module start from 8'h90 end to 8'hff
// -----------------------------------------------
// CBUS_BASE:  MAD_VCBUS_BASE = 0x17
// -----------------------------------------------
#define DI_PRE_CTRL                                0x1700
// bit 31,      cbus_pre_frame_rst
// bit 30,      cbus_pre_soft_rst
// bit 29,      pre_field_num 
// bit 27:26,   mode_444c422
// bit 25,      di_cont_read_en
// bit 24:23,   mode_422c444
// bit 22,      mtn_after_nr
// bit 21:16,   pre_hold_fifo_lines
// bit 15,      nr_wr_by
// bit 14,      use_vdin_go_line
// bit 13,      di_prevdin_en
// bit 12,      di_pre_viu_link
// bit 11,      di_pre_repeat
// bit 10,      di_pre_drop_1st
// bit  9,      di_buf2_en
// bit  8,      di_chan2_en
// bit  7,      prenr_hist_en
// bit  6,      chan2_hist_en
// bit  5,      hist_check_en
// bit  4,      check_after_nr
// bit  3,      check222p_en
// bit  2,      check322p_en
// bit  1,      mtn_en
// bit  0,      nr_en
#define DI_POST_CTRL                               0x1701
// bit 31,      cbus_post_frame_rst
// bit 30,      cbus_post_soft_rst
// bit 29,      post_field_num
// bit 21:16,   post_hold_fifo_lines
// bit 13,      prepost_link
// bit 12,      di_post_viu_link
// bit 11,      di_post_repeat
// bit 10,      di_post_drop_1st
// bit  9,      mif0_to_vpp_en
// bit  8,      di_vpp_out_en
// bit  7,      di_wr_bk_en
// bit  6,      di_mux_en
// bit  5,      di_blend_en
// bit  4,      di_mtnp_read_en
// bit  3,      di_mtn_buf_en
// bit  2,      di_ei_en
// bit  1,      di_buf1_en
// bit  0,      di_buf0_en
#define DI_POST_SIZE                               0x1702
//bit 28:16,    vsize1post
//bit 12:0,     hsize1post
#define DI_PRE_SIZE                                0x1703
//bit 28:16,    vsize1pre
//bit 12:0,     hsize1pre
#define DI_EI_CTRL0                                0x1704
//bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter && ...right>filter && ...top>filter && ...bot>filter -> filter
//bit 15:8,     ei0_threshold[2:+] 
//bit 3,        ei0_vertical
//bit 2,        ei0_bpscf2
//bit 1,        ei0_bpsfar1
#define DI_EI_CTRL1                                0x1705
//bit 31:24,    ei0_diff
//bit 23:16,    ei0_angle45
//bit 15:8,     ei0_peak
//bit 7:0,      ei0_cross
#define DI_EI_CTRL2                                0x1706
//bit 31:24,    ei0_close2
//bit 23:16,    ei0_close1
//bit 15:8,     ei0_far2
//bit 7:0,      ei0_far1
#define DI_NR_CTRL0                                0x1707
//bit 26,       nr_cue_en
//bit 25,       nr2_en
#define DI_NR_CTRL1                                0x1708
//bit 31:30,    mot_p1txtcore_mode  
//bit 29:24,    mot_p1txtcore_clmt  
//bit 21:16,    mot_p1txtcore_ylmt  
//bit 15:8,     mot_p1txtcore_crate  
//bit 7:0,      mot_p1txtcore_yrate  
#define DI_NR_CTRL2                                0x1709
//bit 29:24,    mot_curtxtcore_clmt  
//bit 21:16,    mot_curtxtcore_ylmt  
//bit 15:8,     mot_curtxtcore_crate  
//bit 7:0,      mot_curtxtcore_yrate  
//`define DI_NR_CTRL3               8'h0a
//no use
//`define DI_MTN_CTRL               8'h0b
//no use
#define DI_MTN_CTRL1                               0x170c
//bit 13 ,      me enable
//bit 12 ,      me autoenable
//bit 11:8,		mtn_paramtnthd
//bit 7:0,      mtn_parafltthd
#define DI_BLEND_CTRL                              0x170d
//bit 31,      blend_1_en         
//bit 30,      blend_mtn_lpf      
//bit 28,      post_mb_en         
//bit 27,      blend_mtn3p_max    
//bit 26,      blend_mtn3p_min    
//bit 25,      blend_mtn3p_ave    
//bit 24,      blend_mtn3p_maxtb  
//bit 23,      blend_mtn_flt_en   
//bit 22,      blend_data_flt_en  
//bit 21:20,   blend_top_mode     
//bit 19,      blend_reg3_enable  
//bit 18,      blend_reg2_enable  
//bit 17,      blend_reg1_enable  
//bit 16,      blend_reg0_enable  
//bit 15:14,   blend_reg3_mode    
//bit 13:12,   blend_reg2_mode    
//bit 11:10,   blend_reg1_mode    
//bit 9:8,     blend_reg0_mode    
//bit 7:0,     kdeint             
//`define DI_BLEND_CTRL1            8'h0e
//no use
//`define DI_BLEND_CTRL2            8'h0f
//no use
#define DI_BLEND_REG0_X                            0x1710
//bit 27:16,   blend_reg0_startx
//bit 11:0,    blend_reg0_endx
#define DI_BLEND_REG0_Y                            0x1711
#define DI_BLEND_REG1_X                            0x1712
#define DI_BLEND_REG1_Y                            0x1713
#define DI_BLEND_REG2_X                            0x1714
#define DI_BLEND_REG2_Y                            0x1715
#define DI_BLEND_REG3_X                            0x1716
#define DI_BLEND_REG3_Y                            0x1717
#define DI_CLKG_CTRL                               0x1718
//bit 31:24,   pre_gclk_ctrl     no clk gate control. if ==1, module clk is not gated (always on). [3] for pulldown,[2] for mtn_1,[1] for mtn_0,[0] for nr
//bit 23:16,   post_gclk_ctrl    no clk gate control. [4] for ei_1, [3] for ei_0,[2] for ei_top, [1] for blend_1, [0] for blend_0
//bit 1,       di_gate_all       clk shut down. if ==1 , all di clock shut down
//bit 0,       di_no_clk_gate    no clk gate control.     if di_gated_all==0 and di_no_clk_gate ==1, all di clock is always working.                         
#define DI_EI_CTRL3                                0x1719
//bit 31,      reg_ei_1
//bit 30,      reg_demon_en
//bit 26:24,   reg_demon_mux
//bit 23:20,   reg_right_win
//bit 19:16,   reg_left_win
//bit 7:4,     reg_ei_sadm_quatize_margin
//bit 1:0,     reg_ei_sad_relative_mode
#define DI_EI_CTRL4                                0x171a
//bit 29,      reg_ei_caldrt_ambliike2_biasvertical
//bit 28:24,   reg_ei_caldrt_addxla2list_drtmax
//bit 22:20,   reg_ei_caldrt_addxla2list_signm0th
//bit 19,      reg_ei_caldrt_addxla2list_mode
//bit 18:16,   reg_ei_signm_sad_cor_rate
//bit 15:12,   reg_ei_signm_sadi_cor_rate
//bit 11:6,    reg_ei_signm_sadi_cor_ofst
//bit 5:0,     reg_ei_signm_sad_ofst
#define DI_EI_CTRL5                                0x171b
//bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd
//bit 26:24,   reg_ei_caldrt_cnflctchk_mg
//bit 23:22,   reg_ei_caldrt_cnflctchk_ws
//bit 21,      reg_ei_caldrt_cnflctchk_en
//bit 20,      reg_ei_caldrt_verfrc_final_en
//bit 19,      reg_ei_caldrt_verfrc_retimflt_en
//bit 18:16,   reg_ei_caldrt_verftc_eithratemth
//bit 15,      reg_ei_caldrt_verfrc_retiming_en
//bit 14:12,   reg_ei_caldrt_verfrc_bothratemth
//bit 11:9,    reg_ei_caldrt_ver_thrd
//bit 8:4,     reg_ei_caldrt_addxla2list_drtmin
//bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit
#define DI_EI_CTRL6                                0x171c
//bit 31:24,   reg_ei_caldrt_abext_sad12thhig
//bit 23:16,   reg_ei_caldrt_abext_sad00thlow
//bit 15:8,    reg_ei_caldrt_abext_sad12thlow
//bit 6:4,     reg_ei_caldrt_abext_ratemth
//bit 2:0,     reg_ei_caldrt_abext_drtthrd
#define DI_EI_CTRL7                                0x171d
//bit 29,      reg_ei_caldrt_xlanopeak_codien
//bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax
//bit 23,      reg_ei_caldrt_xlanopeak_en
//bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha
//bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd
//bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd
//bit 28:24,   reg_ei_caldrt_abext_sad00rate
//bit 28:24,   reg_ei_caldrt_abext_sad12rate
//bit 28:24,   reg_ei_caldrt_abext_sad00thhig          
#define DI_EI_CTRL8                                0x171e
//bit 30:28,   reg_ei_assign_headtail_magin
//bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode
//bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth
//bit 20,      reg_ei_caldrt_histchk_cnfid
//bit 19:16,   reg_ei_caldrt_histchk_thrd
//bit 15,      reg_ei_caldrt_histchk_abext
//bit 14,      reg_ei_caldrt_histchk_npen
//bit 13:11,   reg_ei_caldrt_amblike2_drtmg
//bit 10:8,    reg_ei_caldrt_amblike2_valmg
//bit 7:4,     reg_ei_caldrt_amblike2_alpha
//bit 3:0,     reg_ei_caldrt_amblike2_drtth
#define DI_EI_CTRL9                                0x171f
//bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3
//bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en
//bit 26:24,   reg_ei_caldrt_conf_drtth
//bit 23:20,   reg_ei_caldrt_conf_absdrtth
//bit 19:18,   reg_ei_caldrt_abcheck_mode1
//bit 17:16,   reg_ei_caldrt_abcheck_mode0
//bit 15:12,   reg_ei_caldrt_abcheck_drth1
//bit 11:8,    reg_ei_caldrt_abcheck_drth0
//bit 6:4,     reg_ei_caldrt_abpnchk1_th
//bit 1,       reg_ei_caldrt_abpnchk1_en
//bit 0,       reg_ei_caldrt_abpnchk0_en
#define DI_EI_CTRL10                               0x1793
//bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth
//bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd
//bit 23:20,   reg_ei_caldrt_hstrrgchk_mg
//bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul
//bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf
//bit 17:16,   reg_ei_caldrt_hstrrgchk_ws
//bit 15,      reg_ei_caldrt_hstrrgchk_en
//bit 14:13,   reg_ei_caldrt_hpncheck_mode
//bit 12,      reg_ei_caldrt_hpncheck_mute
//bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2
//bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1
//bit 5:4,     reg_ei_caldrt_hcnfcheck_mode
//bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2
#define DI_EI_CTRL11                               0x179e
//bit 30:29,   reg_ei_amb_detect_mode
//bit 28:24,   reg_ei_amb_detect_winth
//bit 23:21,   reg_ei_amb_decide_rppth
//bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth
//bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode
//bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode
//bit 13:12,   reg_ei_retime_lastvertfrcchk_mode
//bit 11:8,    reg_ei_retime_lastpnchk_drtth
//bit 6,       reg_ei_retime_lastpnchk_en
//bit 5:4,     reg_ei_retime_mode
//bit 3,       reg_ei_retime_last_en
//bit 2,       reg_ei_retime_ab_en
//bit 1,       reg_ei_caldrt_hstrvertfrcchk_en
//bit 0,       reg_ei_caldrt_hstrrgchk_mode
#define DI_EI_CTRL12                               0x179f
//bit 31:28,   reg_ei_drtdelay2_lmt
//bit 27:26,   reg_ei_drtdelay2_notver_lrwin
//bit 25:24,   reg_ei_drtdelay_mode
//bit 23,      reg_ei_drtdelay2_mode
//bit 22:20,   reg_ei_assign_xla_signm0th
//bit 19,      reg_ei_assign_pkbiasvert_en
//bit 18,      reg_ei_assign_xla_en
//bit 17:16,   reg_ei_assign_xla_mode
//bit 15:12,   reg_ei_assign_nlfilter_magin
//bit 11:8,    reg_ei_localsearch_maxrange
//bit 7:4,     reg_ei_xla_drtth
//bit 3:0,     reg_ei_flatmsad_thrd
#define DI_EI_CTRL13                               0x17a8
//bit 27:24,   reg_ei_int_drt2x_chrdrt_limit
//bit 23:20,   reg_ei_int_drt16x_core
//bit 19:16,   reg_ei_int_drtdelay2_notver_cancv
//bit 15:8,    reg_ei_int_drtdelay2_notver_sadth
//bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth
#define DI_EI_XWIN0                                0x1798
//bit 27:16,   ei_xend0
//bit 11:0,    ei_xstart0
#define DI_EI_XWIN1                                0x1799
// DEINTERLACE mode check.
#define DI_MC_REG0_X                               0x1720
//bit 27:16,   mc_reg0_start_x 
//bit 11:0,    mc_reg0_end_x 
#define DI_MC_REG0_Y                               0x1721
#define DI_MC_REG1_X                               0x1722
#define DI_MC_REG1_Y                               0x1723
#define DI_MC_REG2_X                               0x1724
#define DI_MC_REG2_Y                               0x1725
#define DI_MC_REG3_X                               0x1726
#define DI_MC_REG3_Y                               0x1727
#define DI_MC_REG4_X                               0x1728
#define DI_MC_REG4_Y                               0x1729
#define DI_MC_32LVL0                               0x172a
//bit 31:24,   mc_reg2_32lvl
//bit 23:16,   mc_reg1_32lvl
//bit 15:8,    mc_reg0_32lvl
//bit 7:0,     field_32lvl
#define DI_MC_32LVL1                               0x172b
//bit 15:8,    mc_reg3_32lvl
//bit 7:0,     mc_reg4_32lvl
#define DI_MC_22LVL0                               0x172c
//bit 31:16,   mc_reg0_22lvl
//bit 15:0,    field_22lvl
#define DI_MC_22LVL1                               0x172d
//bit 31:16,   mc_reg2_22lvl
//bit 15:0,    mc_reg1_22lvl
#define DI_MC_22LVL2                               0x172e
//bit 31:16,   mc_reg4_22lvl
//bit 15:0,    mc_reg3_22lvl
#define DI_MC_CTRL                                 0x172f
//bit 4,       mc_reg4_en 
//bit 3,       mc_reg3_en 
//bit 2,       mc_reg2_en 
//bit 1,       mc_reg1_en 
//bit 0,       mc_reg0_en 
#define DI_INTR_CTRL                               0x1730
#define DI_INFO_ADDR                               0x1731
#define DI_INFO_DATA                               0x1732
#define DI_PRE_HOLD                                0x1733
#define DI_MTN_1_CTRL1                             0x1740
//bit 31,      mtn_1_en
//bit 30,      mtn_init
//bit 29,      di2nr_txt_en
//bit 28,      di2nr_txt_mode
//bit 27:24,   mtn_def
//bit 23:16,   mtn_adp_yc
//bit 15:8,    mtn_adp_2c
//bit 7:0,     mtn_adp_2y
#define DI_MTN_1_CTRL2                             0x1741
//bit 31:24,   mtn_ykinter
//bit 23:16,   mtn_ckinter
//bit 15:8,    mtn_ykintra
//bit  7:0,    mtn_ckintra
#define DI_MTN_1_CTRL3                             0x1742
//bit 31:24,   mtn_tyrate 
//bit 23:16,   mtn_tcrate
//bit 15: 8,   mtn_mxcmby
//bit  7: 0,   mtn_mxcmbc
#define DI_MTN_1_CTRL4                             0x1743
//bit 31:24,   mtn_tcorey
//bit 23:16,   mtn_tcorec
//bit 15: 8,   mtn_minth
//bit  7: 0,   mtn_maxth
#define DI_MTN_1_CTRL5                             0x1744
//bit 31:28,   mtn_m1b_extnd
//bit 27:24,   mtn_m1b_errod
//bit 19:18,   mtn_replace_cbyy
//bit 17:16,   mtn_replace_ybyc
//bit 15: 8,   mtn_core_ykinter
//bit  7: 0,   mtn_core_ckinter
#define DI_MTN_1_CTRL6                             0x17a9
//bit 31:24,   mtn_m1b_extnd
//bit 23:16,   mtn_m1b_errod
//bit 15: 8,   mtn_core_ykinter
//bit  7: 0,   mtn_core_ckinter
#define DI_MTN_1_CTRL7                             0x17aa
//bit 31:24,   mtn_core_mxcmby
//bit 23:16,   mtn_core_mxcmbc
//bit 15: 8,   mtn_core_y     
//bit  7: 0,   mtn_core_c     
#define DI_MTN_1_CTRL8                             0x17ab
//bit 31:24,   mtn_fcore_ykinter
//bit 23:16,   mtn_fcore_ckinter
//bit 15: 8,   mtn_fcore_ykintra
//bit  7: 0,   mtn_fcore_ckintra
#define DI_MTN_1_CTRL9                             0x17ac
//bit 31:24,   mtn_fcore_2yrate 
//bit 23:16,   mtn_fcore_2crate
//bit 15: 8,   mtn_fcore_y     
//bit  7: 0,   mtn_fcore_c     
#define DI_MTN_1_CTRL10                            0x17ad
//bit 27:24,   mtn_motfld0 
//bit 19:16,   mtn_stlfld0  
//bit 11: 8,   mtn_motfld1  
//bit  3: 0,   mtn_stlfld1  
#define DI_MTN_1_CTRL11                            0x17ae
//bit 27:24,   mtn_smotevn
//bit 20:16,   mtn_smotodd
//bit 11: 8,   mtn_sstlevn
//bit  4: 0,   mtn_sstlodd
#define DI_MTN_1_CTRL12                            0x17af
//bit 31:24,   mtn_mgain
//bit 17:16,   mtn_mmode
//bit 15: 8,   mtn_sthrd
//bit  4: 0,   mtn_sgain
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f
#define DET3D_MOTN_CFG                             0x1734
//Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
//Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma: 
//                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
//Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
//Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
#define DET3D_CB_CFG                               0x1735
//Bit 7:4,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizotnal or vertical combing detection.  
//Bit 3:0,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizotnal or vertical combing detection.  
#define DET3D_SPLT_CFG                             0x1736
//Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection. 
//                                      The smaller of this value, the easier of the split line detected. 
//Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation. 
//                                      The smaller of this value, the more samples will be added to the estimation.
#define DET3D_HV_MUTE                              0x1737
//Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part. 
//Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part. 
//Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part 
//Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part 
//Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block. 
//Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block. 
#define DET3D_MAT_STA_P1M1                         0x1738
//Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
//Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
//Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
//Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
#define DET3D_MAT_STA_P1TH                         0x1739
//Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)   
//Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
//Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
#define DET3D_MAT_STA_M1TH                         0x173a
//Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
//Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
//Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
#define DET3D_MAT_STA_RSFT                         0x173b
//Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping: 
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping: 
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping: 
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
#define DET3D_MAT_SYMTC_TH                         0x173c
//Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric. 
//Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric. 
//Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric. 
//Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric. 
#define DET3D_RO_DET_CB_HOR                        0x173d
//Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
//Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
#define DET3D_RO_DET_CB_VER                        0x173e
//Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
//Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
#define DET3D_RO_SPLT_HT                           0x173f
//Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
//Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
//Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//// DET 3D REG DEFINE END ////
//// NR2 REG DEFINE BEGIN////
#define NR2_MET_NM_CTRL                            0x1745
//Bit 28,	   reg_NM_reset	          Reset to the status of the Loop filter.
//Bit 27:24,   reg_NM_calc_length	  Length mode of the Noise measurement sample number for statistics.
//                                    0:  256 samples;    1: 512 samples;    2: 1024 samples;   ¡­X: 2^(8+x) samples
//Bit 23:20,   reg_NM_inc_step	      Loop filter input gain increase step. 
//Bit 19:16,   reg_NM_dec_step	      Loop filter input gain decrease step. 
//Bit 15:8,	   reg_NM_YHPmot_thrd	  Luma channel HP portion motion for condition of pixels included in Luma Noise measurement. 
//Bit 7:0,	   reg_NM_CHPmot_thrd	  Chroma channel HP portion motion for condition of pixels included in Chroma Noise measurement. 
#define NR2_MET_NM_YCTRL                           0x1746
//Bit 31:28,   reg_NM_YPLL_target	      Target rate of NM_Ynoise_thrd to mean of the Luma Noise 
//Bit 27:24,   reg_NM_YLPmot_thrd	      Luma channel LP portion motion for condition of pixels included in Luma Noise measurement. 
//Bit 23:16,   reg_NM_YHPmot_thrd_min	  Minimum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement. 
//Bit 15:8,	   reg_NM_YHPmot_thrd_max	  Maximum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement. 
//Bit 7:0,	   reg_NM_Ylock_rate	      Rate to decide whether the Luma noise measurement is lock or not.
#define NR2_MET_NM_CCTRL                           0x1747
//Bit 31:28,	reg_NM_CPLL_target	     Target rate of NM_Cnoise_thrd to mean of the Chroma Noise 
//Bit 27:24,	reg_NM_CLPmot_thrd	     Chroma channel LP portion motion for condition of pixels included in Chroma Noise measurement. 
//Bit 23:16,	reg_NM_CHPmot_thrd_min	 Minimum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement. 
//Bit 15:8,	    reg_NM_CHPmot_thrd_max	 Maximum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement. 
//Bit 7:0,	    reg_NM_Clock_rate	     Rate to decide whether the Chroma noise measurement is lock or not;
#define NR2_MET_NM_TNR                             0x1748
//Bit 25,	    ro_NM_TNR_Ylock	         Read-only register to tell ifLuma channel noise measurement is locked or not. 
//Bit 24,	    ro_NM_TNR_Clock	         Read-only register to tell if Chroma channel noise measurement is locked or not. 
//Bit 23:12,	ro_NM_TNR_Ylevel	     Read-only register to give Luma channel noise level. It was 16x of pixel difference in 8 bits of YHPmot. 
//Bit 11:0,	ro_NM_TNR_Clevel	         Read-only register to give Chroma channel noise level. It was 16x of pixel difference in 8 bits of CHPmot. 
#define NR2_MET_NMFRM_TNR_YLEV                     0x1749
//Bit 28:0,	ro_NMFrm_TNR_Ylevel	         Frame based Read-only register to give Luma channel noise level within one frame/field. 
#define NR2_MET_NMFRM_TNR_YCNT                     0x174a
//Bit 23:0,	ro_NMFrm_TNR_Ycount	         Number ofLuma channel pixels included in Frame/Field based noise level measurement.
#define NR2_MET_NMFRM_TNR_CLEV                     0x174b
//Bit 28:0,	ro_NMFrm_TNR_Clevel	         Frame based Read-only register to give Chroma channel noise level within one frame/field.
#define NR2_MET_NMFRM_TNR_CCNT                     0x174c
//Bit 23:0,	ro_NMFrm_TNR_Ccount	         Number of Chroma channel pixels included in Frame/Field based noise level measurement. 
#define NR2_3DEN_MODE                              0x174d
//Bit 6:4,	Blend_3dnr_en_r	
//Bit 2:0,	Blend_3dnr_en_l	
#define NR2_IIR_CTRL                               0x174e
//Bit 15:14, reg_LP_IIR_8bit_mode	LP IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
//                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
//Bit 13:12, reg_LP_IIR_mute_mode	Mode for the LP IIR mute,
//Bit 11:8,	 reg_LP_IIR_mute_thrd	Threshold of LP IIR mute to avoid ghost:
//Bit 7:6,	 reg_HP_IIR_8bit_mode	IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
//                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
//Bit 5:4,	reg_HP_IIR_mute_mode	Mode for theLP IIR mute
//Bit 3:0,	reg_HP_IIR_mute_thrd	Threshold of HP IIR mute to avoid ghost
//
#define NR2_SW_EN                                  0x174f
//Bit 17:8,	Clk_gate_ctrl	
//Bit 7,	Cfr_enable	
//Bit 5,	Det3d_en	
//Bit 4,	Nr2_proc_en	
//Bit 0,	Nr2_sw_en	
#define NR2_FRM_SIZE                               0x1750
//Bit 27:16,  Frm_heigh	Frame/field height
//Bit 11: 0,  Frm_width	Frame/field width
#define NR2_SNR_SAD_CFG                            0x1751
//Bit 12,	reg_MATNR_SNR_SAD_CenRPL	U1, Enable signal for Current pixel position SAD to be replaced by SAD_min.0: do not replace Current pixel position SAD by SAD_min;1: do replacements
//Bit 11:8,	reg_MATNR_SNR_SAD_coring	Coring value of the intra-frame SAD. sum = (sum - reg_MATNR_SNR_SAD_coring);sum = (sum<0) ? 0: (sum>255)? 255: sum;
//Bit 6:5,	reg_MATNR_SNR_SAD_WinMod	Unsigned, Intra-frame SAD matching window mode:0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
//Bit 4:0,	Sad_coef_num	            Sad coeffient
#define NR2_MATNR_SNR_OS                           0x1752
//Bit 7:4,	reg_MATNR_SNR_COS	    SNR Filter overshoot control margin for UV channel (X2 to u10 scale)
//Bit 3:0,	reg_MATNR_SNR_YOS	    SNR Filter overshoot control margin for luma channel (X2 to u10 scale)
#define NR2_MATNR_SNR_NRM_CFG                      0x1753
//Bit 23:16,	reg_MATNR_SNR_NRM_ofst	Edge based SNR boosting normalization offset to SAD_max ;
//Bit 15:8,	    reg_MATNR_SNR_NRM_max	Edge based SNR boosting normalization Max value
//Bit 7:0,	    reg_MATNR_SNR_NRM_min	Edge based SNR boosting normalization Min value
#define NR2_MATNR_SNR_NRM_GAIN                     0x1754
//Bit 15:8,	reg_MATNR_SNR_NRM_Cgain	Edge based SNR boosting normalization Gain for Chrm channel (norm 32 as 1)
//Bit 7:0,	reg_MATNR_SNR_NRM_Ygain	Edge based SNR boosting normalization Gain for Luma channel (norm 32 as 1)
#define NR2_MATNR_SNR_LPF_CFG                      0x1755
//Bit 23:16,reg_MATNR_SNRLPF_SADmaxTH	U8,  Threshold to SADmax to use TNRLPF to replace SNRLPF. i.e.if (SAD_max<reg_MATNR_SNRLPF_SADmaxTH) SNRLPF_yuv[k] = TNRLPF_yuv[k];
//Bit 13:11,reg_MATNR_SNRLPF_Cmode	    LPF based SNR filtering mode on CHRM channel:
//                                      0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 4 4 3]/16;  
//                                      4: TNRLPF;  5 : CurLPF3x3_yuv[];  6: CurLPF3o3_yuv[]  7: CurLPF3x5_yuv[]
//Bit 10:8,	reg_MATNR_SNRLPF_Ymode	    LPF based SNR filtering mode on LUMA channel:
//                                      0: gradient LPF //Bit [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8;3: gradient LPF [5 4 4 3]/16;      
//                                      4: TNRLPF;               5 : CurLPF3x3_yuv[];       6: CurLPF3o3_yuv[]         7: CurLPF3x5_yuv[]
//Bit 7:4,	reg_MATNR_SNRLPF_SADmin3TH	Offset threshold to SAD_min to Discard SAD_min3 corresponding pixel in LPF SNR filtering. (X8 to u8 scale) 
//Bit 3:0,	reg_MATNR_SNRLPF_SADmin2TH	Offset threshold to SAD_min to Discard SAD_min2 corresponding pixel in LPF SNR filtering. (X8 to u8 scale) 
#define NR2_MATNR_SNR_USF_GAIN                     0x1756
//Bit 15:8,	reg_MATNR_SNR_USF_Cgain	    Un-sharp (HP) compensate back Chrm portion gain, (norm 64 as 1)
//Bit 7:0,	reg_MATNR_SNR_USF_Ygain	    Un-sharp (HP) compensate back Luma portion gain, (norm 64 as 1)
#define NR2_MATNR_SNR_EDGE2B                       0x1757
//Bit 15:8,	reg_MATNR_SNR_Edge2Beta_ofst	U8,  Offset for Beta based on Edge.
//Bit 7:0,	reg_MATNR_SNR_Edge2Beta_gain	U8.  Gain to SAD_min for Beta based on Edge. (norm 16 as 1) 
#define NR2_MATNR_BETA_EGAIN                       0x1758
//Bit 15:8,	reg_MATNR_CBeta_Egain	U8,  Gain to Edge based Beta for Chrm channel. (normalized to 32 as 1)
//Bit 7:0,	reg_MATNR_YBeta_Egain	U8,  Gain to Edge based Beta for Luma channel. (normalized to 32 as 1)
#define NR2_MATNR_BETA_BRT                         0x1759
//Bit 31:28,	reg_MATNR_beta_BRT_limt_hi	U4,  Beta adjustment based on Brightness high side Limit. (X16 to u8 scale)
//Bit 27:24,	reg_MATNR_beta_BRT_slop_hi	U4,  Beta adjustment based on Brightness high side slope. Normalized to 16 as 1
//Bit 23:16,	reg_MATNR_beta_BRT_thrd_hi	U8,  Beta adjustment based on Brightness high threshold.(u8 scale)
//Bit 15:12,	reg_MATNR_beta_BRT_limt_lo	U4,  Beta adjustment based on Brightness low side Limit. (X16 to u8 scale)
//Bit 11:8,	    reg_MATNR_beta_BRT_slop_lo	U4,  Beta adjustment based on Brightness low side slope. Normalized to 16 as 1
//Bit 7:0,	    reg_MATNR_beta_BRT_thrd_lo	U8,  Beta adjustment based on Brightness low threshold.(u8 scale)
#define NR2_MATNR_XBETA_CFG                        0x175a
//Bit 19:18,	reg_MATNR_CBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Chrm channel;  
//Bit 17:16,	reg_MATNR_YBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Luma channel;
//Bit 15: 8,	reg_MATNR_CBeta_Ofst	    U8,  Offset to Beta for Chrm channel.(after beta_edge and beta_motion mux)
//Bit  7: 0,	reg_MATNR_YBeta_Ofst	    U8,  Offset to Beta for Luma channel.(after beta_edge and beta_motion mux)
#define NR2_MATNR_YBETA_SCL                        0x175b
//Bit 31:24,	reg_MATNR_YBeta_scale_min	U8,  Final step Beta scale low limit for Luma channel;
//Bit 23:16,	reg_MATNR_YBeta_scale_max	U8,  Final step Beta scale high limit for Luma channe;
//Bit 15: 8,	reg_MATNR_YBeta_scale_gain	U8,  Final step Beta scale Gain for Luma channel (normalized 32 to 1);
//Bit 7 : 0,	reg_MATNR_YBeta_scale_ofst	S8,  Final step Beta scale offset for Luma channel ;
#define NR2_MATNR_CBETA_SCL                        0x175c
//Bit 31:24,	reg_MATNR_CBeta_scale_min	Final step Beta scale low limit for Chrm channel.Similar to Y
//Bit 23:16,	reg_MATNR_CBeta_scale_max	U8,  Final step Beta scale high limit for Chrm channel.Similar to Y
//Bit 15: 8,	reg_MATNR_CBeta_scale_gain	U8,  Final step Beta scale Gain for Chrm channel Similar to Y
//Bit  7: 0,	reg_MATNR_CBeta_scale_ofst	S8,  Final step Beta scale offset for Chrm channel Similar to Y
#define NR2_SNR_MASK                               0x175d
//Bit 20:0, 	SAD_MSK	                    Valid signal in the 3x7 SAD surface
#define NR2_SAD2NORM_LUT0                          0x175e
//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_3	SAD convert normal LUT node 3
//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_2	SAD convert normal LUT node 2
//Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_1	SAD convert normal LUT node 1
//Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_0	SAD convert normal LUT node 0
#define NR2_SAD2NORM_LUT1                          0x175f
//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_7	SAD convert normal LUT node 7
//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_6	SAD convert normal LUT node 6
//Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_5	SAD convert normal LUT node 5
//Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_4	SAD convert normal LUT node 4
#define NR2_SAD2NORM_LUT2                          0x1760
//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_11	SAD convert normal LUT node 11
//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_10	SAD convert normal LUT node 10
//Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_9	SAD convert normal LUT node 9
//Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_8	SAD convert normal LUT node 8
#define NR2_SAD2NORM_LUT3                          0x1761
//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_15	SAD convert normal LUT node 15
//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_14	SAD convert normal LUT node 14
//Bit 15:8,	reg_MATNR_SAD2Norm_LUT_13	SAD convert normal LUT node 13
//Bit 7:0,	reg_MATNR_SAD2Norm_LUT_12	SAD convert normal LUT node 12
#define NR2_EDGE2BETA_LUT0                         0x1762
//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_3	Edge convert beta LUT node 3
//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_2	Edge convert beta LUT node 2
//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_1	Edge convert beta LUT node 1
//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_0	Edge convert beta LUT node 0
#define NR2_EDGE2BETA_LUT1                         0x1763
//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_7	Edge convert beta LUT node 7
//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_6	Edge convert beta LUT node 6
//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_5	Edge convert beta LUT node 5
//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_4	Edge convert beta LUT node 4
#define NR2_EDGE2BETA_LUT2                         0x1764
//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_11	Edge convert beta LUT node 11
//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_10	Edge convert beta LUT node 10
//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_9	Edge convert beta LUT node 9
//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_8	Edge convert beta LUT node 8
#define NR2_EDGE2BETA_LUT3                         0x1765
//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_15	Edge convert beta LUT node 15
//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_14	Edge convert beta LUT node 14
//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_13	Edge convert beta LUT node 13
//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_12	Edge convert beta LUT node 12
#define NR2_MOTION2BETA_LUT0                       0x1766
//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_3	Motion convert beta LUT node 3
//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_2	Motion convert beta LUT node 2
//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_1	Motion convert beta LUT node 1
//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_0	Motion convert beta LUT node 0
#define NR2_MOTION2BETA_LUT1                       0x1767
//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_7	Motion convert beta LUT node 7
//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_6	Motion convert beta LUT node 6
//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_5	Motion convert beta LUT node 5
//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_4	Motion convert beta LUT node 4
#define NR2_MOTION2BETA_LUT2                       0x1768
//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_11	Motion convert beta LUT node 11
//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_10	Motion convert beta LUT node 10
//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_9	Motion convert beta LUT node 9
//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_8	Motion convert beta LUT node 8
#define NR2_MOTION2BETA_LUT3                       0x1769
//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_15	Motion convert beta LUT node 15
//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_14	Motion convert beta LUT node 14
//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_13	Motion convert beta LUT node 13
//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_12	Motion convert beta LUT node 12
#define NR2_MATNR_MTN_CRTL                         0x176a
//Bit 25:24,	reg_MATNR_Vmtn_use_mode	    Motion_yuvV channel motion selection mode:0: Vmot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)  
//Bit 21:20,	reg_MATNR_Umtn_use_mode	    Motion_yuvU channel motion selection mode:0:Umot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)  
//Bit 17:16,	reg_MATNR_Ymtn_use_mode	    Motion_yuvLuma channel motion selection mode:0:  Ymot, 1: Ymot/2 + (Umot+Vmot)/4; 2: Ymot/2 + max(Umot,Vmot)/2; 3:  max(Ymot,Umot, Vmot)   
//Bit 13:12,	reg_MATNR_mtn_txt_mode	    Texture detection mode for adaptive coring of HP motion
//Bit  9: 8,	reg_MATNR_mtn_cor_mode	    Coring selection mode based on texture detection;
//Bit  6: 4,	reg_MATNR_mtn_hpf_mode	    video mode of current and previous frame/field for MotHPF_yuv[k] calculation:
//Bit  2: 0,	reg_MATNR_mtn_lpf_mode	    LPF video mode of current and previous frame/field for MotLPF_yuv[k] calculation:
#define NR2_MATNR_MTN_CRTL2                        0x176b
//Bit 18:16,	reg_MATNR_iir_BS_Ymode	    IIR TNR filter Band split filter mode for Luma LPF result generation (Cur and Prev);
//Bit 15: 8,	reg_MATNR_mtnb_alpLP_Cgain	Scale of motion_brthp_uv to motion_brtlp_uv, normalized to 32 as 1
//Bit  7: 0,	reg_MATNR_mtnb_alpLP_Ygain	Scale of motion_brthp_y to motion_brtlp_y, normalized to 32 as 1
#define NR2_MATNR_MTN_COR                          0x176c
//Bit 15:12,	reg_MATNR_mtn_cor_Cofst	    Coring Offset for Chroma Motion.
//Bit 11: 8,	reg_MATNR_mtn_cor_Cgain	    Gain to texture based coring for Chroma Motion. Normalized to 16 as 1
//Bit  7: 4,	reg_MATNR_mtn_cor_Yofst	    Coring Offset for Luma Motion.
//Bit  3: 0,	reg_MATNR_mtn_cor_Ygain	    Gain to texture based coring for Luma Motion. Normalized to 16 as 1
#define NR2_MATNR_MTN_GAIN                         0x176d
//Bit 31:24,	reg_MATNR_mtn_hp_Cgain	Gain to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
//Bit 23:16,	reg_MATNR_mtn_hp_Ygain	Gain to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
//Bit 15: 8,	reg_MATNR_mtn_lp_Cgain	Gain to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
//Bit  7: 0,	reg_MATNR_mtn_lp_Ygain	Gain to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
#define NR2_MATNR_DEGHOST                          0x176e
//Bit 8,	reg_MATNR_DeGhost_En	Enable signal for DeGhost function:0: disable; 1: enable  
//Bit 7:4,	reg_MATNR_DeGhost_COS	DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
//Bit 3:0,	reg_MATNR_DeGhost_YOS	DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
#define NR2_MATNR_ALPHALP_LUT0                     0x176f
//Bit 31:24,	reg_MATNR_AlphaLP_LUT_3	    Matnr low-pass filter alpha LUT node 3
//Bit 23:16,	reg_MATNR_AlphaLP_LUT_2	    Matnr low-pass filter alpha LUT node 2
//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_1	    Matnr low-pass filter alpha LUT node 1
//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_0	    Matnr low-pass filter alpha LUT node 0
#define NR2_MATNR_ALPHALP_LUT1                     0x1770
//Bit 31:24,	reg_MATNR_AlphaLP_LUT_7	    Matnr low-pass filter alpha LUT node 7
//Bit 23:16,	reg_MATNR_AlphaLP_LUT_6	    Matnr low-pass filter alpha LUT node 6
//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_5	    Matnr low-pass filter alpha LUT node 5
//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_4	    Matnr low-pass filter alpha LUT node 4
#define NR2_MATNR_ALPHALP_LUT2                     0x1771
//Bit 31:24,	reg_MATNR_AlphaLP_LUT_11	Matnr low-pass filter alpha LUT node 11
//Bit 23:16,	reg_MATNR_AlphaLP_LUT_10	Matnr low-pass filter alpha LUT node 10
//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_9	    Matnr low-pass filter alpha LUT node 9
//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_8	    Matnr low-pass filter alpha LUT node 8
#define NR2_MATNR_ALPHALP_LUT3                     0x1772
//Bit 31:24,	reg_MATNR_AlphaLP_LUT_15	Matnr low-pass filter alpha LUT node 15
//Bit 23:16,	reg_MATNR_AlphaLP_LUT_14	Matnr low-pass filter alpha LUT node 14
//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_13	Matnr low-pass filter alpha LUT node 13
//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_12	Matnr low-pass filter alpha LUT node 12
#define NR2_MATNR_ALPHAHP_LUT0                     0x1773
//Bit 31:24,	reg_MATNR_AlphaHP_LUT_3	    Matnr high-pass filter alpha LUT node 3
//Bit 23:16,	reg_MATNR_AlphaHP_LUT_2	    Matnr high-pass filter alpha LUT node 2
//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_1	    Matnr high-pass filter alpha LUT node 1
//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_0	    Matnr high-pass filter alpha LUT node 0
#define NR2_MATNR_ALPHAHP_LUT1                     0x1774
//Bit 31:24,	reg_MATNR_AlphaHP_LUT_7	    Matnr high-pass filter alpha LUT node 7
//Bit 23:16,	reg_MATNR_AlphaHP_LUT_6	    Matnr high-pass filter alpha LUT node 6
//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_5	    Matnr high-pass filter alpha LUT node 5
//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_4	    Matnr high-pass filter alpha LUT node 4
#define NR2_MATNR_ALPHAHP_LUT2                     0x1775
//Bit 31:24,	reg_MATNR_AlphaHP_LUT_11	Matnr high-pass filter alpha LUT node 11
//Bit 23:16,	reg_MATNR_AlphaHP_LUT_10	Matnr high-pass filter alpha LUT node 10
//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_9	    Matnr high-pass filter alpha LUT node 9
//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_8	    Matnr high-pass filter alpha LUT node 8
#define NR2_MATNR_ALPHAHP_LUT3                     0x1776
//Bit 31:24,	reg_MATNR_AlphaHP_LUT_15	Matnr high-pass filter alpha LUT node 15
//Bit 23:16,	reg_MATNR_AlphaHP_LUT_14	Matnr high-pass filter alpha LUT node 14
//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_13	Matnr high-pass filter alpha LUT node 13
//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_12	Matnr high-pass filter alpha LUT node 12
#define NR2_MATNR_MTNB_BRT                         0x1777
//Bit 31:28,	reg_MATNR_mtnb_BRT_limt_hi	Motion adjustment based on Brightness high side Limit. (X16 to u8 scale)
//Bit 27:24,	reg_MATNR_mtnb_BRT_slop_hi	Motion adjustment based on Brightness high side slope. Normalized to 16 as 1
//Bit 23:16,	reg_MATNR_mtnb_BRT_thrd_hi	Motion adjustment based on Brightness high threshold.(u8 scale)
//Bit 15:12,	reg_MATNR_mtnb_BRT_limt_lo	Motion adjustment based on Brightness low side Limit. (X16 to u8 scale)
//Bit 11: 8,	reg_MATNR_mtnb_BRT_slop_lo	Motion adjustment based on Brightness low side slope. Normalized to 16 as 1
//Bit  7: 0,	reg_MATNR_mtnb_BRT_thrd_lo	Motion adjustment based on Brightness low threshold.(u8 scale)
#define NR2_CUE_MODE                               0x1778
//Bit 9,	Cue_enable_r	        Cue right half frame enable
//Bit 8,	Cue_enable_l            Cue left half frame enable 
//Bit 6:4,	reg_CUE_CON_RPLC_mode	U3, CUE pixel chroma replace mode;
//Bit 2:0,	reg_CUE_CHRM_FLT_mode	U3, CUE improvement filter mode,
#define NR2_CUE_CON_MOT_TH                         0x1779
//Bit 31:24,	reg_CUE_CON_Cmot_thrd2	U8,  Motion Detection threshold of up/down two rows,  Chroma channel in Chroma Up-sampling Error (CUE) Detection (tighter). 
//Bit 23:16,	reg_CUE_CON_Ymot_thrd2	U8,  Motion Detection threshold of up/mid/down three rows,  Luma channel in Chroma Up-sampling Error (CUE) Detection (tighter). 
//Bit 15: 8,	reg_CUE_CON_Cmot_thrd	U8,  Motion Detection threshold of up/down two rows, Chroma channel in Chroma Up-sampling Error (CUE) Detection.
//Bit  7: 0,	reg_CUE_CON_Ymot_thrd	U8,  Motion Detection threshold of up/mid/down three rows, Luma channel in Chroma Up-sampling Error (CUE) Detection. 
#define NR2_CUE_CON_DIF0                           0x177a
//Bit 15:8,	reg_CUE_CON_difP1_thrd	    U8,  P1 field Intra-Field top/below line chroma difference threshold, 
//Bit 7:0,	reg_CUE_CON_difCur_thrd	    U8,  Current Field/Frame Intra-Field up/down line chroma difference threshold, 
#define NR2_CUE_CON_DIF1                           0x177b
//Bit 19:16,	reg_CUE_CON_rate0	    U4,  The Krate to decide CUE by relationship between CUE_diflG and CUE_difEG 
//Bit 15: 8,	reg_CUE_CON_difEG_thrd	U8,  Theshold to the difference between current Field/Frame middle line to down line color channel(CUE_difEG). 
//Bit  7: 0,	reg_CUE_CON_diflG_thrd	U8,  Threshold to the difference between P1 field top line to current Field/Frame down line color channel (CUE_diflG).
#define NR2_CUE_CON_DIF2                           0x177c
//Bit 19:16,	reg_CUE_CON_rate1	    U4,  The Krate to decide CUE by relationship between CUE_difnC and CUE_difEC 
//Bit 15: 8,	reg_CUE_CON_difEC_thrd	U8,  Theshold to the difference between current Field/Frame middle line to up line color channel(CUE_difEC). 
//Bit  7: 0,	reg_CUE_CON_difnC_thrd	U8,  Threshold to the difference between P1 field bot line to current Field/Frame up line color channel (CUE_difnC). 
#define NR2_CUE_CON_DIF3                           0x177d
//Bit 19:16,	reg_CUE_CON_rate2	    U4,  The Krate to decide CUE by relationship between CUE_difP1 and CUE_difEP1 
//Bit 15: 8,	reg_CUE_CON_difEP1_thrd	U8,  Inter-Field top/below line to current field/frame middle line chroma difference (CUE_difEP1) threshold. 
//Bit  7: 0,	reg_CUE_CON_difP1_thrd2	U8,  P1 field Intra-Field top/below line chroma difference threshold (tighter), 
#define NR2_CUE_PRG_DIF                            0x177e
//Bit 20,	    reg_CUE_PRG_Enable	    Enable bit for progressive video CUE detection.If interlace input video, 
//Bit 19:16,	reg_CUE_PRG_rate	    U3,  The Krate to decide CUE by relationship between CUE_difCur and (CUE_difEC+CUE_difEG) 
//Bit 15: 8,	reg_CUE_PRG_difCEG_thrd	U8,  Current Frame Intra-Field up-mid and mid-down line chroma difference threshold for progressive video CUE detection, 
//Bit  7: 0,	reg_CUE_PRG_difCur_thrd	U8,  Current Frame Intra-Field up/down line chroma difference threshold, 
#define NR2_CONV_MODE                              0x177f
//Bit 3:2,	Conv_c444_mode	The format convert mode about 422 to 444 when data read out line buffer
//Bit 1:0,	Conv_c422_mode	the format convert mode about 444 to 422 when data write to line buffer 
//// NR2 REG DEFINE END ////
//// DET 3D REG DEFINE BEGIN ////
////  8'h80~8'h8f
#define DET3D_RO_SPLT_HB                           0x1780
//Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define DET3D_RO_SPLT_VL                           0x1781
//Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define DET3D_RO_SPLT_VR                           0x1782
//Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define DET3D_RO_MAT_LUMA_LR                       0x1783
//Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically), 
//                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
//Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically), 
//                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
//Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision, 
//                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
#define DET3D_RO_MAT_LUMA_TB                       0x1784
//Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally), 
//Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally), 
//Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision, 
#define DET3D_RO_MAT_CHRU_LR                       0x1785
//Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically), 
//Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically), 
//Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision, 
#define DET3D_RO_MAT_CHRU_TB                       0x1786
//Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
#define DET3D_RO_MAT_CHRV_LR                       0x1787
//Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
#define DET3D_RO_MAT_CHRV_TB                       0x1788
//Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
#define DET3D_RO_MAT_HEDG_LR                       0x1789
//Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
#define DET3D_RO_MAT_HEDG_TB                       0x178a
//Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
#define DET3D_RO_MAT_VEDG_LR                       0x178b
//Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
#define DET3D_RO_MAT_VEDG_TB                       0x178c
//Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
#define DET3D_RO_MAT_MOTN_LR                       0x178d
//Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
#define DET3D_RO_MAT_MOTN_TB                       0x178e
//Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
#define DET3D_RO_FRM_MOTN                          0x178f
//Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
/// mat ram read enter addr
#define DET3D_RAMRD_ADDR_PORT                      0x179a
#define DET3D_RAMRD_DATA_PORT                      0x179b
#define NR2_CFR_PARA_CFG0                          0x179c
//Bit 8,	reg_CFR_CurDif_luma_mode	Current Field Top/Bot line Luma difference calculation mode
//Bit 7:6,	reg_MACFR_frm_phase	        U2  This will be a field based phase register that need to be set by FW phase to phase: 
//                                      this will be calculated based on dbdr_phase of the specific line of this frame. 
//                                      u1: dbdr_phase=1, center line is DB in current line;  dbdr_phase=2, center line is Dr in current line;
//Bit 5:4,	reg_CFR_CurDif_tran_mode	U2  Current Field Top/Bot line Luma/Chroma transition level calculation mode, 
//Bit 3:2,	reg_CFR_alpha_mode	        U2  Alpha selection mode for CFR block from curAlp and motAlp i.e. 0: motAlp; 1: (motAlp+curAlp)/2; 2: min(motAlp,curAlp); 3: max(motAlp,curAlp);
//Bit 1:0,	reg_CFR_Motion_Luma_mode	U2  LumaMotion Calculation mode for MA-CFR. 0: top/bot Lumma motion;   1: middle Luma Motion 2: top/bot + middle motion; 3: max(top/tot motion, middle motion)
#define NR2_CFR_PARA_CFG1                          0x179d
//Bit 23:16,	reg_CFR_alpha_gain	    gain to map muxed curAlp and motAlp to alpha that will be used for final blending.
//Bit 15: 8,	reg_CFR_Motion_ofst	    Offset to Motion to calculate the motAlp, e,g:motAlp= reg_CFR_Motion_ofst- Motion;This register can be seen as the level of motion that we consider it at moving.
//Bit  7: 0,	reg_CFR_CurDif_gain	    gain to CurDif to map to alpha, normalized to 32;
//// DET 3D REG DEFINE END ////
#define DI_NR_1_CTRL0                              0x1794
#define DI_NR_1_CTRL1                              0x1795
#define DI_NR_1_CTRL2                              0x1796
#define DI_NR_1_CTRL3                              0x1797
#define DI_CONTWR_X                                0x17a0
#define DI_CONTWR_Y                                0x17a1
#define DI_CONTWR_CTRL                             0x17a2
#define DI_CONTPRD_X                               0x17a3
#define DI_CONTPRD_Y                               0x17a4
#define DI_CONTP2RD_X                              0x17a5
#define DI_CONTP2RD_Y                              0x17a6
#define DI_CONTRD_CTRL                             0x17a7
#define DI_NRWR_X                                  0x17c0
#define DI_NRWR_Y                                  0x17c1
#define DI_NRWR_CTRL                               0x17c2
#define DI_MTNWR_X                                 0x17c3
#define DI_MTNWR_Y                                 0x17c4
#define DI_MTNWR_CTRL                              0x17c5
#define DI_DIWR_X                                  0x17c6
#define DI_DIWR_Y                                  0x17c7
#define DI_DIWR_CTRL                               0x17c8
//`define DI_MTNCRD_X               8'hc9
//`define DI_MTNCRD_Y               8'hca
#define DI_MTNPRD_X                                0x17cb
#define DI_MTNPRD_Y                                0x17cc
#define DI_MTNRD_CTRL                              0x17cd
#define DI_INP_GEN_REG                             0x17ce
#define DI_INP_CANVAS0                             0x17cf
#define DI_INP_LUMA_X0                             0x17d0
#define DI_INP_LUMA_Y0                             0x17d1
#define DI_INP_CHROMA_X0                           0x17d2
#define DI_INP_CHROMA_Y0                           0x17d3
#define DI_INP_RPT_LOOP                            0x17d4
#define DI_INP_LUMA0_RPT_PAT                       0x17d5
#define DI_INP_CHROMA0_RPT_PAT                     0x17d6
#define DI_INP_DUMMY_PIXEL                         0x17d7
#define DI_INP_LUMA_FIFO_SIZE                      0x17d8
#define DI_INP_RANGE_MAP_Y                         0x17ba
#define DI_INP_RANGE_MAP_CB                        0x17bb
#define DI_INP_RANGE_MAP_CR                        0x17bc
#define DI_INP_GEN_REG2                            0x1791
#define DI_INP_FMT_CTRL                            0x17d9
#define DI_INP_FMT_W                               0x17da
#define DI_MEM_GEN_REG                             0x17db
#define DI_MEM_CANVAS0                             0x17dc
#define DI_MEM_LUMA_X0                             0x17dd
#define DI_MEM_LUMA_Y0                             0x17de
#define DI_MEM_CHROMA_X0                           0x17df
#define DI_MEM_CHROMA_Y0                           0x17e0
#define DI_MEM_RPT_LOOP                            0x17e1
#define DI_MEM_LUMA0_RPT_PAT                       0x17e2
#define DI_MEM_CHROMA0_RPT_PAT                     0x17e3
#define DI_MEM_DUMMY_PIXEL                         0x17e4
#define DI_MEM_LUMA_FIFO_SIZE                      0x17e5
#define DI_MEM_RANGE_MAP_Y                         0x17bd
#define DI_MEM_RANGE_MAP_CB                        0x17be
#define DI_MEM_RANGE_MAP_CR                        0x17bf
#define DI_MEM_GEN_REG2                            0x1792
#define DI_MEM_FMT_CTRL                            0x17e6
#define DI_MEM_FMT_W                               0x17e7
#define DI_IF1_GEN_REG                             0x17e8
#define DI_IF1_CANVAS0                             0x17e9
#define DI_IF1_LUMA_X0                             0x17ea
#define DI_IF1_LUMA_Y0                             0x17eb
#define DI_IF1_CHROMA_X0                           0x17ec
#define DI_IF1_CHROMA_Y0                           0x17ed
#define DI_IF1_RPT_LOOP                            0x17ee
#define DI_IF1_LUMA0_RPT_PAT                       0x17ef
#define DI_IF1_CHROMA0_RPT_PAT                     0x17f0
#define DI_IF1_DUMMY_PIXEL                         0x17f1
#define DI_IF1_LUMA_FIFO_SIZE                      0x17f2
#define DI_IF1_RANGE_MAP_Y                         0x17fc
#define DI_IF1_RANGE_MAP_CB                        0x17fd
#define DI_IF1_RANGE_MAP_CR                        0x17fe
#define DI_IF1_GEN_REG2                            0x1790
#define DI_IF1_FMT_CTRL                            0x17f3
#define DI_IF1_FMT_W                               0x17f4
#define DI_CHAN2_GEN_REG                           0x17f5
#define DI_CHAN2_CANVAS0                           0x17f6
#define DI_CHAN2_LUMA_X0                           0x17f7
#define DI_CHAN2_LUMA_Y0                           0x17f8
#define DI_CHAN2_CHROMA_X0                         0x17f9
#define DI_CHAN2_CHROMA_Y0                         0x17fa
#define DI_CHAN2_RPT_LOOP                          0x17fb
#define DI_CHAN2_LUMA0_RPT_PAT                     0x17b0
#define DI_CHAN2_CHROMA0_RPT_PAT                   0x17b1
#define DI_CHAN2_DUMMY_PIXEL                       0x17b2
#define DI_CHAN2_LUMA_FIFO_SIZE                    0x17b3
#define DI_CHAN2_RANGE_MAP_Y                       0x17b4
#define DI_CHAN2_RANGE_MAP_CB                      0x17b5
#define DI_CHAN2_RANGE_MAP_CR                      0x17b6
#define DI_CHAN2_GEN_REG2                          0x17b7
#define DI_CHAN2_FMT_CTRL                          0x17b8
#define DI_CHAN2_FMT_W                             0x17b9
#define DI_CANVAS_URGENT0                          0x170a
#define DI_CANVAS_URGENT1                          0x170b
#define DI_CANVAS_URGENT2                          0x170e
//
// Closing file:  vregs.h
//
//`define  VENC_VCBUS_BASE              8'h1b
//
// Reading file:  venc_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VENC_VCBUS_BASE = 0x1b
// -----------------------------------------------
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define ENCP_VFIFO2VD_CTL                          0x1b58
// bit 12:0 -- vfifo2vd_pixel_start 
#define ENCP_VFIFO2VD_PIXEL_START                  0x1b59
// bit 12:00 -- vfifo2vd_pixel_end   
#define ENCP_VFIFO2VD_PIXEL_END                    0x1b5a
// bit 10:0 -- vfifo2vd_line_top_start 
#define ENCP_VFIFO2VD_LINE_TOP_START               0x1b5b
// bit 10:00 -- vfifo2vd_line_top_end   
#define ENCP_VFIFO2VD_LINE_TOP_END                 0x1b5c
// bit 10:00 -- vfifo2vd_line_bot_start 
#define ENCP_VFIFO2VD_LINE_BOT_START               0x1b5d
// bit 10:00 -- vfifo2vd_line_bot_end   
#define ENCP_VFIFO2VD_LINE_BOT_END                 0x1b5e
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define VENC_SYNC_ROUTE                            0x1b60
#define VENC_VIDEO_EXSRC                           0x1b61
#define VENC_DVI_SETTING                           0x1b62
#define VENC_C656_CTRL                             0x1b63
#define VENC_UPSAMPLE_CTRL0                        0x1b64
#define VENC_UPSAMPLE_CTRL1                        0x1b65
#define VENC_UPSAMPLE_CTRL2                        0x1b66
// Invert control for tcon output
// bit[15:14] -- vsync, hsync, 
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define TCON_INVERT_CTL                            0x1b67
#define VENC_VIDEO_PROG_MODE                       0x1b68
//---- Venc pixel/line info
#define VENC_ENCI_LINE                             0x1b69
#define VENC_ENCI_PIXEL                            0x1b6a
#define VENC_ENCP_LINE                             0x1b6b
#define VENC_ENCP_PIXEL                            0x1b6c
//---- Status
#define VENC_STATA                                 0x1b6d
//---- Interrupt setting
#define VENC_INTCTRL                               0x1b6e
#define VENC_INTFLAG                               0x1b6f
//--------- Video test configuration
#define VENC_VIDEO_TST_EN                          0x1b70
#define VENC_VIDEO_TST_MDSEL                       0x1b71
#define VENC_VIDEO_TST_Y                           0x1b72
#define VENC_VIDEO_TST_CB                          0x1b73
#define VENC_VIDEO_TST_CR                          0x1b74
#define VENC_VIDEO_TST_CLRBAR_STRT                 0x1b75
#define VENC_VIDEO_TST_CLRBAR_WIDTH                0x1b76
#define VENC_VIDEO_TST_VDCNT_STSET                 0x1b77
//----- Video dac setting
#define VENC_VDAC_DACSEL0                          0x1b78
#define VENC_VDAC_DACSEL1                          0x1b79
#define VENC_VDAC_DACSEL2                          0x1b7a
#define VENC_VDAC_DACSEL3                          0x1b7b
#define VENC_VDAC_DACSEL4                          0x1b7c
#define VENC_VDAC_DACSEL5                          0x1b7d
#define VENC_VDAC_SETTING                          0x1b7e
#define VENC_VDAC_TST_VAL                          0x1b7f
#define VENC_VDAC_DAC0_GAINCTRL                    0x1bf0
#define VENC_VDAC_DAC0_OFFSET                      0x1bf1
#define VENC_VDAC_DAC1_GAINCTRL                    0x1bf2
#define VENC_VDAC_DAC1_OFFSET                      0x1bf3
#define VENC_VDAC_DAC2_GAINCTRL                    0x1bf4
#define VENC_VDAC_DAC2_OFFSET                      0x1bf5
#define VENC_VDAC_DAC3_GAINCTRL                    0x1bf6
#define VENC_VDAC_DAC3_OFFSET                      0x1bf7
#define VENC_VDAC_DAC4_GAINCTRL                    0x1bf8
#define VENC_VDAC_DAC4_OFFSET                      0x1bf9
#define VENC_VDAC_DAC5_GAINCTRL                    0x1bfa
#define VENC_VDAC_DAC5_OFFSET                      0x1bfb
#define VENC_VDAC_FIFO_CTRL                        0x1bfc
#define ENCL_TCON_INVERT_CTL                       0x1bfd
//
// Closing file:  venc_regs.h
//
//
// Reading file:  enc480p_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define ENCP_VIDEO_EN                              0x1b80
#define ENCP_VIDEO_SYNC_MODE                       0x1b81
#define ENCP_MACV_EN                               0x1b82
#define ENCP_VIDEO_Y_SCL                           0x1b83
#define ENCP_VIDEO_PB_SCL                          0x1b84
#define ENCP_VIDEO_PR_SCL                          0x1b85
#define ENCP_VIDEO_SYNC_SCL                        0x1b86
#define ENCP_VIDEO_MACV_SCL                        0x1b87
#define ENCP_VIDEO_Y_OFFST                         0x1b88
#define ENCP_VIDEO_PB_OFFST                        0x1b89
#define ENCP_VIDEO_PR_OFFST                        0x1b8a
#define ENCP_VIDEO_SYNC_OFFST                      0x1b8b
#define ENCP_VIDEO_MACV_OFFST                      0x1b8c
//----- Video mode
#define ENCP_VIDEO_MODE                            0x1b8d
#define ENCP_VIDEO_MODE_ADV                        0x1b8e
//--------------- Debug pins
#define ENCP_DBG_PX_RST                            0x1b90
#define ENCP_DBG_LN_RST                            0x1b91
#define ENCP_DBG_PX_INT                            0x1b92
#define ENCP_DBG_LN_INT                            0x1b93
//----------- Video Advanced setting
#define ENCP_VIDEO_YFP1_HTIME                      0x1b94
#define ENCP_VIDEO_YFP2_HTIME                      0x1b95
#define ENCP_VIDEO_YC_DLY                          0x1b96
#define ENCP_VIDEO_MAX_PXCNT                       0x1b97
#define ENCP_VIDEO_HSPULS_BEGIN                    0x1b98
#define ENCP_VIDEO_HSPULS_END                      0x1b99
#define ENCP_VIDEO_HSPULS_SWITCH                   0x1b9a
#define ENCP_VIDEO_VSPULS_BEGIN                    0x1b9b
#define ENCP_VIDEO_VSPULS_END                      0x1b9c
#define ENCP_VIDEO_VSPULS_BLINE                    0x1b9d
#define ENCP_VIDEO_VSPULS_ELINE                    0x1b9e
#define ENCP_VIDEO_EQPULS_BEGIN                    0x1b9f
#define ENCP_VIDEO_EQPULS_END                      0x1ba0
#define ENCP_VIDEO_EQPULS_BLINE                    0x1ba1
#define ENCP_VIDEO_EQPULS_ELINE                    0x1ba2
#define ENCP_VIDEO_HAVON_END                       0x1ba3
#define ENCP_VIDEO_HAVON_BEGIN                     0x1ba4
#define ENCP_VIDEO_VAVON_ELINE                     0x1baf
#define ENCP_VIDEO_VAVON_BLINE                     0x1ba6
#define ENCP_VIDEO_HSO_BEGIN                       0x1ba7
#define ENCP_VIDEO_HSO_END                         0x1ba8
#define ENCP_VIDEO_VSO_BEGIN                       0x1ba9
#define ENCP_VIDEO_VSO_END                         0x1baa
#define ENCP_VIDEO_VSO_BLINE                       0x1bab
#define ENCP_VIDEO_VSO_ELINE                       0x1bac
#define ENCP_VIDEO_SYNC_WAVE_CURVE                 0x1bad
#define ENCP_VIDEO_MAX_LNCNT                       0x1bae
#define ENCP_VIDEO_SY_VAL                          0x1bb0
#define ENCP_VIDEO_SY2_VAL                         0x1bb1
#define ENCP_VIDEO_BLANKY_VAL                      0x1bb2
#define ENCP_VIDEO_BLANKPB_VAL                     0x1bb3
#define ENCP_VIDEO_BLANKPR_VAL                     0x1bb4
#define ENCP_VIDEO_HOFFST                          0x1bb5
#define ENCP_VIDEO_VOFFST                          0x1bb6
#define ENCP_VIDEO_RGB_CTRL                        0x1bb7
#define ENCP_VIDEO_FILT_CTRL                       0x1bb8
#define ENCP_VIDEO_OFLD_VPEQ_OFST                  0x1bb9
#define ENCP_VIDEO_OFLD_VOAV_OFST                  0x1bba
#define ENCP_VIDEO_MATRIX_CB                       0x1bbb
#define ENCP_VIDEO_MATRIX_CR                       0x1bbc
#define ENCP_VIDEO_RGBIN_CTRL                      0x1bbd
//------------------Macrovision advanced setting
#define ENCP_MACV_BLANKY_VAL                       0x1bc0
#define ENCP_MACV_MAXY_VAL                         0x1bc1
#define ENCP_MACV_1ST_PSSYNC_STRT                  0x1bc2
#define ENCP_MACV_PSSYNC_STRT                      0x1bc3
#define ENCP_MACV_AGC_STRT                         0x1bc4
#define ENCP_MACV_AGC_END                          0x1bc5
#define ENCP_MACV_WAVE_END                         0x1bc6
#define ENCP_MACV_STRTLINE                         0x1bc7
#define ENCP_MACV_ENDLINE                          0x1bc8
#define ENCP_MACV_TS_CNT_MAX_L                     0x1bc9
#define ENCP_MACV_TS_CNT_MAX_H                     0x1bca
#define ENCP_MACV_TIME_DOWN                        0x1bcb
#define ENCP_MACV_TIME_LO                          0x1bcc
#define ENCP_MACV_TIME_UP                          0x1bcd
#define ENCP_MACV_TIME_RST                         0x1bce
//---------------- VBI control -------------------
#define ENCP_VBI_CTRL                              0x1bd0
#define ENCP_VBI_SETTING                           0x1bd1
#define ENCP_VBI_BEGIN                             0x1bd2
#define ENCP_VBI_WIDTH                             0x1bd3
#define ENCP_VBI_HVAL                              0x1bd4
#define ENCP_VBI_DATA0                             0x1bd5
#define ENCP_VBI_DATA1                             0x1bd6
//----------------C656 OUT Control------------- Grant
#define C656_HS_ST                                 0x1be0
#define C656_HS_ED                                 0x1be1
#define C656_VS_LNST_E                             0x1be2
#define C656_VS_LNST_O                             0x1be3
#define C656_VS_LNED_E                             0x1be4
#define C656_VS_LNED_O                             0x1be5
#define C656_FS_LNST                               0x1be6
#define C656_FS_LNED                               0x1be7
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  enc480p_regs.h
//
//
// Reading file:  enci_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define ENCI_VIDEO_MODE                            0x1b00
#define ENCI_VIDEO_MODE_ADV                        0x1b01
#define ENCI_VIDEO_FSC_ADJ                         0x1b02
#define ENCI_VIDEO_BRIGHT                          0x1b03
#define ENCI_VIDEO_CONT                            0x1b04
#define ENCI_VIDEO_SAT                             0x1b05
#define ENCI_VIDEO_HUE                             0x1b06
#define ENCI_VIDEO_SCH                             0x1b07
#define ENCI_SYNC_MODE                             0x1b08
#define ENCI_SYNC_CTRL                             0x1b09
#define ENCI_SYNC_HSO_BEGIN                        0x1b0a
#define ENCI_SYNC_HSO_END                          0x1b0b
#define ENCI_SYNC_VSO_EVN                          0x1b0c
#define ENCI_SYNC_VSO_ODD                          0x1b0d
#define ENCI_SYNC_VSO_EVNLN                        0x1b0e
#define ENCI_SYNC_VSO_ODDLN                        0x1b0f
#define ENCI_SYNC_HOFFST                           0x1b10
#define ENCI_SYNC_VOFFST                           0x1b11
#define ENCI_SYNC_ADJ                              0x1b12
#define ENCI_RGB_SETTING                           0x1b13
//`define	ENCI_CMPN_MATRIX_CB		8'h14
//`define	ENCI_CMPN_MATRIX_CR		8'h15
#define ENCI_DE_H_BEGIN                            0x1b16
#define ENCI_DE_H_END                              0x1b17
#define ENCI_DE_V_BEGIN_EVEN                       0x1b18
#define ENCI_DE_V_END_EVEN                         0x1b19
#define ENCI_DE_V_BEGIN_ODD                        0x1b1a
#define ENCI_DE_V_END_ODD                          0x1b1b
#define ENCI_VBI_SETTING                           0x1b20
#define ENCI_VBI_CCDT_EVN                          0x1b21
#define ENCI_VBI_CCDT_ODD                          0x1b22
#define ENCI_VBI_CC525_LN                          0x1b23
#define ENCI_VBI_CC625_LN                          0x1b24
#define ENCI_VBI_WSSDT                             0x1b25
#define ENCI_VBI_WSS_LN                            0x1b26
#define ENCI_VBI_CGMSDT_L                          0x1b27
#define ENCI_VBI_CGMSDT_H                          0x1b28
#define ENCI_VBI_CGMS_LN                           0x1b29
#define ENCI_VBI_TTX_HTIME                         0x1b2a
#define ENCI_VBI_TTX_LN                            0x1b2b
#define ENCI_VBI_TTXDT0                            0x1b2c
#define ENCI_VBI_TTXDT1                            0x1b2d
#define ENCI_VBI_TTXDT2                            0x1b2e
#define ENCI_VBI_TTXDT3                            0x1b2f
#define ENCI_MACV_N0                               0x1b30
#define ENCI_MACV_N1                               0x1b31
#define ENCI_MACV_N2                               0x1b32
#define ENCI_MACV_N3                               0x1b33
#define ENCI_MACV_N4                               0x1b34
#define ENCI_MACV_N5                               0x1b35
#define ENCI_MACV_N6                               0x1b36
#define ENCI_MACV_N7                               0x1b37
#define ENCI_MACV_N8                               0x1b38
#define ENCI_MACV_N9                               0x1b39
#define ENCI_MACV_N10                              0x1b3a
#define ENCI_MACV_N11                              0x1b3b
#define ENCI_MACV_N12                              0x1b3c
#define ENCI_MACV_N13                              0x1b3d
#define ENCI_MACV_N14                              0x1b3e
#define ENCI_MACV_N15                              0x1b3f
#define ENCI_MACV_N16                              0x1b40
#define ENCI_MACV_N17                              0x1b41
#define ENCI_MACV_N18                              0x1b42
#define ENCI_MACV_N19                              0x1b43
#define ENCI_MACV_N20                              0x1b44
#define ENCI_MACV_N21                              0x1b45
#define ENCI_MACV_N22                              0x1b46
//`define	ENCI_MACV_P_AGC			8'h47
#define ENCI_DBG_PX_RST                            0x1b48
#define ENCI_DBG_FLDLN_RST                         0x1b49
#define ENCI_DBG_PX_INT                            0x1b4a
#define ENCI_DBG_FLDLN_INT                         0x1b4b
#define ENCI_DBG_MAXPX                             0x1b4c
#define ENCI_DBG_MAXLN                             0x1b4d
#define ENCI_MACV_MAX_AMP                          0x1b50
#define ENCI_MACV_PULSE_LO                         0x1b51
#define ENCI_MACV_PULSE_HI                         0x1b52
#define ENCI_MACV_BKP_MAX                          0x1b53
#define ENCI_CFILT_CTRL                            0x1b54
#define ENCI_CFILT7                                0x1b55
#define ENCI_YC_DELAY                              0x1b56
#define ENCI_VIDEO_EN                              0x1b57
//
// Closing file:  enci_regs.h
//
//`define  VENC2_VCBUS_BASE             8'h1c
//
// Reading file:  venc2_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef; RDMA registers 0xcf0 - 0xcff)
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VENC2_VCBUS_BASE = 0x1c
// -----------------------------------------------
// Program video control signals from ENCI core to DVI/HDMI interface
#define ENCI_DVI_HSO_BEGIN                         0x1c00
#define ENCI_DVI_HSO_END                           0x1c01
#define ENCI_DVI_VSO_BLINE_EVN                     0x1c02
#define ENCI_DVI_VSO_BLINE_ODD                     0x1c03
#define ENCI_DVI_VSO_ELINE_EVN                     0x1c04
#define ENCI_DVI_VSO_ELINE_ODD                     0x1c05
#define ENCI_DVI_VSO_BEGIN_EVN                     0x1c06
#define ENCI_DVI_VSO_BEGIN_ODD                     0x1c07
#define ENCI_DVI_VSO_END_EVN                       0x1c08
#define ENCI_DVI_VSO_END_ODD                       0x1c09
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define ENCI_CFILT_CTRL2                           0x1c0a
#define ENCI_DACSEL_0                              0x1c0b
#define ENCI_DACSEL_1                              0x1c0c
#define ENCP_DACSEL_0                              0x1c0d
#define ENCP_DACSEL_1                              0x1c0e
#define ENCP_MAX_LINE_SWITCH_POINT                 0x1c0f
#define ENCI_TST_EN                                0x1c10
#define ENCI_TST_MDSEL                             0x1c11
#define ENCI_TST_Y                                 0x1c12
#define ENCI_TST_CB                                0x1c13
#define ENCI_TST_CR                                0x1c14
#define ENCI_TST_CLRBAR_STRT                       0x1c15
#define ENCI_TST_CLRBAR_WIDTH                      0x1c16
#define ENCI_TST_VDCNT_STSET                       0x1c17
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCI_VFIFO2VD_CTL                          0x1c18
// bit 12:0 -- vfifo2vd_pixel_start 
#define ENCI_VFIFO2VD_PIXEL_START                  0x1c19
// bit 12:00 -- vfifo2vd_pixel_end   
#define ENCI_VFIFO2VD_PIXEL_END                    0x1c1a
// bit 10:0 -- vfifo2vd_line_top_start 
#define ENCI_VFIFO2VD_LINE_TOP_START               0x1c1b
// bit 10:00 -- vfifo2vd_line_top_end   
#define ENCI_VFIFO2VD_LINE_TOP_END                 0x1c1c
// bit 10:00 -- vfifo2vd_line_bot_start 
#define ENCI_VFIFO2VD_LINE_BOT_START               0x1c1d
// bit 10:00 -- vfifo2vd_line_bot_end   
#define ENCI_VFIFO2VD_LINE_BOT_END                 0x1c1e
#define ENCI_VFIFO2VD_CTL2                         0x1c1f
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCT_VFIFO2VD_CTL                          0x1c20
// bit 12:0 -- vfifo2vd_pixel_start 
#define ENCT_VFIFO2VD_PIXEL_START                  0x1c21
// bit 12:00 -- vfifo2vd_pixel_end   
#define ENCT_VFIFO2VD_PIXEL_END                    0x1c22
// bit 10:0 -- vfifo2vd_line_top_start 
#define ENCT_VFIFO2VD_LINE_TOP_START               0x1c23
// bit 10:00 -- vfifo2vd_line_top_end   
#define ENCT_VFIFO2VD_LINE_TOP_END                 0x1c24
// bit 10:00 -- vfifo2vd_line_bot_start 
#define ENCT_VFIFO2VD_LINE_BOT_START               0x1c25
// bit 10:00 -- vfifo2vd_line_bot_end   
#define ENCT_VFIFO2VD_LINE_BOT_END                 0x1c26
#define ENCT_VFIFO2VD_CTL2                         0x1c27
#define ENCT_TST_EN                                0x1c28
#define ENCT_TST_MDSEL                             0x1c29
#define ENCT_TST_Y                                 0x1c2a
#define ENCT_TST_CB                                0x1c2b
#define ENCT_TST_CR                                0x1c2c
#define ENCT_TST_CLRBAR_STRT                       0x1c2d
#define ENCT_TST_CLRBAR_WIDTH                      0x1c2e
#define ENCT_TST_VDCNT_STSET                       0x1c2f
// Program video control signals from ENCP core to DVI/HDMI interface
#define ENCP_DVI_HSO_BEGIN                         0x1c30
#define ENCP_DVI_HSO_END                           0x1c31
#define ENCP_DVI_VSO_BLINE_EVN                     0x1c32
#define ENCP_DVI_VSO_BLINE_ODD                     0x1c33
#define ENCP_DVI_VSO_ELINE_EVN                     0x1c34
#define ENCP_DVI_VSO_ELINE_ODD                     0x1c35
#define ENCP_DVI_VSO_BEGIN_EVN                     0x1c36
#define ENCP_DVI_VSO_BEGIN_ODD                     0x1c37
#define ENCP_DVI_VSO_END_EVN                       0x1c38
#define ENCP_DVI_VSO_END_ODD                       0x1c39
#define ENCP_DE_H_BEGIN                            0x1c3a
#define ENCP_DE_H_END                              0x1c3b
#define ENCP_DE_V_BEGIN_EVEN                       0x1c3c
#define ENCP_DE_V_END_EVEN                         0x1c3d
#define ENCP_DE_V_BEGIN_ODD                        0x1c3e
#define ENCP_DE_V_END_ODD                          0x1c3f
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCI_SYNC_LINE_LENGTH                      0x1c40
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCI_SYNC_PIXEL_EN                         0x1c41
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCI_SYNC_TO_LINE_EN                       0x1c42
// Bit 12:0 - sync target pixel
#define ENCI_SYNC_TO_PIXEL                         0x1c43
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCP_SYNC_LINE_LENGTH                      0x1c44
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCP_SYNC_PIXEL_EN                         0x1c45
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCP_SYNC_TO_LINE_EN                       0x1c46
// Bit 12:0 - sync target pixel
#define ENCP_SYNC_TO_PIXEL                         0x1c47
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCT_SYNC_LINE_LENGTH                      0x1c48
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCT_SYNC_PIXEL_EN                         0x1c49
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCT_SYNC_TO_LINE_EN                       0x1c4a
// Bit 12:0 - sync target pixel
#define ENCT_SYNC_TO_PIXEL                         0x1c4b
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCL_SYNC_LINE_LENGTH                      0x1c4c
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCL_SYNC_PIXEL_EN                         0x1c4d
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCL_SYNC_TO_LINE_EN                       0x1c4e
// Bit 12:0 - sync target pixel
#define ENCL_SYNC_TO_PIXEL                         0x1c4f
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define ENCP_VFIFO2VD_CTL2                         0x1c50
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define VENC_DVI_SETTING_MORE                      0x1c51
#define VENC_VDAC_DAC4_FILT_CTRL0                  0x1c54
#define VENC_VDAC_DAC4_FILT_CTRL1                  0x1c55
#define VENC_VDAC_DAC5_FILT_CTRL0                  0x1c56
#define VENC_VDAC_DAC5_FILT_CTRL1                  0x1c57
//Bit 0   filter_en
#define VENC_VDAC_DAC0_FILT_CTRL0                  0x1c58
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define VENC_VDAC_DAC0_FILT_CTRL1                  0x1c59
//Bit 0   filter_en
#define VENC_VDAC_DAC1_FILT_CTRL0                  0x1c5a
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define VENC_VDAC_DAC1_FILT_CTRL1                  0x1c5b
//Bit 0   filter_en
#define VENC_VDAC_DAC2_FILT_CTRL0                  0x1c5c
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define VENC_VDAC_DAC2_FILT_CTRL1                  0x1c5d
//Bit 0   filter_en
#define VENC_VDAC_DAC3_FILT_CTRL0                  0x1c5e
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define VENC_VDAC_DAC3_FILT_CTRL1                  0x1c5f
//===========================================================================
// ENCT registers
#define ENCT_VIDEO_EN                              0x1c60
#define ENCT_VIDEO_Y_SCL                           0x1c61
#define ENCT_VIDEO_PB_SCL                          0x1c62
#define ENCT_VIDEO_PR_SCL                          0x1c63
#define ENCT_VIDEO_Y_OFFST                         0x1c64
#define ENCT_VIDEO_PB_OFFST                        0x1c65
#define ENCT_VIDEO_PR_OFFST                        0x1c66
//----- Video mode
#define ENCT_VIDEO_MODE                            0x1c67
#define ENCT_VIDEO_MODE_ADV                        0x1c68
//--------------- Debug pins
#define ENCT_DBG_PX_RST                            0x1c69
#define ENCT_DBG_LN_RST                            0x1c6a
#define ENCT_DBG_PX_INT                            0x1c6b
#define ENCT_DBG_LN_INT                            0x1c6c
//----------- Video Advanced setting
#define ENCT_VIDEO_YFP1_HTIME                      0x1c6d
#define ENCT_VIDEO_YFP2_HTIME                      0x1c6e
#define ENCT_VIDEO_YC_DLY                          0x1c6f
#define ENCT_VIDEO_MAX_PXCNT                       0x1c70
#define ENCT_VIDEO_HAVON_END                       0x1c71
#define ENCT_VIDEO_HAVON_BEGIN                     0x1c72
#define ENCT_VIDEO_VAVON_ELINE                     0x1c73
#define ENCT_VIDEO_VAVON_BLINE                     0x1c74
#define ENCT_VIDEO_HSO_BEGIN                       0x1c75
#define ENCT_VIDEO_HSO_END                         0x1c76
#define ENCT_VIDEO_VSO_BEGIN                       0x1c77
#define ENCT_VIDEO_VSO_END                         0x1c78
#define ENCT_VIDEO_VSO_BLINE                       0x1c79
#define ENCT_VIDEO_VSO_ELINE                       0x1c7a
#define ENCT_VIDEO_MAX_LNCNT                       0x1c7b
#define ENCT_VIDEO_BLANKY_VAL                      0x1c7c
#define ENCT_VIDEO_BLANKPB_VAL                     0x1c7d
#define ENCT_VIDEO_BLANKPR_VAL                     0x1c7e
#define ENCT_VIDEO_HOFFST                          0x1c7f
#define ENCT_VIDEO_VOFFST                          0x1c80
#define ENCT_VIDEO_RGB_CTRL                        0x1c81
#define ENCT_VIDEO_FILT_CTRL                       0x1c82
#define ENCT_VIDEO_OFLD_VPEQ_OFST                  0x1c83
#define ENCT_VIDEO_OFLD_VOAV_OFST                  0x1c84
#define ENCT_VIDEO_MATRIX_CB                       0x1c85
#define ENCT_VIDEO_MATRIX_CR                       0x1c86
#define ENCT_VIDEO_RGBIN_CTRL                      0x1c87
#define ENCT_MAX_LINE_SWITCH_POINT                 0x1c88
#define ENCT_DACSEL_0                              0x1c89
#define ENCT_DACSEL_1                              0x1c8a
//===========================================================================
// For ENCL
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCL_VFIFO2VD_CTL                          0x1c90
// bit 12:0 -- vfifo2vd_pixel_start 
#define ENCL_VFIFO2VD_PIXEL_START                  0x1c91
// bit 12:00 -- vfifo2vd_pixel_end   
#define ENCL_VFIFO2VD_PIXEL_END                    0x1c92
// bit 10:0 -- vfifo2vd_line_top_start 
#define ENCL_VFIFO2VD_LINE_TOP_START               0x1c93
// bit 10:00 -- vfifo2vd_line_top_end   
#define ENCL_VFIFO2VD_LINE_TOP_END                 0x1c94
// bit 10:00 -- vfifo2vd_line_bot_start 
#define ENCL_VFIFO2VD_LINE_BOT_START               0x1c95
// bit 10:00 -- vfifo2vd_line_bot_end   
#define ENCL_VFIFO2VD_LINE_BOT_END                 0x1c96
#define ENCL_VFIFO2VD_CTL2                         0x1c97
#define ENCL_TST_EN                                0x1c98
#define ENCL_TST_MDSEL                             0x1c99
#define ENCL_TST_Y                                 0x1c9a
#define ENCL_TST_CB                                0x1c9b
#define ENCL_TST_CR                                0x1c9c
#define ENCL_TST_CLRBAR_STRT                       0x1c9d
#define ENCL_TST_CLRBAR_WIDTH                      0x1c9e
#define ENCL_TST_VDCNT_STSET                       0x1c9f
//===========================================================================
// ENCL registers
#define ENCL_VIDEO_EN                              0x1ca0
#define ENCL_VIDEO_Y_SCL                           0x1ca1
#define ENCL_VIDEO_PB_SCL                          0x1ca2
#define ENCL_VIDEO_PR_SCL                          0x1ca3
#define ENCL_VIDEO_Y_OFFST                         0x1ca4
#define ENCL_VIDEO_PB_OFFST                        0x1ca5
#define ENCL_VIDEO_PR_OFFST                        0x1ca6
//----- Video mode
#define ENCL_VIDEO_MODE                            0x1ca7
#define ENCL_VIDEO_MODE_ADV                        0x1ca8
//--------------- Debug pins
#define ENCL_DBG_PX_RST                            0x1ca9
#define ENCL_DBG_LN_RST                            0x1caa
#define ENCL_DBG_PX_INT                            0x1cab
#define ENCL_DBG_LN_INT                            0x1cac
//----------- Video Advanced setting
#define ENCL_VIDEO_YFP1_HTIME                      0x1cad
#define ENCL_VIDEO_YFP2_HTIME                      0x1cae
#define ENCL_VIDEO_YC_DLY                          0x1caf
#define ENCL_VIDEO_MAX_PXCNT                       0x1cb0
#define ENCL_VIDEO_HAVON_END                       0x1cb1
#define ENCL_VIDEO_HAVON_BEGIN                     0x1cb2
#define ENCL_VIDEO_VAVON_ELINE                     0x1cb3
#define ENCL_VIDEO_VAVON_BLINE                     0x1cb4
#define ENCL_VIDEO_HSO_BEGIN                       0x1cb5
#define ENCL_VIDEO_HSO_END                         0x1cb6
#define ENCL_VIDEO_VSO_BEGIN                       0x1cb7
#define ENCL_VIDEO_VSO_END                         0x1cb8
#define ENCL_VIDEO_VSO_BLINE                       0x1cb9
#define ENCL_VIDEO_VSO_ELINE                       0x1cba
#define ENCL_VIDEO_MAX_LNCNT                       0x1cbb
#define ENCL_VIDEO_BLANKY_VAL                      0x1cbc
#define ENCL_VIDEO_BLANKPB_VAL                     0x1cbd
#define ENCL_VIDEO_BLANKPR_VAL                     0x1cbe
#define ENCL_VIDEO_HOFFST                          0x1cbf
#define ENCL_VIDEO_VOFFST                          0x1cc0
#define ENCL_VIDEO_RGB_CTRL                        0x1cc1
#define ENCL_VIDEO_FILT_CTRL                       0x1cc2
#define ENCL_VIDEO_OFLD_VPEQ_OFST                  0x1cc3
#define ENCL_VIDEO_OFLD_VOAV_OFST                  0x1cc4
#define ENCL_VIDEO_MATRIX_CB                       0x1cc5
#define ENCL_VIDEO_MATRIX_CR                       0x1cc6
#define ENCL_VIDEO_RGBIN_CTRL                      0x1cc7
#define ENCL_MAX_LINE_SWITCH_POINT                 0x1cc8
#define ENCL_DACSEL_0                              0x1cc9
#define ENCL_DACSEL_1                              0x1cca
//===========================================================================
// RDMA Registers       0xcf0 - 0xcff
// Bit 31: 0 RW AHB start address for manual start DMA
#define RDMA_AHB_START_ADDR_MAN                    0x1cf0
// Bit 31: 0 RW AHB end address for manual start DMA
#define RDMA_AHB_END_ADDR_MAN                      0x1cf1
// Bit 31: 0 RW AHB start address for auto start source 1
#define RDMA_AHB_START_ADDR_1                      0x1cf2
// Bit 31: 0 RW AHB end address for auto start source 1
#define RDMA_AHB_END_ADDR_1                        0x1cf3
// Bit 31: 0 RW AHB start address for auto start source 2
#define RDMA_AHB_START_ADDR_2                      0x1cf4
// Bit 31: 0 RW AHB end address for auto start source 2
#define RDMA_AHB_END_ADDR_2                        0x1cf5
// Bit 31: 0 RW AHB start address for auto start source 3
#define RDMA_AHB_START_ADDR_3                      0x1cf6
// Bit 31: 0 RW AHB end address for auto start source 3
#define RDMA_AHB_END_ADDR_3                        0x1cf7
// Auto start DMA control:
// Bit 31:24 RW ctrl_enable_int_3. Interrupt inputs enable mask for source 3.
// Bit 23:16 RW ctrl_enable_int_2. Interrupt inputs enable mask for source 2.
// Bit 15: 8 RW ctrl_enable_int_1. Interrupt inputs enable mask for source 1.
// Bit     7 RW ctrl_cbus_write_3. Register read/write mode for auto-start 3. 1=Register write; 0=Register read.
// Bit     6 RW ctrl_cbus_write_3. Register read/write mode for auto-start 2. 1=Register write; 0=Register read.
// Bit     5 RW ctrl_cbus_write_3. Register read/write mode for auto-start 1. 1=Register write; 0=Register read.
// Bit     4 R  Rsrv.
// Bit     3 RW ctrl_cbus_addr_incr_3. 1=Incremental register access for auto-start 3; 0=Non-incremental (individual) register access.
// Bit     2 RW ctrl_cbus_addr_incr_2. 1=Incremental register access for auto-start 2; 0=Non-incremental (individual) register access.
// Bit     1 RW ctrl_cbus_addr_incr_1. 1=Incremental register access for auto-start 1; 0=Non-incremental (individual) register access.
// Bit     0 R  Rsrv.
#define RDMA_ACCESS_AUTO                           0x1cf8
// Manual start DMA control:
// Bit 31: 3 R  Rsrv.
// Bit     2 RW ctrl_cbus_write_man. Register read/write mode for manual-start. 1=Register write; 0=Register read.
// Bit     1 RW ctrl_cbus_addr_incr_man. 1=Incremental register access for manual-start; 0=Non-incremental (individual) register access.
// Bit     0 W  ctrl_start_man. Write 1 to this bit to manual-start DMA. This bit always read back 0.
#define RDMA_ACCESS_MAN                            0x1cf9
// RDMA general control:
// Bit 31:25 R  Rsrv.
// Bit    24 W  ctrl_clr_rdma_done_int. Write 1 to reset rdma_int level to 0. No need to clear this bit.
// Bit 23:19 R  Rsrv.
// Bit 18:13 R  Rsrv.
// Bit 12: 7 R  Rsrv.
// Bit     6 RW ctrl_ddr_urgent.
// Bit  5: 4 RW ctrl_ahb_wr_burst_size. 0=ABH write request burst size 16;
//                                      1=ABH write request burst size 24;
//                                      2=ABH write request burst size 32;
//                                      3=ABH write request burst size 48.
// Bit  3: 2 RW ctrl_ahb_rd_burst_size. 0=ABH read request burst size 16;
//                                      1=ABH read request burst size 24;
//                                      2=ABH read request burst size 32;
//                                      3=ABH read request burst size 48.
// Bit     1 RW ctrl_sw_reset. 1=Reset RDMA logics except register.
// Bit     0 RW ctrl_free_clk_enable. 0=Default, Enable clock gating. 1=No clock gating, enable free clock.
#define RDMA_CTRL                                  0x1cfa
// Read only.
// Bit 31:29 R  Rsrv.
// Bit    28 R  rdma_done_int.
// Bit 27:25 R  Rsrv.
// Bit 24:18 R  ahb_wrfifo_cnt. FIFO for buffering CBus read data to be sent to AHB
// Bit 17:11 R  ahb_rdfifo_cnt. FIFO for buffering data read from AHB.
// Bit 10: 8 R  ddr_req_st. =0 -- Idle; !=0 -- AHB interfacing ongoing.
// Bit  7: 4 R  curr_req. Latest requests that is being/been serviced. E.g. 0000=Idle; 0010=Latest serviced request is Req 1.
// Bit  3: 0 R  req_latch. Requests that are yet to be serviced. E.g. 0000=No request; 0001=Req 0 waiting; 1100=Req 2 and 3 waiting.
#define RDMA_STATUS                                0x1cfb
//
// Closing file:  venc2_regs.h
//
//`define VPP_VCBUS_BASE			     8'h1d
//
// Reading file:  vpp_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPP_VCBUS_BASE = 0x1d
// -----------------------------------------------
//===========================================================================
// Video postprocesing Registers 
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define VPP_DUMMY_DATA                             0x1d00
//input line length used in VPP
#define VPP_LINE_IN_LENGTH                         0x1d01
//input Picture height used in VPP
#define VPP_PIC_IN_HEIGHT                          0x1d02
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered 
//Bit 6:0 	coef index
#define VPP_SCALE_COEF_IDX                         0x1d03
//coefficients for vertical filter and horizontal filter
#define VPP_SCALE_COEF                             0x1d04
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		. 
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region	
//		.
//  ---------------------------  
//  ---------------------------  <------ region1_startp 
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define VPP_VSC_REGION12_STARTP                    0x1d05
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define VPP_VSC_REGION34_STARTP                    0x1d06
#define VPP_VSC_REGION4_ENDP                       0x1d07
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0	fraction part
#define VPP_VSC_START_PHASE_STEP                   0x1d08
//vertical scaler region0 phase slope, Bit24 signed bit
#define VPP_VSC_REGION0_PHASE_SLOPE                0x1d09
//vertical scaler region1 phase slope, Bit24 signed bit
#define VPP_VSC_REGION1_PHASE_SLOPE                0x1d0a
//vertical scaler region3 phase slope, Bit24 signed bit
#define VPP_VSC_REGION3_PHASE_SLOPE                0x1d0b
//vertical scaler region4 phase slope, Bit24 signed bit
#define VPP_VSC_REGION4_PHASE_SLOPE                0x1d0c
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X, 
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field   
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field   
#define VPP_VSC_PHASE_CTRL                         0x1d0d
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define VPP_VSC_INI_PHASE                          0x1d0e
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define VPP_HSC_REGION12_STARTP                    0x1d10
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define VPP_HSC_REGION34_STARTP                    0x1d11
#define VPP_HSC_REGION4_ENDP                       0x1d12
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0	fraction part
#define VPP_HSC_START_PHASE_STEP                   0x1d13
//horizontal scaler region0 phase slope, Bit24 signed bit
#define VPP_HSC_REGION0_PHASE_SLOPE                0x1d14
//horizontal scaler region1 phase slope, Bit24 signed bit
#define VPP_HSC_REGION1_PHASE_SLOPE                0x1d15
//horizontal scaler region3 phase slope, Bit24 signed bit
#define VPP_HSC_REGION3_PHASE_SLOPE                0x1d16
//horizontal scaler region4 phase slope, Bit24 signed bit
#define VPP_HSC_REGION4_PHASE_SLOPE                0x1d17
//Bit 22:21   horizontal scaler initial repeat pixel0 number0
//Bit 19:16   horizontal scaler initial receiving number0   
//Bit 15:0    horizontal scaler top field initial phase0
#define VPP_HSC_PHASE_CTRL                         0x1d18
// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
// Bit 2:0 vertical scaler bank length
#define VPP_SC_MISC                                0x1d19
// preblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_PREBLEND_VD1_H_START_END               0x1d1a
// preblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_PREBLEND_VD1_V_START_END               0x1d1b
// postblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_POSTBLEND_VD1_H_START_END              0x1d1c
// postblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_POSTBLEND_VD1_V_START_END              0x1d1d
// preblend/postblend video2 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_BLEND_VD2_H_START_END                  0x1d1e
// preblend/postblend video2 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_BLEND_VD2_V_START_END                  0x1d1f
// preblend horizontal size
#define VPP_PREBLEND_H_SIZE                        0x1d20
// postblend horizontal size
#define VPP_POSTBLEND_H_SIZE                       0x1d21
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 15:8     preblend hold lines
//Bit 7:0      postblend hold lines
#define VPP_HOLD_LINES                             0x1d22
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define VPP_BLEND_ONECOLOR_CTRL                    0x1d23
//Read Only, VPP preblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define VPP_PREBLEND_CURRENT_XY                    0x1d24
//Read Only, VPP postblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define VPP_POSTBLEND_CURRENT_XY                   0x1d25
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// Bit 28   color management enable
// Bit 27,  if true, vd2 use viu2 output as the input, otherwise use normal vd2 from memory 
// Bit 26:18, vd2 alpha
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, vd2 enable for preblend
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, vd2 enable for postblend
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultipiled 
// Bit 8,  if true, osd2 is alpha premultipiled 
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,  
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//			 the aync fifo will be reseted.
// Bit 1,	  
// Bit 0	if true, the output result of VPP is saturated
#define VPP_MISC                                   0x1d26
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define VPP_OFIFO_SIZE                             0x1d27
//Read only
//Bit 28:18 current scale out fifo counter
//Bit 17:13 current afifo counter
//Bit 12:0 current ofifo counter
#define VPP_FIFO_STATUS                            0x1d28
// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable 
// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable 
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
#define VPP_SMOKE_CTRL                             0x1d29
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 chanel
//smoke2 for OSD2 chanel
//smoke3 for VD2 chanel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define VPP_SMOKE1_VAL                             0x1d2a
#define VPP_SMOKE2_VAL                             0x1d2b
#define VPP_SMOKE3_VAL                             0x1d2c
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE1_H_START_END                     0x1d2d
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE1_V_START_END                     0x1d2e
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE2_H_START_END                     0x1d2f
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE2_V_START_END                     0x1d30
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE3_H_START_END                     0x1d31
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE3_V_START_END                     0x1d32
//Bit 27:16 scale out fifo line length minus 1
//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
#define VPP_SCO_FIFO_CTRL                          0x1d33
//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 23 horizontal scaler double pixel mode
//Bit 22:21   horizontal scaler initial repeat pixel0 number1
//Bit 19:16   horizontal scaler initial receiving number1   
//Bit 15:0    horizontal scaler top field initial phase1
#define VPP_HSC_PHASE_CTRL1                        0x1d34
//for 3D quincunx sub-sampling
//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
//22:20  prehsc pattern start
//18:16 prehsc pattern end
//15:8 hsc pattern, each patten 1 bit, from lsb -> msb
//6:4  hsc pattern start
//2:0  hsc pattern end
#define VPP_HSC_INI_PAT_CTRL                       0x1d35
//Bit 3			minus black level enable for vadj2
//Bit 2			Video adjustment enable for vadj2
//Bit 1			minus black level enable for vadj1
//Bit 0			Video adjustment enable for vadj1
#define VPP_VADJ_CTRL                              0x1d40
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
#define VPP_VADJ1_Y                                0x1d41
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define VPP_VADJ1_MA_MB                            0x1d42
#define VPP_VADJ1_MC_MD                            0x1d43
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
#define VPP_VADJ2_Y                                0x1d44
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define VPP_VADJ2_MA_MB                            0x1d45
#define VPP_VADJ2_MC_MD                            0x1d46
//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur  
//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur  
//Bit 0 horizontal sharpness enable
#define VPP_HSHARP_CTRL                            0x1d50
//{1'b0,threhsold} < diff
//Bit 26:16  luma threshold0
//Bit 10:0   luma threshold1    
#define VPP_HSHARP_LUMA_THRESH01                   0x1d51
//
//Bit 26:16  luma threshold2
//Bit 10:0   luma threshold3    
#define VPP_HSHARP_LUMA_THRESH23                   0x1d52
//Bit 26:16  chroma threshold0
//Bit 10:0   chroma threshold1    
#define VPP_HSHARP_CHROMA_THRESH01                 0x1d53
//Bit 26:16  chroma threshold2
//Bit 10:0   chroma threshold3    
#define VPP_HSHARP_CHROMA_THRESH23                 0x1d54
//Bit 23:16 luma gain2
//Bit 15:8  luma gain1
//Bit 7:0   luma gain0
#define VPP_HSHARP_LUMA_GAIN                       0x1d55
//
//Bit 23:16 chroma gain2
//Bit 15:8  chroma gain1
//Bit 7:0   chroma gain0
#define VPP_HSHARP_CHROMA_GAIN                     0x1d56
//Read only 
//Bit 31, if it is true, it means this probe is valid in the last field/frame
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VPP_MATRIX_PROBE_COLOR                     0x1d5c
#define VPP_MATRIX_PROBE_COLOR1                    0x1dd7
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VPP_MATRIX_HL_COLOR                        0x1d5d
//28:16 probe x, postion
//12:0  probe y, position  
#define VPP_MATRIX_PROBE_POS                       0x1d5e
//Bit 16,  highlight_en
//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix, 010: select vd2 matrix
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    vd2 conversion matrix enable
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define VPP_MATRIX_CTRL                            0x1d5f
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VPP_MATRIX_COEF00_01                       0x1d60
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define VPP_MATRIX_COEF02_10                       0x1d61
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VPP_MATRIX_COEF11_12                       0x1d62
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VPP_MATRIX_COEF20_21                       0x1d63
#define VPP_MATRIX_COEF22                          0x1d64
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VPP_MATRIX_OFFSET0_1                       0x1d65
//Bit 10:0  offset2
#define VPP_MATRIX_OFFSET2                         0x1d66
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VPP_MATRIX_PRE_OFFSET0_1                   0x1d67
//Bit 10:0  pre_offset2
#define VPP_MATRIX_PRE_OFFSET2                     0x1d68
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define VPP_DUMMY_DATA1                            0x1d69
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define VPP_GAINOFF_CTRL0                          0x1d6a
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define VPP_GAINOFF_CTRL1                          0x1d6b
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define VPP_GAINOFF_CTRL2                          0x1d6c
//Bit 26:16, pre_offset0, signed data 
//Bit 10:0, pre_offset1, signed data 
#define VPP_GAINOFF_CTRL3                          0x1d6d
//Bit 10:0, pre_offset2, signed data 
#define VPP_GAINOFF_CTRL4                          0x1d6e
//only two registers used in the color management, which are defined in the chroma_reg.h
//`define VPP_CHROMA_ADDR_PORT    8'h70
//`define VPP_CHROMA_DATA_PORT    8'h71
//
// Reading file:  chroma_reg.h
//
//**********************************************************************************
//* Copyright (c) 2008, AMLOGIC Inc.
//* All rights reserved
//**********************************************************************************
//* File :  chroma_reg.v
//* Author : Terrence Wang
//* Date : Dec 2008
//* Description :  
//*
//********************************************************************************** 
//* Modification History:
//* Date    Modified By         Reason
//**********************************************************************************
// synopsys translate_off
// synopsys translate_on
#define VPP_CHROMA_ADDR_PORT                       0x1d70
#define VPP_CHROMA_DATA_PORT                       0x1d71
//`define CHROMA_ADDR_PORT        8'h67
//`define CHROMA_DATA_PORT        8'h68

//  CHROMA_GAIN_REG_XX(00-07)
//  hue gain, sat gain function control
//  Bit 31      reg_sat_en                  enable sat adjustment in current region
//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
//                                          1'b1: increase  1'b0: decrease
//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
//                                          2'b01 central biggest   2'b00 one side biggest
//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
//                                          1'b1: left side biggest 1'b0 right side biggest  
//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
//                                          0x00-0xff
//  Bit 15      reg_hue_en                  enable hue adjustment in current region
//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
//                                          1'b1: clockwise 1'b0: anti-clockwise
//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
//                                          1'b1: parabola curve    1'b0: non-symmetry curve
//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
//                                          1'b1: right side change more    1'b0: left side change more
//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
//                                          0x00-0x80, note: should be no bigger than 0x80

    #define CHROMA_GAIN_REG00       0x00


//  HUE_HUE_RANGE_REG_XX(00-07)
//  hue range select
//  Bit 31:24   no use now
//  Bit 23:16   reg_hue_shift_range         define the angle of target region
//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
//                                          must be greater or equal than 8'd8
//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
//                                          the symmetry region hue_shift_range = reg_hue_shift_range
//                                          in symmetry region, all the sat and hue setting will be same with original region, 
//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
//                                          0x6000 means 360 degree
//                                          only region 0 and 1 can exceed 360 degrees.

    #define HUE_HUE_RANGE_REG00     0x01


//  HUE_RANGE_INV_REG_XX
//  Calculation should be follow
//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
//  HUE_RANGE_INV_REG_XX is to used to save divider

    #define HUE_RANGE_INV_REG00     0x02



//  for belowing each low, high, low_slope, high_slope group:
//            a_____________b
//            /             \               a = low  + 2^low_slope
//           /               \              b = high - 2^high_slope
//          /                 \             low_slope <= 7; high_slope <= 7
//         /                   \            b >= a
//  ______/_____________________\________
//       low                    high
//
//
//  HUE_LUM_RANGE_REG_XX(00-07)
//  luma range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
//                                          0x00-0xff

    #define HUE_LUM_RANGE_REG00     0x03

//  HUE_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
//                                          0x00-0xff

    #define HUE_SAT_RANGE_REG00     0x04

//  SAT_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
//                                          0x00-0xff

    #define SAT_SAT_RANGE_REG00     0x05


    #define CHROMA_GAIN_REG01       0x06
    #define HUE_HUE_RANGE_REG01     0x07
    #define HUE_RANGE_INV_REG01     0x08
    #define HUE_LUM_RANGE_REG01     0x09
    #define HUE_SAT_RANGE_REG01     0x0a
    #define SAT_SAT_RANGE_REG01     0x0b

    #define CHROMA_GAIN_REG02       0x0c
    #define HUE_HUE_RANGE_REG02     0x0d
    #define HUE_RANGE_INV_REG02     0x0e
    #define HUE_LUM_RANGE_REG02     0x0f
    #define HUE_SAT_RANGE_REG02     0x10
    #define SAT_SAT_RANGE_REG02     0x11


    #define CHROMA_GAIN_REG03       0x12
    #define HUE_HUE_RANGE_REG03     0x13
    #define HUE_RANGE_INV_REG03     0x14
    #define HUE_LUM_RANGE_REG03     0x15
    #define HUE_SAT_RANGE_REG03     0x16
    #define SAT_SAT_RANGE_REG03     0x17

    #define CHROMA_GAIN_REG04       0x18
    #define HUE_HUE_RANGE_REG04     0x19
    #define HUE_RANGE_INV_REG04     0x1a
    #define HUE_LUM_RANGE_REG04     0x1b
    #define HUE_SAT_RANGE_REG04     0x1c
    #define SAT_SAT_RANGE_REG04     0x1d

    #define CHROMA_GAIN_REG05       0x1e
    #define HUE_HUE_RANGE_REG05     0x1f
    #define HUE_RANGE_INV_REG05     0x20
    #define HUE_LUM_RANGE_REG05     0x21
    #define HUE_SAT_RANGE_REG05     0x22
    #define SAT_SAT_RANGE_REG05     0x23

    #define CHROMA_GAIN_REG06       0x24
    #define HUE_HUE_RANGE_REG06     0x25
    #define HUE_RANGE_INV_REG06     0x26
    #define HUE_LUM_RANGE_REG06     0x27
    #define HUE_SAT_RANGE_REG06     0x28
    #define SAT_SAT_RANGE_REG06     0x29

    #define CHROMA_GAIN_REG07       0x2a
    #define HUE_HUE_RANGE_REG07     0x2b
    #define HUE_RANGE_INV_REG07     0x2c
    #define HUE_LUM_RANGE_REG07     0x2d
    #define HUE_SAT_RANGE_REG07     0x2e
    #define SAT_SAT_RANGE_REG07     0x2f

//  REG_CHROMA_CONTROL
//  Bit 31      reg_chroma_en               enable color manage function
//                                          1'b1: enable    1'b0: bypass
//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
//  Bit 5       uv_adj_en                   final uv_adjust enable
//                                          1'b1: enable    1'b0: bypass
//  Bit 2       hue_en                      rgb to hue enable
//                                          1'b1: enable(default)   1'b0: bypass
//  Bit 1:0     csc_sel                     define input YUV with different color type
//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024
    #define REG_DEMO_CENTER_BAR     0x31   // default 32h'0
    #define REG_DEMO_HLIGHT_MODE    0x32   // default 32h'0
    #define REG_DEMO_OWR_DATA       0x33   // default 32h'0


////===========================================////
//// CM2 ADDR
////===========================================////

    #define SAT_BYYB_NODE_REG0          0x200   // default 32'h0
//Bit 31:24, sat_byyb_node3    the 4th node
//Bit 23:16, sat_byyb_node2    the 3th node
//Bit 15: 8, sat_byyb_node1    signed, the 2th node about saturation
//Bit  7: 0, sat_byyb_node0    signed, the 1th node about saturation
//gain offset along y coordinate,the gain normalized to 128 as "1"
    
	#define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
//Bit 31:24, sat_byyb_node7     the 8th node
//Bit 23:16, sat_byyb_node6     the 7th node
//Bit 15: 8, sat_byyb_node5     signed, the 6th node about saturation
//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
//gain offset along y coordinate,the gain normalized to 128 as "1"

    #define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
//Bit 31: 8, reserved
//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation


    #define SAT_SRC_NODE_REG            0x203   // default 32'h0
//Bit 31:28, reserved 
//Bit 27:16, sat_src_node1  
//Bit 15:12, reserved 
//Bit 11: 0, sat_src_node0     usigned, threshold of input saturation for  first and second piece

    #define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
//Bit 31: 9, reserved
//Bit  8: 6, hue_lsft_mode        hue offset adjustments scale 
//Bit  5: 4, luma_lsft_mode       luma offset adjustments scale for reg_cm2_adj_luma_via_hue
//Bit  3: 2, sat_byy_rsft_mode    saturation gain adjustments scale for reg_cm2_adj_sat_via_y
//Bit  1: 0, sat_byhs_rsft_mode   saturation gain adjustments scale for reg_cm2_adj_sat_via_hs[:][:] 0:no scale up/down 1:dnscale by 2(-128,127)/2

    #define FRM_SIZE_REG                0x205   // default 32'h0
//Bit 31:29, reserved 
//Bit 28:16, reg_frm_height       the frame height size 
//Bit 15:13, reserved 
//Bit 12: 0, reg_frm_width        the frame width size 

    #define FITLER_CFG_REG              0x206   // default 32'h0
//Bit 31: 5, reserved 
//Bit  4: 4, inteleav_mod         horizontal interleave filter(zero-padding) for 3D considerations 0:using non-zero padding lpf 1:using zero-padding lpf
//Bit  3: 2, lpf_slt_uv           apply cm on lp portion or original video pixels options
//Bit  1: 0, lpf_slt_y            apply cm on lp portion or original video pixels options

    #define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
//Bit 31:28, reserved 
//Bit 27:16, cm2_global_sat     global saturation gain for general color adjustments(0~4095 <=> 0~8),512 normalized to "1"
//Bit 15:12, reserved 
//Bit 11: 0, cm2_global_hue     global hue offsets for general color adjustments(0~4095 <=> 0~360 degree) 

    #define CM_ENH_CTL_REG              0x208   // default 32'h0
//Bit  31:7, reserved
//Bit     6, hue_adj_en        cm2 hue adjustments
//Bit     5, sat_adj_en        cm2 saturation adjustments
//Bit     4, luma_adj_en       enable siganl for cm2 luma adjustments 
//Bit     3, reserved
//Bit     2, cm2_filt_en       apply cm on lp portion enable
//Bit     1, cm2_en            cm2 enable siganl
//Bit     0, cm1_en

    #define ROI_X_SCOPE_REG             0x209   // default 32'h0
//Bit 31:29, reserved 
//Bit 28:16, roi_x_end      ending col index of the region of interest
//Bit 15:13, reserved 
//Bit 12: 0, roi_x_beg      start col index of the region of interest
  
   #define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
//Bit 31:29, reserved 
//Bit 28:16, roi_y_end      ending row index of the region of interest
//Bit 15:13, reserved 
//Bit 12: 0, roi_y_beg      start row index of the region of interest

    #define POI_XY_DIR_REG              0x20b   // default 32'h0
//Bit 31:29, reserved 
//Bit 28:16, poi_y_dir      ending row index of the region of interest
//Bit 15:13, reserved 
//Bit 12: 0, poi_x_dir      start row index of the region of interest

    #define COI_Y_SCOPE_REG             0x20c   // default 32'h0
//Bit 31:16, reserved 
//Bit 15: 8, coi_y_end       
//Bit  7: 0, coi_y_beg       

    #define COI_H_SCOPE_REG             0x20d   // default 32'h0
//Bit 31:28, reserved 
//Bit 27:16, coi_h_end 
//Bit 15:12, reserved 
//Bit 11: 0, coi_h_beg        lower bound of hue value for color of interest ,12 bits precision 

    #define COI_S_SCOPE_REG             0x20e   // default 32'h0
//Bit 31:28, reserved 
//Bit 27:16, coi_s_end        
//Bit 15:12, reserved 
//Bit 11: 0, coi_s_beg        lower bound of sat value for color of interest ,12 bits precision 
    #define IFO_MODE_REG                0x20f   // default 32'h0
//Bit 31:8, reserved 
//Bit  7:6, ifo_mode3 
//Bit  5:4, ifo_mode2 
//Bit  3:2, ifo_mode1 
//Bit  1:0, ifo_mode0 
    #define POI_RPL_MODE_REG            0x210   // default 32'h0
//Bit 31:4, reserved 
//Bit  3:0, poi_rpl_mode          enhance mode control of pixels inside and outside region of interest bit[3:2]control roi 
    #define DEMO_OWR_YHS_REG            0x211   // default 32'h0
//Bit 31: 0, demo_owr_yhs
 
    #define DEMO_POI_Y_REG              0x212   // default 32'h0
//Bit 31: 8, reserved 
//Bit  7: 0, luma_data_poi_r       only get locked higher 8bits
    #define DEMO_POI_H_REG              0x213   // default 32'h0
//Bit 31: 12, reserved 
//Bit 11: 0, hue_data_poi_r        only get locked higher 12bits
    #define DEMO_POI_S_REG              0x214   // default 32'h0
//Bit 31: 12, reserved 
//Bit 11: 0, sat_data_poi_r         only get locked higher 12bits
    //#define LUMA_BYH_LIMT_REG           0x215   // default 32'h0
    #define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
//Bit 31:24, reserved 
//Bit 23:16, luma_lmt_satslp         slope to do the luma adjustment degrade
//Bit 15:12, reserved 
//Bit 11:0, luma_lmt_satth           threshold to saturation
    #define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
//Bit 31:24, reserved 
//Bit 23:16, sat_lmt_satslp        slope to do the adjustment degrade
//Bit 15:12, reserved 
//Bit 11:0, sat_lmt_satth          threshold to saturation
    #define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
//Bit 31: 24, reserved 
//Bit 23: 16, hue_lmt_satslp        slope to do the adjustment degrade
//Bit 15: 12, reserved 
//Bit 11: 0,  hue_lmt_satth          threshold to saturation
    #define UVHS_OFST_REG               0x218   // default 32'h0
//Bit 31: 24, hs2uv_v_ofst 
//Bit 23: 16, hs2uv_u_ofst 
//Bit 15: 8,  uv2hs_v_ofst 
//Bit  7: 0,  uv2hs_u_ofst 
    #define HUE_CFG_PARA_REG            0x219   // default 32'h0
//Bit 31: 17, reserved 
//Bit     16, hue_protect_en 
//Bit 15: 13, cm2_hue_byhs_mode   
//Bit     12, cm2_hue_div_mode    
//Bit 11: 0, cm2_before_hue_ofst 
    #define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
//Bit 31: 22, reserved 
//Bit 21: 20, demo_split_mode  
//Bit 19: 16, demo_split_width        slope to do the adjustment degrade
//Bit 15: 13, reserved 
//Bit 12: 0,  demo_split_post           threshold to saturation
    #define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0    
//Bit 31: 0,  demo_splt_yhs             threshold to saturation
    
    #define XVYCC_YSCP_REG              0x21c   // default 32'h0    
//Bit 31: 28, reserved 
//Bit 27: 16, xvycc_y_max 
//Bit 15: 12, reserved 
//Bit 11: 0, xvycc_y_min 
    #define XVYCC_USCP_REG              0x21d   // default 32'h0    
//Bit 31: 28, reserved 
//Bit 27: 16, xvycc_u_max 
//Bit 15: 12, reserved 
//Bit 11: 0, xvycc_u_min 
    #define XVYCC_VSCP_REG              0x21e   // default 32'h0    
//Bit 31: 28, reserved 
//Bit 27: 16, xvycc_v_max 
//Bit 15: 12, reserved 
//Bit 11: 0, xvycc_v_min 

////========= NODE 0 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
//Bit 31: 24, reg_cm2_adj_sat_via_hs_2  
//Bit 23: 16, reg_cm2_adj_sat_via_hs_1  
//Bit 15: 8,  reg_cm2_adj_sat_via_hs_0  
//Bit  7: 0, reg_cm2_adj_luma_via_h  
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 1 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 2 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 3 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 4 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 5 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 6 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 7 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 8 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 9 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 10 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 11 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 12 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 13 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx


/* Constraints 
0)
  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
  the 8 regions for hue adjustment are defined by: (example are for region 0)
    a) hue:
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_hue_sat_low_00 
        end:   reg_hue_sat_high_00  

  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
  the 8 regions for sat adjustment are defined by: (example are for region 0)
    a) hue: same as that for hue adjustment.
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_sat_sat_low_00
        end:   reg_sat_sat_high_00  

1)
  reg_hue_hue_shift_range_00[7:0]:
  reg_hue_hue_shift_range_01[7:0]:
  reg_hue_hue_shift_range_02[7:0]:
  reg_hue_hue_shift_range_03[7:0]:
  reg_hue_hue_shift_range_04[7:0]:
  reg_hue_hue_shift_range_05[7:0]:
  reg_hue_hue_shift_range_06[7:0]:
  reg_hue_hue_shift_range_07[7:0]:
  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx

2)
  all regions of 0-7 should meet below requirement. below is just an example for region 7.
  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >= 
        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)

  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)

  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)

  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)

3)
  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
  only region 0 and 1 can exceed 360 degrees. ie:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
  but below should be met:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1

  others could not exceed 360 degrees. ie:
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.

4)
  reg_hue_gain_00[7:0] <= 0x80.
  reg_hue_gain_01[7:0] <= 0x80.
  reg_hue_gain_02[7:0] <= 0x80.
  reg_hue_gain_03[7:0] <= 0x80.
  reg_hue_gain_04[7:0] <= 0x80.
  reg_hue_gain_05[7:0] <= 0x80.
  reg_hue_gain_06[7:0] <= 0x80.
  reg_hue_gain_07[7:0] <= 0x80.

5)
  below registers can only have two setting: 00 and 01.
    reg_hue_central_en_00[1:0]  .. _07[1:0]
    reg_sat_central_en_00[1:0]  .. _07[1:0]

6)
  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
   for example: below is for region 0:
   reg_hue_lum_low_slope_00[3:0]  <= 7
   reg_hue_lum_high_slope_00[3:0] <= 7
   reg_hue_sat_low_slope_00[3:0]  <= 7
   reg_hue_sat_high_slope_00[3:0] <= 7
   reg_sat_lum_low_slope_00[3:0]  <= 7
   reg_sat_lum_high_slope_00[3:0] <= 7
   reg_sat_sat_low_slope_00[3:0]  <= 7
   reg_sat_sat_high_slope_00[3:0] <= 7
*/

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  chroma_reg.h
//
//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
//because the register itself canot be set again without clk
//Bit 31:0
#define VPP_GCLK_CTRL0                             0x1d72
//(front_lti), (front_cti), Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
//Bit 13:0
#define VPP_GCLK_CTRL1                             0x1d73
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
#define VPP_SC_GCLK_CTRL                           0x1d74
//Bit 17:9 VD1 alpha for preblend
//Bit 8:0 VD1 alpha for postblend
#define VPP_MISC1                                  0x1d76
//Bit 31:0 super scalar clock control 
#define VPP_SRSCL_GCLK_CTRL                        0x1d77
//Bit 31:0 OSD super scalar clock control 
#define VPP_OSDSR_GCLK_CTRL                        0x1d78
//Bit 31:0 vvycc clock control 
#define VPP_XVYCC_GCLK_CTRL                        0x1d79
//Bit 31:24     blackext_start
//Bit 23:16     blackext_slope1
//Bit 15:8      blackext_midpt
//Bit 7:0       blackext_slope2
#define VPP_BLACKEXT_CTRL                          0x1d80
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define VPP_DNLP_CTRL_00                           0x1d81
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define VPP_DNLP_CTRL_01                           0x1d82
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define VPP_DNLP_CTRL_02                           0x1d83
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define VPP_DNLP_CTRL_03                           0x1d84
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define VPP_DNLP_CTRL_04                           0x1d85
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define VPP_DNLP_CTRL_05                           0x1d86
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define VPP_DNLP_CTRL_06                           0x1d87
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define VPP_DNLP_CTRL_07                           0x1d88
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define VPP_DNLP_CTRL_08                           0x1d89
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define VPP_DNLP_CTRL_09                           0x1d8a
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define VPP_DNLP_CTRL_10                           0x1d8b
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define VPP_DNLP_CTRL_11                           0x1d8c
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define VPP_DNLP_CTRL_12                           0x1d8d
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define VPP_DNLP_CTRL_13                           0x1d8e
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define VPP_DNLP_CTRL_14                           0x1d8f
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define VPP_DNLP_CTRL_15                           0x1d90
//Bit 28        vlti_step
//Bit 27        vlti_step2
//Bit 26:25     hlti_step
//Bit 24:20     peaking_gain_h1
//Bit 19:15     peaking_gain_h2
//Bit 14:10     peaking_gain_h3
//Bit 9:5       peaking_gain_h4
//Bit 4:0       peaking_gain_h5
#define VPP_PEAKING_HGAIN                          0x1d91
//Bit 31        hsvsharp_buf_en
//Bit 30        hsvsharp_buf_c5line_mode
//Bit 29:25     peaking_gain_v1
//Bit 24:20     peaking_gain_v2
//Bit 19:15     peaking_gain_v3
//Bit 14:10     peaking_gain_v4
//Bit 9:5       peaking_gain_v5
//Bit 4:0       peaking_gain_v6
#define VPP_PEAKING_VGAIN                          0x1d92
//Bit 31:26     hpeaking_slope1
//Bit 25:20     hpeaking_slope2
//Bit 19:12     hpeaking_slope_th1
//Bit 11:6      vpeaking_slope1
//Bit 5:0       vpeaking_slope2
#define VPP_PEAKING_NLP_1                          0x1d93
//Bit 31:24     hpeaking_slope_th2
//Bit 23:16     hpeaking_nlp_coring_th
//Bit 15:8      hpeaking_nlp_pgain
//Bit 7:0       hpeaking_nlp_ngain
#define VPP_PEAKING_NLP_2                          0x1d94
//Bit 31:24     vpeaking_slope_th1
//Bit 23:18     speaking_slope1
//Bit 17:12     speaking_slope2
//Bit 11:4      speaking_slope_th1
//Bit 3:0       peaking_coring_gain
#define VPP_PEAKING_NLP_3                          0x1d95
//Bit 31:24     vpeaking_slope_th2
//Bit 23:16     vpeaking_nlp_coring_th
//Bit 15:8      vpeaking_nlp_pgain
//Bit 7:0       vpeaking_nlp_ngain
#define VPP_PEAKING_NLP_4                          0x1d96
//Bit 31:24     speaking_slope_th2
//Bit 23:16     speaking_nlp_coring_th
//Bit 15:8      speaking_nlp_pgain
//Bit 7:0       speaking_nlp_ngain
#define VPP_PEAKING_NLP_5                          0x1d97
//Bit 31:24     peaking_coring_th_l
//Bit 23:16     peaking_coring_th_h
//Bit 15:12     vlimit_high_coef
//Bit 11:8      vlimit_low_coef
//Bit 7:4       hlimit_high_coef
//Bit 3:0       hlimit_low_coef
#define VPP_SHARP_LIMIT                            0x1d98
//Bit 31:24     vlti_neg_gain
//Bit 23:16     vlti_pos_gain
//Bit 15:8      vlti_threshold
//Bit 7:0       vlti_blend_factor
#define VPP_VLTI_CTRL                              0x1d99
//Bit 31:24     hlti_neg_gain
//Bit 23:16     hlti_pos_gain
//Bit 15:8      hlti_threshold
//Bit 7:0       hlti_blend_factor
#define VPP_HLTI_CTRL                              0x1d9a
//Bit 30        cti_c444to422_en
//Bit 29:28     cti_vfilter_type
//Bit 27        cti_c422to444_en
//Bit 26:24     cti_step2
//Bit 23:21     cti_step
//Bit 20:16     cti_blend_factor
//Bit 15        cti_median_mode
//Bit 14:8      cti_threshold
//Bit 7:0       cti_gain
#define VPP_CTI_CTRL                               0x1d9b
//Bit 29        blue_stretch_cb_inc
//Bit 28        blue_stretch_cr_inc
//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
//Bit 23:16     blue_stretch_gain
//Bit 15:8      blue_stretch_gain_cb4cr
//Bit 7:0       blue_stretch_luma_high
#define VPP_BLUE_STRETCH_1                         0x1d9c
//Bit 31:27     blue_stretch_error_crp
//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
//Bit 15:11     blue_stretch_error_crn
//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
#define VPP_BLUE_STRETCH_2                         0x1d9d
//Bit 31:27     blue_stretch_error_cbp
//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
//Bit 15:11     blue_stretch_error_cbn
//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
#define VPP_BLUE_STRETCH_3                         0x1d9e
//Bit 25:16 bypass_ccoring_ythd
//Bit 15:8, Chroma coring threshold
//Bit 3:0, Chroma coring slope
#define VPP_CCORING_CTRL                           0x1da0
//Bit 20 demo chroma coring enable
//Bit 19 demo black enxtension enable
//Bit 18 demo dynamic nonlinear luma processing enable
//Bit 17 demo hsvsharp enable
//Bit 16 demo bluestretch enable
//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
//Bit 4 chroma coring enable
//Bit 3 black enxtension enable
//Bit 2 dynamic nonlinear luma processing enable
//Bit 1 hsvsharp enable
//Bit 0 bluestretch enable
#define VPP_VE_ENABLE_CTRL                         0x1da1
//Bit 12:0, demo left or top screen width
#define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH          0x1da2
#define VPP_VE_DEMO_CENTER_BAR                     0x1da3
//28:16  ve_line_length
//12:0   ve_pic_height
#define VPP_VE_H_V_SIZE                            0x1da4
//28:16  psr_line_length
//12:0   psr_pic_height
#define VPP_PSR_H_V_SIZE                           0x1da5
//28:16  vppin_line_length
//12:0   vppin_pic_height
#define VPP_IN_H_V_SIZE                            0x1da6
//Bit 10   reset bit, high active
//Bit 9    0: measuring rising edge, 1: measuring falling edge
//Bit 8    if true, accumulate the counter number, otherwise not
//Bit 7:0  vsync_span, define how many vsync span need to measure 
#define VPP_VDO_MEAS_CTRL                          0x1da8
//Read only
//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
//15:0, high bit portion of counter
#define VPP_VDO_MEAS_VS_COUNT_HI                   0x1da9
//Read only
//31:0, low bit portion of counter
#define VPP_VDO_MEAS_VS_COUNT_LO                   0x1daa
//bit 11:9 vd2_sel,  001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection             
//bit 8:6 vd1_l_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//bit 5:3 vd1_r_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//note: the source vd1_l_sel selected cannot be used as the source of vd1_r_sel or vd2_sel
// vd1_r_sel is useful only vd1_interleave_mode is not 00. And the source vd1_r_sel used can not used for the vd2_sel any more.  
//bit 2:0 vd1_interleave_mode, 000: no interleave, 001: pixel interleaving, 010: line interleaving, 011: 2 pixel interleaving, 
// 100: 2 line interleaving
#define VPP_INPUT_CTRL                             0x1dab
//bit 25:24 cti_bpf_sel
//bit 20:16 cti_blend_factor_gama
//bit 12:8 cti_blend_factor_beta
//bit 4:0 cti_blend_factor_alpha
#define VPP_CTI_CTRL2                              0x1dac
#define VPP_PEAKING_SAT_THD1                       0x1dad
#define VPP_PEAKING_SAT_THD2                       0x1dae
#define VPP_PEAKING_SAT_THD3                       0x1daf
#define VPP_PEAKING_SAT_THD4                       0x1db0
#define VPP_PEAKING_SAT_THD5                       0x1db1
#define VPP_PEAKING_SAT_THD6                       0x1db2
#define VPP_PEAKING_SAT_THD7                       0x1db3
#define VPP_PEAKING_SAT_THD8                       0x1db4
#define VPP_PEAKING_SAT_THD9                       0x1db5
#define VPP_PEAKING_GAIN_ADD1                      0x1db6
#define VPP_PEAKING_GAIN_ADD2                      0x1db7
//bit 23:16 peaking_dnlp_gain, u5.3, DNLP effect
//bit 15:8  peaking_factor
//bit 5     peaking_dnlp_demo_en
//bit 4     peaking_dnlp_en
//bit 3:0   peaking_filter_sel
#define VPP_PEAKING_DNLP                           0x1db8
//bit 24    sharp_demo_win_en
//bit 23:12 sharp_demo_win_vend
//bit 11:0  sharp_demo_win_vstart
#define VPP_SHARP_DEMO_WIN_CTRL1                   0x1db9
//bit 23:12 sharp_demo_win_hend
//bit 11:0  sharp_demo_win_hstart
#define VPP_SHARP_DEMO_WIN_CTRL2                   0x1dba
//Bit 31:24     front_hlti_neg_gain
//Bit 23:16     front_hlti_pos_gain
//Bit 15:8      front_hlti_threshold
//Bit 7:0       front_hlti_blend_factor
#define VPP_FRONT_HLTI_CTRL                        0x1dbb
//Bit 31        front_enable, enable the front LTI&CTI before scaler
//Bit 26:24     front_cti_step2
//Bit 23:21     front_cti_step
//Bit 20:16     front_cti_blend_factor
//Bit 15        front_cti_median_mode
//Bit 14:8      front_cti_threshold
//Bit 7:0       front_cti_gain
#define VPP_FRONT_CTI_CTRL                         0x1dbc
//bit 29:28 front_hlti_step
//bit 25:24 front_cti_bpf_sel
//bit 20:16 front_cti_blend_factor_gama
//bit 12:8  front_cti_blend_factor_beta
//bit 4:0   front_cti_blend_factor_alpha
#define VPP_FRONT_CTI_CTRL2                        0x1dbd
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define VPP_OSD_VSC_PHASE_STEP                     0x1dc0
//Bit 31:16, botttom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define VPP_OSD_VSC_INI_PHASE                      0x1dc1
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length 
#define VPP_OSD_VSC_CTRL0                          0x1dc2
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define VPP_OSD_HSC_PHASE_STEP                     0x1dc3
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define VPP_OSD_HSC_INI_PHASE                      0x1dc4
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define VPP_OSD_HSC_CTRL0                          0x1dc5
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define VPP_OSD_HSC_INI_PAT_CTRL                   0x1dc6
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define VPP_OSD_SC_DUMMY_DATA                      0x1dc7
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable 
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define VPP_OSD_SC_CTRL0                           0x1dc8
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define VPP_OSD_SCI_WH_M1                          0x1dc9
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define VPP_OSD_SCO_H_START_END                    0x1dca
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define VPP_OSD_SCO_V_START_END                    0x1dcb
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define VPP_OSD_SCALE_COEF_IDX                     0x1dcc
//coefficients for vertical filter and horizontal filter
#define VPP_OSD_SCALE_COEF                         0x1dcd
//Bit 12:0 line number use to generate interrupt when line == this number
#define VPP_INT_LINE_NUM                           0x1dce
#define VPP_XVYCC_MISC                             0x1dcf
// new add lti/cti in 120924
//Bit  3: 0        //default== 0  reg_hlti_dn_flt_coe[0]
//Bit  7: 4        //default== 0  reg_hlti_dn_flt_coe[1]
//Bit 11: 8        //default== 0  reg_hlti_dn_flt_coe[2]
//Bit 15:12        //default== 2  reg_hlti_dn_flt_coe[3]
//Bit 19:16        //default== 4  reg_hlti_dn_flt_coe[4]
//Bit 22:20        //default== 3  reg_hlti_dn_flt_nrm  u3: 3~7
#define VPP_HLTI_DN_FLT                            0x1dd0
//Bit  7: 0        //default== 8  reg_hlti_bst_gain  u8, norm 16 as "1"
//Bit 15: 8        //default== 20 reg_hlti_bst_core  u8, norm 32 as "1"
//Bit 23:16        //default== 32 reg_hlti_oob_gain  u8, norm 32 as "1"
//Bit 28:24        //default== 0  reg_hlti_oob_core  u5                                  
#define VPP_HLTI_GAIN                              0x1dd1
//Bit  7: 0        //default== 2  reg_hlti_clp_ofst  u8, 
//Bit     8        //default== 0  reg_hlti_clp_mode  u1, 
//Bit 11: 9        //default== 1  reg_hlti_clp_wind  u3, 
//Bit 14:12        //default== 1  reg_hlti_bst_fltr  u3, 
//Bit    15        //default== 1  reg_hlti_enable    u1, 
#define VPP_HLTI_PARA                              0x1dd2
//Bit  3: 0        //default== 0  reg_hcti_dn_flt_coe[0]
//Bit  7: 4        //default== 0  reg_hcti_dn_flt_coe[1]
//Bit 11: 8        //default== 1  reg_hcti_dn_flt_coe[2]
//Bit 15:12        //default== 2  reg_hcti_dn_flt_coe[3]
//Bit 19:16        //default== 2  reg_hcti_dn_flt_coe[4]
//Bit 22:20        //default== 3  reg_hcti_dn_flt_nrm   u3: 3~7
#define VPP_HCTI_DN_FLT                            0x1dd3
//Bit 7: 0        //default== 48 reg_hcti_bst_gain  u8, norm 16 as "1"
//Bit15: 8        //default== 17 reg_hcti_bst_core  u8, norm 32 as "1"
//Bit23:16        //default== 16 reg_hcti_oob_gain  u8, norm 32 as "1"
//Bit28:24        //default==  0 reg_hcti_oob_core  u5
#define VPP_HCTI_GAIN                              0x1dd4
//Bit  7: 0        //default==  0 reg_hcti_clp_ofst  u8, 
//Bit     8        //default==  1 reg_hcti_clp_mode  u1, 
//Bit 11: 9        //default==  3 reg_hcti_clp_wind  u3, 
//Bit 14:12        //default==  6 reg_hcti_bst_fltr  u3, 
//Bit    15        //default==  1 reg_hcti_enable    u1, 
#define VPP_HCTI_PARA                              0x1dd5
//Bit  7: 0        //default== 48 reg_vcti_bst_gain  u8, normalize 16 as "1"
//Bit 15: 8        //default== 10 reg_vcti_bst_core  u8
//Bit 19:16        //default== 10 reg_vcti_clp_ofst  u4
//Bit    20        //default==  1 reg_vcti_clp_wind  u1, 0: wind 3, 1: wind5
#define VPP_VCTI_PARA                              0x1dd6
//`define VPP_MATRIX_PROBE_COLOR1 8'hd7  //defined before
//Bit 15          //default== 0, urgent_ctrl_en
//Bit 14          //default== 0, urgent_wr, if true for write buffer
//Bit 13          //default== 0, out_inv_en
//Bit 12          //default == 0, urgent_ini_value
//Bit 11:6        //default == 0, up_th  up threshold
//Bit 5:0         //default == 0, dn_th  dn threshold
#define VPP_OFIFO_URG_CTRL                         0x1dd8
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_regs.h
//
//`define VIU2_VCBUS_BASE                8'h1e     
//
// Reading file:  v2regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Interface 2 Registers    0xe00 - 0xeff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VIU2_VCBUS_BASE = 0x1e
// -----------------------------------------------
#define VIU2_ADDR_START                            0x1e00
#define VIU2_ADDR_END                              0x1eff
//------------------------------------------------------------------------------
// VIU2 top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  7 RW, vpp_reset
#define VIU2_SW_RESET                              0x1e01
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define VIU2_OSD1_CTRL_STAT                        0x1e10
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define VIU2_OSD1_CTRL_STAT2                       0x1e2d
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define VIU2_OSD1_COLOR_ADDR                       0x1e11
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU2_OSD1_COLOR                            0x1e12
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU2_OSD1_TCOLOR_AG0                       0x1e17
#define VIU2_OSD1_TCOLOR_AG1                       0x1e18
#define VIU2_OSD1_TCOLOR_AG2                       0x1e19
#define VIU2_OSD1_TCOLOR_AG3                       0x1e1a
// Bit 31:30 Reserved
// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
// Bit 27:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define VIU2_OSD1_BLK0_CFG_W0                      0x1e1b
#define VIU2_OSD1_BLK1_CFG_W0                      0x1e1f
#define VIU2_OSD1_BLK2_CFG_W0                      0x1e23
#define VIU2_OSD1_BLK3_CFG_W0                      0x1e27
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define VIU2_OSD1_BLK0_CFG_W1                      0x1e1c
#define VIU2_OSD1_BLK1_CFG_W1                      0x1e20
#define VIU2_OSD1_BLK2_CFG_W1                      0x1e24
#define VIU2_OSD1_BLK3_CFG_W1                      0x1e28
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define VIU2_OSD1_BLK0_CFG_W2                      0x1e1d
#define VIU2_OSD1_BLK1_CFG_W2                      0x1e21
#define VIU2_OSD1_BLK2_CFG_W2                      0x1e25
#define VIU2_OSD1_BLK3_CFG_W2                      0x1e29
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define VIU2_OSD1_BLK0_CFG_W3                      0x1e1e
#define VIU2_OSD1_BLK1_CFG_W3                      0x1e22
#define VIU2_OSD1_BLK2_CFG_W3                      0x1e26
#define VIU2_OSD1_BLK3_CFG_W3                      0x1e2a
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define VIU2_OSD1_BLK0_CFG_W4                      0x1e13
#define VIU2_OSD1_BLK1_CFG_W4                      0x1e14
#define VIU2_OSD1_BLK2_CFG_W4                      0x1e15
#define VIU2_OSD1_BLK3_CFG_W4                      0x1e16
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define VIU2_OSD1_FIFO_CTRL_STAT                   0x1e2b
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define VIU2_OSD1_TEST_RDDATA                      0x1e2c
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define VIU2_OSD1_PROT_CTRL                        0x1e2e
//------------------------------------------------------------------------------
// OSD2 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define VIU2_OSD2_CTRL_STAT                        0x1e30
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define VIU2_OSD2_CTRL_STAT2                       0x1e4d
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define VIU2_OSD2_COLOR_ADDR                       0x1e31
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU2_OSD2_COLOR                            0x1e32
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define VIU2_OSD2_HL1_H_START_END                  0x1e33
#define VIU2_OSD2_HL1_V_START_END                  0x1e34
#define VIU2_OSD2_HL2_H_START_END                  0x1e35
#define VIU2_OSD2_HL2_V_START_END                  0x1e36
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU2_OSD2_TCOLOR_AG0                       0x1e37
#define VIU2_OSD2_TCOLOR_AG1                       0x1e38
#define VIU2_OSD2_TCOLOR_AG2                       0x1e39
#define VIU2_OSD2_TCOLOR_AG3                       0x1e3a
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define VIU2_OSD2_BLK0_CFG_W0                      0x1e3b
#define VIU2_OSD2_BLK1_CFG_W0                      0x1e3f
#define VIU2_OSD2_BLK2_CFG_W0                      0x1e43
#define VIU2_OSD2_BLK3_CFG_W0                      0x1e47
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define VIU2_OSD2_BLK0_CFG_W1                      0x1e3c
#define VIU2_OSD2_BLK1_CFG_W1                      0x1e40
#define VIU2_OSD2_BLK2_CFG_W1                      0x1e44
#define VIU2_OSD2_BLK3_CFG_W1                      0x1e48
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define VIU2_OSD2_BLK0_CFG_W2                      0x1e3d
#define VIU2_OSD2_BLK1_CFG_W2                      0x1e41
#define VIU2_OSD2_BLK2_CFG_W2                      0x1e45
#define VIU2_OSD2_BLK3_CFG_W2                      0x1e49
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define VIU2_OSD2_BLK0_CFG_W3                      0x1e3e
#define VIU2_OSD2_BLK1_CFG_W3                      0x1e42
#define VIU2_OSD2_BLK2_CFG_W3                      0x1e46
#define VIU2_OSD2_BLK3_CFG_W3                      0x1e4a
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define VIU2_OSD2_BLK0_CFG_W4                      0x1e64
#define VIU2_OSD2_BLK1_CFG_W4                      0x1e65
#define VIU2_OSD2_BLK2_CFG_W4                      0x1e66
#define VIU2_OSD2_BLK3_CFG_W4                      0x1e67
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define VIU2_OSD2_FIFO_CTRL_STAT                   0x1e4b
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define VIU2_OSD2_TEST_RDDATA                      0x1e4c
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define VIU2_OSD2_PROT_CTRL                        0x1e4e
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
#define VIU2_VD1_IF0_GEN_REG                       0x1e50
#define VIU2_VD1_IF0_CANVAS0                       0x1e51
#define VIU2_VD1_IF0_CANVAS1                       0x1e52
#define VIU2_VD1_IF0_LUMA_X0                       0x1e53
#define VIU2_VD1_IF0_LUMA_Y0                       0x1e54
#define VIU2_VD1_IF0_CHROMA_X0                     0x1e55
#define VIU2_VD1_IF0_CHROMA_Y0                     0x1e56
#define VIU2_VD1_IF0_LUMA_X1                       0x1e57
#define VIU2_VD1_IF0_LUMA_Y1                       0x1e58
#define VIU2_VD1_IF0_CHROMA_X1                     0x1e59
#define VIU2_VD1_IF0_CHROMA_Y1                     0x1e5a
#define VIU2_VD1_IF0_RPT_LOOP                      0x1e5b
#define VIU2_VD1_IF0_LUMA0_RPT_PAT                 0x1e5c
#define VIU2_VD1_IF0_CHROMA0_RPT_PAT               0x1e5d
#define VIU2_VD1_IF0_LUMA1_RPT_PAT                 0x1e5e
#define VIU2_VD1_IF0_CHROMA1_RPT_PAT               0x1e5f
#define VIU2_VD1_IF0_LUMA_PSEL                     0x1e60
#define VIU2_VD1_IF0_CHROMA_PSEL                   0x1e61
#define VIU2_VD1_IF0_DUMMY_PIXEL                   0x1e62
#define VIU2_VD1_IF0_LUMA_FIFO_SIZE                0x1e63
#define VIU2_VD1_IF0_RANGE_MAP_Y                   0x1e6a
#define VIU2_VD1_IF0_RANGE_MAP_CB                  0x1e6b
#define VIU2_VD1_IF0_RANGE_MAP_CR                  0x1e6c
#define VIU2_VD1_IF0_GEN_REG2                      0x1e6d
#define VIU2_VD1_IF0_PROT_CNTL                     0x1e6e
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define VIU2_VD1_FMT_CTRL                          0x1e68
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define VIU2_VD1_FMT_W                             0x1e69
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  v2regs.h
//
//======================================================================
//   vpu  register.
//======================================================================
// -----------------------------------------------
// CBUS_BASE:  VPU_VCBUS_BASE = 0x27
// -----------------------------------------------
#define VPU_OSD1_MMC_CTRL                          0x2701
#define VPU_OSD2_MMC_CTRL                          0x2702
#define VPU_VD1_MMC_CTRL                           0x2703
#define VPU_VD2_MMC_CTRL                           0x2704
#define VPU_DI_IF1_MMC_CTRL                        0x2705
#define VPU_DI_MEM_MMC_CTRL                        0x2706
#define VPU_DI_INP_MMC_CTRL                        0x2707
#define VPU_DI_MTNRD_MMC_CTRL                      0x2708
#define VPU_DI_CHAN2_MMC_CTRL                      0x2709
#define VPU_DI_MTNWR_MMC_CTRL                      0x270a
#define VPU_DI_NRWR_MMC_CTRL                       0x270b
#define VPU_DI_DIWR_MMC_CTRL                       0x270c
#define VPU_VDIN0_MMC_CTRL                         0x270d
#define VPU_VDIN1_MMC_CTRL                         0x270e
#define VPU_BT656_MMC_CTRL                         0x270f
#define VPU_TVD3D_MMC_CTRL                         0x2710
#define VPU_TVDVBI_MMC_CTRL                        0x2711
//Read only
//`define     VPU_TVDVBI_VSLATCH_ADDR   8'h12
//Read only
//`define     VPU_TVDVBI_WRRSP_ADDR 8'h13
#define VPU_VDIN_PRE_ARB_CTRL                      0x2714
#define VPU_VDISP_PRE_ARB_CTRL                     0x2715
#define VPU_VPUARB2_PRE_ARB_CTRL                   0x2716
#define VPU_OSD3_MMC_CTRL                          0x2717
#define VPU_OSD4_MMC_CTRL                          0x2718
#define VPU_VD3_MMC_CTRL                           0x2719
// [31:11] Reserved.
// [10: 8] cntl_viu_vdin_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
//          3'b000=Disable VIU to VDIN path;
//          3'b001=Enable VIU of ENC_I domain to VDIN;
//          3'b010=Enable VIU of ENC_P domain to VDIN;
//          3'b100=Enable VIU of ENC_T domain to VDIN;
// [ 6: 4] cntl_viu_vdin_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
//          3'b000=Disable VIU to VDIN clock;
//          3'b001=Select encI clock to VDIN;
//          3'b010=Select encP clock to VDIN;
//          3'b100=Select encT clock to VDIN;
// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
#define VPU_VIU_VENC_MUX_CTRL                      0x271a
// [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
// [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
// [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
//                          0=output CrYCb(BRG);
//                          1=output YCbCr(RGB);
//                          2=output YCrCb(RBG);
//                          3=output CbCrY(GBR);
//                          4=output CbYCr(GRB);
//                          5=output CrCbY(BGR);
//                          6,7=Rsrv.
// [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
// [    3] inv_vsync. 1=Invert Vsync polarity.
// [    2] inv_hsync. 1=Invert Hsync polarity.
// [ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
#define VPU_HDMI_SETTING                           0x271b
#define ENCI_INFO_READ                             0x271c
#define ENCP_INFO_READ                             0x271d
#define ENCT_INFO_READ                             0x271e
#define ENCL_INFO_READ                             0x271f
// Bit  0 RW, viu_rst_n
// Bit  1 RW, vdin_mmc_arb_rst_n
// Bit  2 RW, vdisp_mmc_arb_rst_n
// Bit  3 RW, vpuarb2_mmc_arb_rst_n
#define VPU_SW_RESET                               0x2720
//Bit 30     d2d3_depr_req_sel,  0:vdisp_pre_arb, 1: vpuarb2_pre_arb
//Bit 27:22  d2d3_depr_brst_num
//Bit 21:16  d2d3_depr_id
//Bit 14     d2d3_depw_req_sel, 0: vdin_pre_arb, 1: vdisp_pre_arb
//Bit 11:6   d2d3_depw_brst_num
//Bit 5:0    d2d3_depw_id
#define VPU_D2D3_MMC_CTRL                          0x2721
//Bit 30     mtn_contrd_req_pre,  0:disp1_arb, 1: vdin_pre_arb
//Bit 27:22  mtn_contrd_brst_num
//Bit 21:16  mtn_contrd_id
//Bit 14     mtn_contwr_req_pre, 0: vdisp1_arb, 1: vdin_pre_arb
//Bit 11:6   mtn_contwr_brst_num
//Bit 5:0    mtn_contwr_id
#define VPU_CONT_MMC_CTRL                          0x2722
// Bit  6 RW, gclk_mpeg_vpu_misc
// Bit  5 RW, gclk_mpeg_venc_l_top
// Bit  4 RW, gclk_mpeg_vencl_int
// Bit  3 RW, gclk_mpeg_vencp_int
// Bit  2 RW, gclk_mpeg_vi2_top
// Bit  1 RW, gclk_mpeg_vi_top
// Bit  0 RW, gclk_mpeg_venc_p_top
#define VPU_CLK_GATE                               0x2723
//Bit    12 RW, rdma_pre
//Bit 11: 6 RW, rdma_num
//Bit  5: 0 RW, rdma_id
#define VPU_RDMA_MMC_CTRL                          0x2724
#define VPU_MEM_PD_REG0                            0x2725
#define VPU_MEM_PD_REG1                            0x2726
// [   31] hdmi_data_ovr_en: 1=Enable overriding data input to HDMI TX with hdmi_data_ovr[29:0]. 0=No override. Default 0.
// [   30] Reserved.                                                                                            Default 0
// [29: 0] hdmi_data_ovr.                                                                                       Default 0.
#define VPU_HDMI_DATA_OVR                          0x2727
//Bit    15 RW, prot1_sel_osd4
//Bit    14 RW, prot1_sel_osd3
//Bit    13 RW, prot1_sel_osd2
//Bit    12 RW, prot1_sel_osd1
//Bit 11: 6 RW, prot1_brst_num
//Bit  5: 0 RW, prot1_id
#define VPU_PROT1_MMC_CTRL                         0x2728
//Bit    14 RW, prot2_sel_vd3
//Bit    13 RW, prot2_sel_vd2
//Bit    12 RW, prot2_sel_vd1
//Bit 11: 6 RW, prot2_brst_num
//Bit  5: 0 RW, prot2_id
#define VPU_PROT2_MMC_CTRL                         0x2729
//Bit    14 RW, prot3_sel_vd3
//Bit    13 RW, prot3_sel_vd2
//Bit    12 RW, prot3_sel_vd1
//Bit 11: 6 RW, prot3_brst_num
//Bit  5: 0 RW, prot3_id
#define VPU_PROT3_MMC_CTRL                         0x272a
//Bit 29:24 RW, s3_brst_num
//Bit 21:16 RW, s2_brst_num
//Bit 13: 8 RW, s1_brst_num
//Bit  5: 0 RW, s0_brst_num
#define VPU_ARB4_V1_MMC_CTRL                       0x272b
//Bit 29:24 RW, s3_brst_num
//Bit 21:16 RW, s2_brst_num
//Bit 13: 8 RW, s1_brst_num
//Bit  5: 0 RW, s0_brst_num
#define VPU_ARB4_V2_MMC_CTRL                       0x272c
//Bit 27:22 RW, mcvecwr_num
//Bit 21:16 RW, mcvecwr_id
//Bit 11:6  RW, mcvecrd_num
//Bit 5:0   RW, mcvecrd_id
#define VPU_MCVEC_MMC_CTRL                         0x272d
//Bit 27:22 RW, mcinfwr_num
//Bit 21:16 RW, mcinfwr_id
//Bit 11:6  RW, mcinfrd_num
//Bit 5:0   RW, mcinfrd_id
#define VPU_MCINF_MMC_CTRL                         0x272e
//Bit 31    reg_vpu_pwm_inv, 1: invert the pwm signal, active low
//Bit 30:29 reg_vpu_pwm_src_sel, 00: encl, enct, encp
//Bit 28:16 reg_vpu_pwm_v_end0 
//Bit 12:0  reg_vpu_pwm_v_start0 
#define VPU_VPU_PWM_V0                             0x2730
//Bit 28:16 reg_vpu_pwm_v_end1 
//Bit 12:0  reg_vpu_pwm_v_start1 
#define VPU_VPU_PWM_V1                             0x2731
//Bit 28:16 reg_vpu_pwm_v_end2 
//Bit 12:0  reg_vpu_pwm_v_start2 
#define VPU_VPU_PWM_V2                             0x2732
//Bit 28:16 reg_vpu_pwm_v_end3 
//Bit 12:0  reg_vpu_pwm_v_start3 
#define VPU_VPU_PWM_V3                             0x2733
//Bit 28:16 reg_vpu_pwm_h_end0 
//Bit 12:0  reg_vpu_pwm_h_start0 
#define VPU_VPU_PWM_H0                             0x2734
//Bit 28:16 reg_vpu_pwm_h_end1 
//Bit 12:0  reg_vpu_pwm_h_start1 
#define VPU_VPU_PWM_H1                             0x2735
//Bit 28:16 reg_vpu_pwm_h_end2 
//Bit 12:0  reg_vpu_pwm_h_start2 
#define VPU_VPU_PWM_H2                             0x2736
//Bit 28:16 reg_vpu_pwm_h_end3 
//Bit 12:0  reg_vpu_pwm_h_start3 
#define VPU_VPU_PWM_H3                             0x2737
//Bit 18   reg_vpu_3d_go_high_fld_pol: 0: go high at field 0, 1: go high at field 1
//Bit 17   reg_vpu_3d_sync_setting_vsync_latch
//Bit 16   reg_vpu_3d_sync_enable
//Bit 14:8 reg_vpu_3d_sync_v_end   
//Bit 6:0  reg_vpu_3d_sync_v_start 
#define VPU_VPU_3D_SYNC1                           0x2738
//Bit 28:16 reg_vpu_3d_sync_h_end   
//Bit 12:0  reg_vpu_3d_sync_h_start 
#define VPU_VPU_3D_SYNC2                           0x2739
//Bit 4    csi2_pre, 1: using vpu pre arbiter0, 0: using vpu pre arbiter2
//Bit 2:1  isp_in_sel, 01: select bt656, 10: select Mipi CSI2, otherwise select nothing  
//Bit 0,   if true, force vencl clk enable, otherwise, it might auto turn off by mipi DSI 
#define VPU_MISC_CTRL                              0x2740
#define VPU_ISP_GCLK_CTRL0                         0x2741
#define VPU_ISP_GCLK_CTRL1                         0x2742
#define VPU_HDMI_FMT_CTRL                          0x2743
#define VPU_VDIN_ASYNC_HOLD_CTRL                   0x2744
#define VPU_VDISP_ASYNC_HOLD_CTRL                  0x2745
#define VPU_VPUARB2_ASYNC_HOLD_CTRL                0x2746
//    vdin_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[0] |
//                        vdin0_lff_urg_ctrl & vpu_arb_urg_ctrl[1] | 
//                        vdin1_lff_urg_ctrl & vpu_arb_urg_ctrl[2];
//
//    vdisp_urg_ctrl_o <= vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[3] |
//                        vdin0_lff_urg_ctrl & vpu_arb_urg_ctrl[4] | 
//                        vdin1_lff_urg_ctrl & vpu_arb_urg_ctrl[5];
//
//    vpuarb2_urg_ctrl_o <= vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[6] |
//                          vdin0_lff_urg_ctrl & vpu_arb_urg_ctrl[7] | 
//                          vdin1_lff_urg_ctrl & vpu_arb_urg_ctrl[8];
#define VPU_ARB_URG_CTRL                           0x2747
// Picture Rotate (PROT) module 1 (for OSD) registers:
#define VPU_PROT1_CLK_GATE                         0x2750
#define VPU_PROT1_GEN_CNTL                         0x2751
#define VPU_PROT1_X_START_END                      0x2752
#define VPU_PROT1_Y_START_END                      0x2753
#define VPU_PROT1_Y_LEN_STEP                       0x2754
#define VPU_PROT1_RPT_LOOP                         0x2755
#define VPU_PROT1_RPT_PAT                          0x2756
#define VPU_PROT1_DDR                              0x2757
#define VPU_PROT1_RBUF_ROOM                        0x2758
#define VPU_PROT1_STAT_0                           0x2759
#define VPU_PROT1_STAT_1                           0x275a
#define VPU_PROT1_STAT_2                           0x275b
#define VPU_PROT1_REQ_ONOFF                        0x275c
// Picture Rotate (PROT) module 2 (for VD) registers:
#define VPU_PROT2_CLK_GATE                         0x2760
#define VPU_PROT2_GEN_CNTL                         0x2761
#define VPU_PROT2_X_START_END                      0x2762
#define VPU_PROT2_Y_START_END                      0x2763
#define VPU_PROT2_Y_LEN_STEP                       0x2764
#define VPU_PROT2_RPT_LOOP                         0x2765
#define VPU_PROT2_RPT_PAT                          0x2766
#define VPU_PROT2_DDR                              0x2767
#define VPU_PROT2_RBUF_ROOM                        0x2768
#define VPU_PROT2_STAT_0                           0x2769
#define VPU_PROT2_STAT_1                           0x276a
#define VPU_PROT2_STAT_2                           0x276b
#define VPU_PROT2_REQ_ONOFF                        0x276c
// Picture Rotate (PROT) module 3 (for VD) registers:
#define VPU_PROT3_CLK_GATE                         0x2770
#define VPU_PROT3_GEN_CNTL                         0x2771
#define VPU_PROT3_X_START_END                      0x2772
#define VPU_PROT3_Y_START_END                      0x2773
#define VPU_PROT3_Y_LEN_STEP                       0x2774
#define VPU_PROT3_RPT_LOOP                         0x2775
#define VPU_PROT3_RPT_PAT                          0x2776
#define VPU_PROT3_DDR                              0x2777
#define VPU_PROT3_RBUF_ROOM                        0x2778
#define VPU_PROT3_STAT_0                           0x2779
#define VPU_PROT3_STAT_1                           0x277a
#define VPU_PROT3_STAT_2                           0x277b
#define VPU_PROT3_REQ_ONOFF                        0x277c
//========================================================================
//  MIPI CSI2 Controller Adaptor    (16'h2a00 - 16'h2aff)
//
//========================================================================
//`define  CSI2_VCBUS_BASE            8'h2a
//`include "csi2_regs.h"
//======================================================================
// D2D3 registers 
//======================================================================
//`define     D2D3_VCBUS_BASE         8'h2b
//
// Reading file:  d2d3_regs.h
//
//===========================================================================
// D2D3 Registers    0x - 0x
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  D2D3_VCBUS_BASE = 0x2b
// -----------------------------------------------
//------------------------------------------------------------------------------
// D2D3 top-level registers
//------------------------------------------------------------------------------
// Bit 31    RW, rd_lock_en,     1 to allow update some read-only registers based on filed
// Bit 30    RW, sw_rst_nobuf,   1 to reset the whole d2d3 unit
// Bit 29:28 RW, clk_auto_dis,   [29] DBR clock disable
//                               [28] DPG clock disable
// Bit 27:16 RW, clk_ctrl,       [27:26] gated clock control for register unit 
//                               [25:24] gated clock control for DBR unit
//                               [23:22] gated clock control for LBDG unit
//                               [21:20] gated clock control for MBDG unit
//                               [19:18] gated clock control for CBDG unit
//                               [17:16] gated clock control for DBLD unit and SCD81 unit
// Bit 15:12 Reserved  
// Bit 11    RW, lo_chroma_sign, 0: negate the u/v component of DBR left channel video output, 1: bypass
// Bit 10    RW, ro_chroma_sign, 0: negate the u/v component of DBR right channel video output, 1: bypass
// Bit 9     RW, vi0_chroma_sign, 0: negate the u/v component of DPG video input, 1: bypass   
// Bit 8     RW, vi1_chroma_sign, 0: negate the u/v component of DBR video input, 1: bypass
// Bit 7:5   Reserved 
// Bit 4     RW, lg_en,          Enable the LBDG unit and LBDG clock        
// Bit 3     RW, mg_en,          Enable the MBDG unit and MBDG clock
// Bit 2     RW, cg_en,          Enable the CBDG unit and CBDG clock
// Bit 1     RW, dbr_en,         Enable the DBR unit and DBR clock
// Bit 0     RW, dpg_en,         Enable the DPG unit and clock except sub-unit CBDG, MBDG and LBDG
#define D2D3_GLB_CTRL                              0x2b00
// Indicate the input picture size in DPG unit
// Bit 31:16 RW, szx_vi_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vi_m1,      The vertical size minus 1
#define D2D3_DPG_INPIC_SIZE                        0x2b01
// Indicate the output picture size in DBR unit
// Bit 31:16 RW, szx_vo_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vo_m1,      The vertical size minus 1
#define D2D3_DBR_OUTPIC_SIZE                       0x2b02
// Indicate the rectangular window to generate the "depth" in DPG unit 
// Bit 31:16 RW, dg_win_x_start, Horizontal start position, count from 0
// Bit 15:0  RW, dg_win_x_end,   Horizontal end position, count from 0
#define D2D3_DGEN_WIN_HOR                          0x2b03
// Indicate the rectangular window to generate the "depth" in DPG unit 
// Bit 31:16 RW, dg_win_y_start, Vertical start position, count from 0
// Bit 15:0  RW, dg_win_y_end,   Vertical end position, count from 0
#define D2D3_DGEN_WIN_VER                          0x2b04
//------------------------------------------------------------------------------
// CBDG SCU18 SCD81 SCD81_PRE registers
// cg: color based depth generate module
// scu18: scale up module
// scd81: scale down module
// scd81_pre: scd81 pre-scale-down module
//------------------------------------------------------------------------------
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_hphs_step, horizontal step
// Bit 15:0  RW, scd81_hphs_ini, horizontal initial phase
#define D2D3_PRE_SCD_H                             0x2b05
// Bit 31:16 RW, scu18_iniph,    initial phase in SCU18, 
//                               [23:16] indicate the horizontal phase offset from the first data of every line
//                               [31:24] indicate the vertical phase offset from the first line of every frame
// Bit 15:12 Reserved
// Bit 11    RW, scd81_predrop_en, 1 to enable scd81 pre-scale-down function
// Bit 10:9  RW, cg_csc_sel,     Color Space Conversion(CSC) matrix mode selector in CBDG 
//                               0: BT.601 (16-235/240)
//                               1: BT.709 (16-235/240)
//                               2: BT.601 (0-255)
//                               3: BT.709 (0-255)
// Bit 8     RW, scu18_rep_en,   1 to double each line of the SCU18 output 
// Bit 7:4   RW, scu18_factor,   up-scale factor in SCU18 on DBR input depth data 
//                               [7:6] for vertical, 0->1:1, 1->1:2, 2->1:4, 3->1:8
//                               [5:4] for horizontal, 0->1:1, 1->1:2, 2->1:4, 3->1:8
// Bit 3:0   RW, scd81_factor,   down-scale factor in SCD81 on DPG source video 
//                               [3:2] for vertical, 0->1:1, 1->2:1, 2->4:1, 3->8:1
//                               [1:0] for horizontal, 0->1:1, 1->2:1, 2->4:1, 3->8:1
#define D2D3_SCALER_CTRL                           0x2b06
// Bit 31:24 RW, cg_rpg_dth,     the down |r-g| threshold for sky detect 
// Bit 23:16 RW, cg_rpg_uth,     the up |r-g| threshold for sky detect 
// Bit 15:8  RW, cg_lum_dth,     the down Y threshold for sky detect  
// Bit 7:0   RW, cg_lum_uth,     the up Y threshold for sky detect  
#define D2D3_CG_THRESHOLD_1                        0x2b07
// Bit 31:24 RW, cg_rpb_dth,     the down |r-b| threshold for sky detect
// Bit 23:16 RW, cg_rpb_uth,     the up |r-b| threshold for sky detect
// Bit 15:8  RW, cg_bpg_dth,     the down |b-g| threshold for sky detect
// Bit 7:0   RW, cg_bpg_uth,     the up |b-g| threshold for sky detect 
#define D2D3_CG_THRESHOLD_2                        0x2b08
// Bit 31:24 RW, cg_vp_rel_k,    parameter to calculate vanish point reliability
// Bit 23:16 RW, cg_vp_y_thr,    the max limitation to calculate the vanish-point's vertical position
// Bit 15:8  RW, cg_meet_dval,   signed depth value in the sky-bitmap 
// Bit 7:0   RW, cg_unmt_dval,   signed depth value not in the sky-bitmap
#define D2D3_CG_PARAM_1                            0x2b09
// Bit 31:16 RW, cg_vpos_thr,    Maximal vertical limitation for sky-bit map when cg_vpos_en=1 and cg_vpos_adpt_en=0
// Bit 15:8  Reserved
// Bit 7     RW, cg_vpos_en,     1 to enable the max vertical limitation for sky-bitmap
// Bit 6     RW, cg_vpos_adpt_en, 1 to enable the adaptive max vertical limitation for sky-bitmap. 
//                               It is only valid when cg_vpos_en=1.
//                               The max vertical limitation is the previous field's vanish-point (vertical position) if cg_vpos_adpt_en=1. 
// Bit 5:4   RW, cg_lpf_bypass,  bypass of low pass filter 
//                               [5]:Vertical bypass, 1: bypass the vertical LPF on the CBDG depth
//                               [4]:Horizontal bypass, 1: bypass the horizontal LPF on the CBDG depth
// Bit 3:0   RW, cg_vp_rel_s,    parameter to calculate vanish point reliability
#define D2D3_CG_PARAM_2                            0x2b0a
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_vphs_step, vertical step
// Bit 15:0  RW, scd81_vphs_ini, vertical initial phase
#define D2D3_PRE_SCD_V                             0x2b0b
//------------------------------------------------------------------------------
// D2P registers
// d2p: depth to parallax transform module
//------------------------------------------------------------------------------
// Bit 31:24 RW, d2p_brdwid,     Horizontal boundary width for parallax, the parallax value would be forced to 0 in boundary, 
//                               the d2p_brdwid should not 0 when D2P_WRAP is enabled
// Bit 23:22 Reserved
// Bit 21:20 RW, d2p_lomode,     line output mode, 
//                               0:whole line is left or right;  1:whole line is left or right;
//                               2:left/right pixel interleaved;  3:left/right half-line interleaved
// Bit 19    RW, d2p_neg,        1 to exchange the left and right parallax value
// Bit 18    Reserved 
// Bit 17    RW, d2p_wrap_en,    1 to enable D2P_WRAP unit
// Bit 16    RW, d2p_lar,        Indicate the first output for left or right, 0: left; 1: right
// Bit 15    RW, d2p_lr_switch,  enable left/right flag filed switch automatically, only valid when parallax output mode is field interleaved
// Bit 14    RW, d2p_1dtolr,     enable to generate 2 parallax data (left and right) from one depth
// Bit 13:12 RW, d2p_out_mode,   Parallax output mode 
//                               0:left/right pixel interleaved; 1:line or half line interleaved; 2:field interleaved
// Bit 11:8  RW, d2p_smode,      Shift mode,
//                               0: no shift; 1: enable left shift;
//                               2: enable right shift; 3: both left and right shift are enabled
// Bit 7:0   RW, d2p_offset,     depth offset, signed, 
#define D2D3_D2P_PARAM_1                           0x2b0c
// Bit 31:24 RW, d2p_pg0,        positive parallax gain when Parallax value < pt
// Bit 23:16 RW, d2p_pg1,        positive parallax gain when Parallax value >= pt
// Bit 15:8  RW, d2p_pt,         unsigned value used to separate the positive parallax range
// Bit 7:0   RW, d2p_plimit,     The limitation for positive parallax
#define D2D3_D2P_PARAM_2                           0x2b0d
// Bit 31:24 RW, d2p_ng0,        negative parallax gain when Parallax value > -nt
// Bit 23:16 RW, d2p_ng1,        negative parallax gain when Parallax value <= -nt
// Bit 15:8  RW, d2p_nt,         unsigned value used to separate the negative parallax range
// Bit 7:0   RW, d2p_nlimit,     The limitation for negative parallax
#define D2D3_D2P_PARAM_3                           0x2b0e
// Indicate step parameters of SCU18 unit
// Bit 31:17 Reserved
// Bit 16    RW, scu18_step_en,   step set enable in SCU18
// Bit 15:8  RW, scu18_hphs_step, horizontal step in SCU18
// Bit 7:0   RW, scu18_vphs_step, vertical step in SCU18
#define D2D3_SCU18_STEP                            0x2b0f
//------------------------------------------------------------------------------
// LBDG and DBLD registers
// lg: luma based depth generate module
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:22 Reserved
// Bit 21:20 RW, db_lpf_bpcoeff, [21]:Vertical factor of low pass filter, 
//                               1: Vfactor = 0/0/64/0/0, 0: Vfactor = {db_vf_a,db_vf_b,db_vf_c,db_vf_b,db_vf_a}, see D2D3_CTRL_15
//                               [20]:Horizontal factor of low pass filter, 
//                               1: Hfactor = 0/0/64/0/0, 0: Hfactor = {db_hf_a,db_hf_b,db_hf_c,db_hf_b,db_hf_a}, see D2D3_CTRL_14
// Bit 19:18 RW, lg_lpf_bpcoeff, [19]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [18]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 17:16 RW, cg_lpf_bpcoeff, [17]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [16]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 15:10 Reserved
// Bit 9:8   RW, db_lpf_bypass,  [9] 1 to bypass the vertical LPF on the DBLD depth
//                               [8] 1 to bypass the horizontal LPF on the DBLD depth
// Bit 7:6   RW, lg_lpf_bypass,  [7] 1 to bypass the vertical LPF on the LBDG depth
//                               [6] 1 to bypass the horizontal LPF on the LBDG depth
// Bit 5:0   RW, lg_kc,          gain of CPL(v-u+256-y) to calculate the depth in LBDG
#define D2D3_DPF_LPF_CTRL                          0x2b10
//------------------------------------------------------------------------------
// DBLD registers
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:24 RW, db_g2_cg,       gain of CBDG depth in DBLD
// Bit 23:16 RW, db_o2_cg,       offset of CBDG depth in DBLD
// Bit 15:8  RW, db_g1_cg,       gain of CBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_cg,       offset of CBDG depth using for summary in DBLD
#define D2D3_DBLD_CG_PARAM                         0x2b11
// Bit 31:24 RW, db_g2_mg,       gain of MBDG depth in DBLD
// Bit 23:16 RW, db_o2_mg,       offset of MBDG depth in DBLD
// Bit 15:8  RW, db_g1_mg,       gain of MBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_mg,       offset of MBDG depth using for summary in DBLD
#define D2D3_DBLD_MG_PARAM                         0x2b12
// Bit 31:24 RW, db_g2_lg,       gain of LBDG depth in DBLD
// Bit 23:16 RW, db_o2_lg,       offset of LBDG depth in DBLD
// Bit 15:8  RW, db_g1_lg,       gain of LBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_lg,       offset of LBDG depth using for summary in DBLD
#define D2D3_DBLD_LG_PARAM                         0x2b13
// Bit 31:24 RW, db_factor,      unsigned gain of difference in DBLD
// Bit 23:16 RW, db_hf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_hf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_hf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define D2D3_DBLD_LPF_HCOEFF                       0x2b14
// Bit 31:24 RW, db_owin_fill,   signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 23:16 RW, db_vf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_vf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_vf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define D2D3_DBLD_LPF_VCOEFF                       0x2b15
// Bit 31:28 RW, hist_depth_idx,     
// Bit 27:26 Reserved   
// Bit 25    RW, mbdg_dep_neg,   1 to negate the output data of MBDG
// Bit 24    RW, lbdg_dep_neg,   1 to negate the output data of LBDG
// Bit 23:16 RW, db_f1_ctrl,     MUX1 selector
//                               [1:0] MUX1 path1 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX1 path2 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX1 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX1out0, others:summary
//                               [7] MUX1OUT0 selector, 0:MIN (MUX1PATH1,MUX1Path2), 1:MAX (MUX1Path1,MUX1Path2)
// Bit 15:8  RW, db_f2_ctrl,     MUX2 selector
//                               [1:0] MUX2 path1 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX2 path2 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX2 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX2out0, others:MUX2out0
//                               [7] MUX2OUT0 selector, 0:MIN (MUX2PATH1,MUX2Path2), 1:MAX (MUX2Path1,MUX2Path2)
// Bit 7:4   RW, db_fifo0_sel,   the source input of FIFO0
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG others:reserved
// Bit 3:0   RW, db_fifo1_sel,   the source input of FIFO1
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG 4: from FIFO0; others:reserved
#define D2D3_DBLD_PATH_CTRL                        0x2b16
// Indicate the input picture size in SCU18 unit
// Bit 31:16 RW, szy_scui,       The vertical size 
// Bit 15:0  RW, szx_scui,       The horizontal size 
#define D2D3_SCU18_INPIC_SIZE                      0x2b17
//------------------------------------------------------------------------------
// MBDG registers
// mg: model based depth generate module
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, mg_vp_en,       mdg vanish point enable, not used
// Bit 16    RW, mg_sw_en,       1 to use the software forced parameter for the point D, U and C in MBDG
// Bit 15:8  RW, mg_owin_fill,   Signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 7     RW, mg_iir_en,      1 to enable the 2-taps IIR filter in MBDG
// Bit 6:0   RW, mg_iir,         [6]: 1 to bypass the 2-taps IIR filter in MBDG
//                               [5:0]:Unsigned coefficient of the 2-taps IIR filter in MBDG
//                               [6]:bypass, 1:bypass, 0:not bypass
#define D2D3_MBDG_CTRL                             0x2b18
// Bit 31:28 RW, mg_dtl_pxl_left, Max pixel number (1<< mg_dtl_pxl_left) using in the left window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_right, Max pixel number (1<< mg_dtl_pxl_right) using in the right window for activities in MBDG
// Bit 23:16 RW, mg_cx_sw,       Depth of point C in horizontal curve in MBDG for software forced
// Bit 15:8  RW, mg_ux_sw,       Depth of point U in horizontal curve in MBDG for software forced
// Bit 7:0   RW, mg_dx_sw,       Depth of point D in horizontal curve in MBDG for software forced
#define D2D3_MBDG_PARAM_0                          0x2b19
// Bit 31:28 RW, mg_dtl_pxl_up,  Max pixel number (1<< mg_dtl_pxl_up) using in the top window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_dn,  Max pixel number (1<< mg_dtl_pxl_dn) using in the bottom window for activities in MBDG
// Bit 23:16 RW, mg_cy_sw,       Depth of point C in vertical curve in MBDG for software forced       
// Bit 15:8  RW, mg_uy_sw,       Depth of point U in vertical curve in MBDG for software forced
// Bit 7:0   RW, mg_dy_sw,       Depth of point D in vertical curve in MBDG for software forced
#define D2D3_MBDG_PARAM_1                          0x2b1a
// Bit 31:24 RW, mg_dtl_ln_up,   Line number in the top window for activities in MBDG
// Bit 23:16 RW, mg_dtl_ln_dn,   Line number in the bottom window for activities in MBDG
// Bit 15:8  RW, mg_dtl_ln_left, Column number in the left window for activities in MBDG
// Bit 7:0   RW, mg_dtl_ln_right,Column number in the right window for activities in MBDG
#define D2D3_MBDG_PARAM_2                          0x2b1b
// Bit 31:24 RW, mg_y_max,       Software initial depth of point D and U in vertical curve
// Bit 23:16 RW, mg_y_min,       Software initial depth of point C in vertical curve
// Bit 15:8  RW, mg_x_max,       Software initial depth of point D and U in horizontal curve
// Bit 7:0   RW, mg_x_min,       Software initial depth of point C in horizontal curve
#define D2D3_MBDG_PARAM_3                          0x2b1c
// Bit 31:27 Reserved
// Bit 26    RW, mg_y_adapt_en,  1 to enable the adaptive mode for point U/D in vertical curve calculation
// Bit 25    RW, mg_xmm_adapt_en, 1 to enable the XMM adaptive mode for point U/D in horizontal curve calculation
// Bit 24    RW, mg_x_adapt_en,  1 to enable the adaptive mode for point U/D in horizontal curve calculation
// Bit 23:20 RW, mg_ytrans_1,    Shifter controller in vertical curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 19:16 RW, mg_xtrans_1,    Shifter controller in horizontal curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 15:8  RW, mg_yk_0,        The based activities value of the ACT for vertical curve
// Bit 7:0   RW, mg_xk_0,        The based activities value of the ACT for horizontal curve
#define D2D3_MBDG_PARAM_4                          0x2b1d
// Bit 31:24 RW, mg_ysu3,        Quantized value 3 in vertical curve adaptive calculation
// Bit 23:16 RW, mg_ysu2,        Quantized value 2 in vertical curve adaptive calculation
// Bit 15:8  RW, mg_ysu1,        Quantized value 1 in vertical curve adaptive calculation
// Bit 7:0   RW, mg_ysu0,        Quantized value 0 in vertical curve adaptive calculation
#define D2D3_MBDG_PARAM_5                          0x2b1e
// Bit 31:24 RW, mg_xsu3,        Quantized value 3 in horizontal curve adaptive calculation
// Bit 23:16 RW, mg_xsu2,        Quantized value 2 in horizontal curve adaptive calculation
// Bit 15:8  RW, mg_xsu1,        Quantized value 1 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_xsu0,        Quantized value 0 in horizontal curve adaptive calculation
#define D2D3_MBDG_PARAM_6                          0x2b1f
// Bit 31:16 Reserved 
// Bit 15:8  RW, mg_xsu4,        Quantized value 4 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_ysu4,        Quantized value 4 in vertical curve adaptive calculation
#define D2D3_MBDG_PARAM_7                          0x2b20
// Bit 31:28 RW, dbg_hscnt_sel   see DBG_STATUS_2
// Bit 27:25 Reserved 
// Bit 24    RW, dbg_dbr_en,     1 to enable debug mode in DBR
// Bit 23:16 RW, dbg_force_data, Forced data in debug mode
// Bit 15:12 RW, dbg_bld_ctrl,   debug controller for DBLD
//                               [12]:enable;  [13]: 0 for passive mode, 0 for handshake mode
//                               [15:14]: 0 for constant mode, 1 for step1 mode
// Bit 11:8  RW, dbg_mg_ctrl,    debug controller for MBDG
//                               [8]:enable;  [9]: 0 for passive mode, 0 for handshake mode
//                               [11:10]: 0 for constant mode, 1 for step1 mode
// Bit 7:4   RW, dbg_cg_ctrl,    debug controller for CBDG
//                               [4]:enable;  [5]: 0 for passive mode, 0 for handshake mode
//                               [7:6]: 0 for constant mode, 1 for step1 mode
// Bit 3:0   RW, dbg_lg_ctrl,    debug controller for LBDG
//                               [0]:enable;  [1]: 0 for passive mode, 0 for handshake mode
//                               [3:2]: 0 for constant mode, 1 for step1 mode
#define D2D3_DBG_CTRL                              0x2b23
//------------------------------------------------------------------------------
// DWMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved 
// Bit 17    RW, dw_x_rev        0: Normal write data from left to right in horizontal
//                               1: Reversed write data from left to right in horizontal
// Bit 16    RW, dw_y_rev        0: Normal write data from top to bottom in horizontal
//                               1: Reversed write data from bottom to top in horizontal  
// Bit 15    RW, dw_done_clr     1 to clear register depw_done (DWMIF_STATUS)
// Bit 14    RW, dw_little_endian, 0: data is ordered in big-endian, 1: little endian
// Bit 13:12 RW, dw_pic_struct,  0:read every line, 1:reserved, 2:read even line, 3:read odd line
// Bit 11    RW, dw_urgent,      urgent index
// Bit 10    RW, dw_clr_wrrsp,   1:clear the write fifo counter
// Bit 9     RW, dw_canvas_wr,   canvas write initialization again
// Bit 8     RW, dw_req_en,      1 to enable write request
// Bit 7:0   RW, dw_canvas_index,Canvas index for the MSB of memory address for memory write
#define D2D3_DWMIF_CTRL                            0x2b24
// Bit 31    Reserved
// Bit 30:16 RW, dw_end_x,       Horizontal end position for memory write, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dw_start_x,     Horizontal start position for memory write, count by BYTE
#define D2D3_DWMIF_HPOS                            0x2b25
// Bit 31:29 Reserved
// Bit 28:16 RW, dw_end_y,       Vertical end position for memory write, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dw_start_y,     Vertical start position for memory write, count by BYTE
#define D2D3_DWMIF_VPOS                            0x2b26
// Bit 31:28 Reserved
// Bit 27:16 RW, dw_vsizem1,     Vertical size for memory write, equal the size minus 1
// Bit 15:12 Reserved
// Bit 11:0  RW, dw_hsizem1,     Horizontal size for memory write, equal the size minus 1
#define D2D3_DWMIF_SIZE                            0x2b27
//------------------------------------------------------------------------------
// DRMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, dr_y_rev,       0: Normal Read data from top to bottom in horizontal
//                               1: Reversed read data from bottom to top in horizontal
// Bit 16    RW, dr_x_rev,       0: Normal Read data from left to right in horizontal
//                               1: Reversed read data from right to left in horizontal
// Bit 15    RW, dr_clr_fifo_error, 1 to clear the overflow flag of the sticky FIFO
// Bit 14    RW, dr_little_endian, 0: data is ordered in big-endian; 1: little-endian
// Bit 13:12 RW, dr_pic_struct,  0: progressive;  1: Reserved;
//                               2: interlaced, even line;  3: interlaced, odd line
// Bit 11    RW, dr_urgent,      urgent index, no use in this system
// Bit 10:9  RW, dr_burst_size,  Burst read length for each request; 0=24,1=32,2=48,3=64
// Bit 8     RW, dr_req_en,      1 to enable read request
// Bit 7:0   RW, dr_canvas_index, Canvas index for the MSB of memory address for memory read
#define D2D3_DRMIF_CTRL                            0x2b28
// Bit 31    Reserved
// Bit 30:16 RW, dr_end_x,       Horizontal end position for memory read, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dr_start_x,     Horizontal start position for memory read, count by BYTE
#define D2D3_DRMIF_HPOS                            0x2b29
// Bit 31:29 Reserved
// Bit 28:16 RW, dr_end_y,       Vertical end position for memory read, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dr_start_y,     Vertical start position for memory read, count by BYTE
#define D2D3_DRMIF_VPOS                            0x2b2a
//------------------------------------------------------------------------------
// PDR registers
// ddd: parallax based render
//------------------------------------------------------------------------------
// Bit 31:8  Reserved
// Bit 7     RW, ddd_brdlpf_en,  1 to enable the smooth filter on the depth around the boundary
// Bit 6     RW, ddd_extn_black, 1 to enable the function to fill black colour when interpolated pixels is outside the picture in DBR
// Bit 5     RW, ddd_wrap_en,    Reserved
// Bit 4     RW, ddd_hhalf,      1 to indicate the left/right line length is a half of original line. 
// Bit 3:2   RW, ddd_out_mode,   Reserved
// Bit 1:0   RW, ddd_lomode,     wrap & pbr interleave mode:                                        
//                               2'b0x: whole line is left or right;                           
//                               2'b10: d2p_lar=1(D2P_PARAM_1), rlrlrlrl inteleave in one line,
//                                      d2p_lar=0(D2P_PARAM_1), lrlrlrlr inteleave in one line,      
//                               2'b11: d2p_lar=1(D2P_PARAM_1), rrrrr?lllll, half line is right, another half is left,
//                                      d2p_lar=0(D2P_PARAM_1), lllll?rrrrr, half line is left, another half is right,
#define D2D3_DBR_DDD_CTRL                          0x2b2c
// Bit 31:0  RW, ddd_dbg_ctrl,   no use
#define D2D3_DBR_DDD_DBG                           0x2b2d
//------------------------------------------------------------------------------
// LRDMX registers
//------------------------------------------------------------------------------
// Bit 31:9  Reserved
// Bit 8     RW, lr_merge,       1: all the left/right input go to the left channel output
// Bit 7:6   RW, lrd_ff0_sel,    FF0 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 5:4   RW, lrd_ff1_sel,    FF1 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 3:2   RW, lrd_lout_sel,   left channel DEMUX
//                               00: ff0  01:ff1   10: left input  11:right input
// Bit 1:0   RW, lrd_rout_sel,   right channel DEMUX
//                               00: ff1  01:ff0   10: left input  11:right input 
#define D2D3_DBR_LRDMX_CTRL                        0x2b2f
//------------------------------------------------------------------------------
// Read Only registers
//------------------------------------------------------------------------------
// Bit 31:24 RO, ro_cg_vprel,    vanish point's reliability in CBDG
// Bit 23:12 RO, ro_cg_vpx,      vanish point's X-Axis in CBDG
// Bit 11:0  RO, ro_cg_vpy,      vanish point's Y-Axis in CBDG
#define D2D3_CBDG_STATUS_1                         0x2b30
// Bit 31:24 RO, ro_mg_cx[7:0],  X-Axis of point C in horizontal curve in MBDG
// Bit 23:16 RO, ro_mg_ux,       Depth value of point U in horizontal curve in MBDG
// Bit 15:8  RO, ro_mg_dx,       Depth value of point D in horizontal curve in MBDG
// Bit 7:0   RO, ro_mg_minx,     Depth value of point C in horizontal curve in MBDG
#define D2D3_MBDG_STATUS_1                         0x2b31
// Bit 31:24 RO, ro_mg_cy[7:0],  X-Axis of point C in vertical curve in MBDG
// Bit 23:16 RO, ro_mg_uy,       Depth value of point U in vertical curve in MBDG
// Bit 15:8  RO, ro_mg_dy,       Depth value of point D in vertical curve in MBDG
// Bit 7:0   RO, ro_mg_miny,     Depth value of point C in vertical curve in MBDG
#define D2D3_MBDG_STATUS_2                         0x2b32
// Bit 31    RO, ro_wrap_status, 1 indicate the D2P_WRAP is busy to perform the initialization
// Bit 30:8  Reserved 
// Bit 7:4   RO, ro_mg_cy[11:8], X-Axis of point C in vertical curve in MBDG
// Bit 3:0   RO, ro_mg_cx[11:8], X-Axis of point C in horizontal curve in MBDG
#define D2D3_MBDG_STATUS_3                         0x2b33
// Bit 31:21 Reserved 
// Bit 20:0  RO, ro_mg_sum_u,    ACT(top): activities of the top part
#define D2D3_MBDG_STATUS_4                         0x2b34
// Bit 31:21 Reserved 
// Bit 20:0  RO, ro_mg_sum_d,    ACT(bottom): activities of the bottom part
#define D2D3_MBDG_STATUS_5                         0x2b35
// Bit 31:21 Reserved 
// Bit 20:0  RO, ro_mg_sum_l,    ACT(left): activities of the left part
#define D2D3_MBDG_STATUS_6                         0x2b36
// Bit 31:21 Reserved  
// Bit 20:0  RO, ro_mg_sum_r,    ACT(right): activities of the right part
#define D2D3_MBDG_STATUS_7                         0x2b37
// Bit 31:0 dbg_handshake_ro0,   handshake signal for debug, internal srdy and rrdy
#define D2D3_DBG_STATUS_1                          0x2b38
// Bit 31:0 dbg_hscnt,           dbg_hscnt_sel == 4'h0, output lg hscnt
//                               dbg_hscnt_sel == 4'h1, output cg hscnt
//                               dbg_hscnt_sel == 4'h2, output mg hscnt
//                               dbg_hscnt_sel == 4'h3, output bld hscnt
//                               dbg_hscnt_sel == other value, output 32'h0
#define D2D3_DBG_STATUS_2                          0x2b39
// Bit 31:0 RO, drmif_status,    drmif module internal status
#define D2D3_DRMIF_STATUS                          0x2b3a
// Bit 31:2 RO, Reserved
// Bit 1:0  RO, d2d3_status0,    [1]: depw_done, one field depth write to ddr has done
//                               [0]: dwmif_pending_ddr_wrrsp, 1 to indicate write response from ddr
#define D2D3_DWMIF_STATUS                          0x2b3b
// Bit 31:24 Reserved  
// Bit 23:0  RO, ro_meet_sum,    register sumxy_sum_dbg in CBDG
#define D2D3_CBDG_STATUS_2                         0x2b3c
// Bit 31:20 Reserved  
// Bit 19:0  RO, ro_hist_depth,  
#define D2D3_DBLD_STATUS                           0x2b3d
// Bit 31:0 Reserved  
#define D2D3_RESEV_STATUS1                         0x2b3e
// Bit 31:0  Reserved  
#define D2D3_RESEV_STATUS2                         0x2b3f
//
// Closing file:  d2d3_regs.h
//
//========================================================================
//  MIPI DSI Host Controller        (16'h2c00 - 16'h2cff)
//
//========================================================================
//`define  DSI_VCBUS_BASE             8'h2c
//`include "dsi_regs.h"
//========================================================================
//  ISP register    (16'h2d00 - 16'h2dff)
//========================================================================
//`define ISP_VCBUS_BASE                   8'h2d
//`include "isp_reg.h"
//========================================================================
//  VI_HIST_SPL register    (16'h2e00 - 16'h2eff)
//========================================================================
//`define VI_HIST_SPL_VCBUS_BASE                   8'h2e
//
// Reading file:  vi_hist_spl_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// VI_HIST_SPL 0x2e  
// ----------------------------
// -----------------------------------------------
// CBUS_BASE:  VI_HIST_SPL_VCBUS_BASE = 0x2e
// -----------------------------------------------
//BIT 14: 34bin only, 0&255 and other 32bins
//Bit 13:11 hist_din_sel, 00: from vdin0 dout,  1: from vdin1, 2: from nr dout, 3: di output, 4: vpp output, 5: vd1_din, 6: vd2_din, 7:osd1_dout
//Bit 10:8   hist_din_comp_mux, mux of [29:22], [19:12], [9:2] for hist detect
//Bit 7:5   hist_dnlp_low   the real pixels in each bins got by VI_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define VI_HIST_CTRL                               0x2e00
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define VI_HIST_H_START_END                        0x2e01
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define VI_HIST_V_START_END                        0x2e02
//Bit 15:8  hist_max    maximum value 
//Bit 7:0   hist_min    minimum value 
//read only
#define VI_HIST_MAX_MIN                            0x2e03
//Bit 31:0  hist_spl_rd
//counts for the total luma value 
//read only
#define VI_HIST_SPL_VAL                            0x2e04
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define VI_HIST_SPL_PIX_CNT                        0x2e05
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value 
//read only
#define VI_HIST_CHROMA_SUM                         0x2e06
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VI_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VI_DNLP_HIST00[15:0]  counts for the first  bin
//VI_DNLP_HIST00[31:16] counts for the second bin
//VI_DNLP_HIST01[15:0]  counts for the third  bin
//VI_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define VI_DNLP_HIST00                             0x2e07
#define VI_DNLP_HIST01                             0x2e08
#define VI_DNLP_HIST02                             0x2e09
#define VI_DNLP_HIST03                             0x2e0a
#define VI_DNLP_HIST04                             0x2e0b
#define VI_DNLP_HIST05                             0x2e0c
#define VI_DNLP_HIST06                             0x2e0d
#define VI_DNLP_HIST07                             0x2e0e
#define VI_DNLP_HIST08                             0x2e0f
#define VI_DNLP_HIST09                             0x2e10
#define VI_DNLP_HIST10                             0x2e11
#define VI_DNLP_HIST11                             0x2e12
#define VI_DNLP_HIST12                             0x2e13
#define VI_DNLP_HIST13                             0x2e14
#define VI_DNLP_HIST14                             0x2e15
#define VI_DNLP_HIST15                             0x2e16
#define VI_DNLP_HIST16                             0x2e17
#define VI_DNLP_HIST17                             0x2e18
#define VI_DNLP_HIST18                             0x2e19
#define VI_DNLP_HIST19                             0x2e1a
#define VI_DNLP_HIST20                             0x2e1b
#define VI_DNLP_HIST21                             0x2e1c
#define VI_DNLP_HIST22                             0x2e1d
#define VI_DNLP_HIST23                             0x2e1e
#define VI_DNLP_HIST24                             0x2e1f
#define VI_DNLP_HIST25                             0x2e20
#define VI_DNLP_HIST26                             0x2e21
#define VI_DNLP_HIST27                             0x2e22
#define VI_DNLP_HIST28                             0x2e23
#define VI_DNLP_HIST29                             0x2e24
#define VI_DNLP_HIST30                             0x2e25
#define VI_DNLP_HIST31                             0x2e26
#define VI_DNLP_HIST32                             0x2e27
//Bit 28:16 hist_pic_height  active input data window height
//Bit 12:0  hist_pic_width   active input data window width
#define VI_HIST_PIC_SIZE                           0x2e28
//Bit 15:8 hist_pix_white_value: >= this value will be white pixel
//Bit 7:0 hist_pix_black_value: <= this value will be black pixel
#define VI_HIST_BLACK_WHITE_VALUE                  0x2e29
#define VI_HIST_GCLK_CTRL                          0x2e2a
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vi_hist_spl_reg.h
//
//`define MCDI_VCBUS_BASE                8'h2f
//
// Reading file:  mcdi_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  MCDI_VCBUS_BASE = 0x2f
// -----------------------------------------------
////=================================================================////
//// memc di core 0
////=================================================================////
#define MCDI_HV_SIZEIN                             0x2f00
//Bit 31:29, reserved  
//Bit 28:16, reg_mcdi_hsize               image horizontal size (number of cols)   default=1024 
//Bit 15:13, reserved                       
//Bit 12: 0, reg_mcdi_vsize               image vertical size   (number of rows)   default=1024
#define MCDI_HV_BLKSIZEIN                          0x2f01
//Bit    31, reg_mcdi_vrev					 default = 0
//Bit    30, reg_mcdi_hrev					 default = 0
//Bit 29:28, reserved
//Bit 27:16, reg_mcdi_blkhsize               image horizontal blk size (number of cols)   default=1024 
//Bit 15:13, reserved                       
//Bit 11: 0, reg_mcdi_blkvsize               image vertical blk size   (number of rows)   default=1024
#define MCDI_BLKTOTAL                              0x2f02
//Bit 31:24, reserved
//Bit 23: 0, reg_mcdi_blktotal
#define MCDI_MOTINEN                               0x2f03
//Bit 31: 2, reserved
//Bit     1, reg_mcdi_motionrefen.           enable motion refinement of MA, default = 1
//Bit     0, reg_mcdi_motionparadoxen.       enable motion paradox detection, default = 1
#define MCDI_CTRL_MODE                             0x2f04
//Bit 31:28, reserved 
//Bit 27:26, reg_mcdi_lmvlocken	             0:disable, 1: use max Lmv, 2: use no-zero Lmv, lmv lock enable mode, default = 2			
//Bit 25,    reg_mcdi_reldetrptchken         
//                                           0: unable; 1: enable, enable repeat pattern check (not repeat mv detection) in rel det part, default = 1
//Bit 24,    reg_mcdi_reldetgmvpd22chken     
//                                           0: unable; 1: enable, enable pull-down 22 mode check in gmv lock mode for rel det, default = 1
//Bit 23,    reg_mcdi_pd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check (lock) function, default = 1      
//Bit 22,    reg_mcdi_reldetlpfen
//                                           0: unable; 1: enable, enable det value lpf, default = 1 
//Bit 21,    reg_mcdi_reldetlmvpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check in lmv lock mode for rel det, default = 1      
//Bit 20,    reg_mcdi_reldetlmvdifchken
//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1  
//Bit 19,    reg_mcdi_reldetgmvdifchken
//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1 
//Bit 18,    reg_mcdi_reldetpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check for rel det refinement, default = 1
//Bit 17,    reg_mcdi_reldetfrqchken
//                                           0: unable; 1: enable, enable mv frequency check in rel det, default = 1  
//Bit 16,    reg_mcdi_qmeen
//                                           0: unable; 1: enable, enable quarter motion estimation, defautl = 1  
//Bit 15,    reg_mcdi_refrptmven
//                                           0: unable; 1: enable, use repeat mv in refinement, default = 1 
//Bit 14,    reg_mcdi_refgmven
//                                           0: unable; 1: enable, use gmv in refinement, default = 1  
//Bit 13,    reg_mcdi_reflmven
//                                           0: unable; 1: enable, use lmvs in refinement, default = 1  
//Bit 12,    reg_mcdi_refnmven
//                                           0: unable; 1: enable, use neighoring mvs in refinement, default = 1  
//Bit 11,    reserved  
//Bit 10,    reg_mcdi_referrfrqchken		 
//                                           0: unable; 1: enable, enable mv frquency check while finding min err in ref, default = 1  
//Bit 9,     reg_mcdi_refen					 
//                                           0: unable; 1: enable, enable mv refinement, default = 1  
//Bit 8,     reg_mcdi_horlineen				 
//                                           0: unable; 1: enable,enable horizontal lines detection by sad map, default = 1  
//Bit 7,     reg_mcdi_highvertfrqdeten		 
//                                           0: unable; 1: enable, enable high vertical frequency pattern detection, default = 1  
//Bit 6,     reg_mcdi_gmvlocken				 
//                                           0: unable; 1: enable, enable gmv lock mode, default = 1
//Bit 5,     reg_mcdi_rptmven	             
//                                           0: unable; 1: enable, enable repeat pattern detection, default = 1  
//Bit 4,     reg_mcdi_gmven                  
//                                           0: unable; 1: enable, enable global motion estimation, default = 1   
//Bit 3,     reg_mcdi_lmven                  
//                                           0: unable; 1: enable, enable line mv estimation for hme, default = 1  
//Bit 2,     reg_mcdi_chkedgeen		         
//                                           0: unable; 1: enable, enable check edge function, default = 1
//Bit 1,     reg_mcdi_txtdeten			     
//                                           0: unable; 1: enable, enable texture detection, default = 1 
//Bit 0,     reg_mcdi_memcen                  
//                                           0: unable; 1: enable, enable of memc di, default = 1
#define MCDI_UNI_MVDST                             0x2f05
//Bit 31:20, reserved  
//Bit 19:17, reg_mcdi_unimvdstabsseg0                     segment0 for uni-mv abs, default = 1
//Bit 16:12, reg_mcdi_unimvdstabsseg1                     segment1 for uni-mv abs, default = 15
//Bit 11: 8, reg_mcdi_unimvdstabsdifgain0	          2/2, gain0 of uni-mv abs dif for segment0, normalized 2 to '1', default = 2 
//Bit  7: 5, reg_mcdi_unimvdstabsdifgain1                 2/2, gain1 of uni-mv abs dif for segment1, normalized 2 to '1', default = 2             
//Bit  4: 2, reg_mcdi_unimvdstabsdifgain2                 2/2, gain2 of uni-mv abs dif beyond segment1, normalized 2 to '1', default = 2              
//Bit  1: 0, reg_mcdi_unimvdstsgnshft		          shift for neighboring distance of uni-mv, default = 0
#define MCDI_BI_MVDST                              0x2f06
//Bit 31:20, reserved  
//Bit 19:17, reg_mcdi_bimvdstabsseg0                      segment0 for bi-mv abs, default = 1
//Bit 16:12, reg_mcdi_bimvdstabsseg1                      segment1 for bi-mv abs, default = 9
//Bit 11: 8, reg_mcdi_bimvdstabsdifgain0	          6/2, gain0 of bi-mv abs dif for segment0, normalized 2 to '1', default = 6
//Bit  7: 5, reg_mcdi_bimvdstabsdifgain1                  3/2, gain1 of bi-mvabs dif for segment1, normalized 2 to '1', default = 3          
//Bit  4: 2, reg_mcdi_bimvdstabsdifgain2                  2/2, gain2 of bi-mvabs dif beyond segment1, normalized 2 to '1', default = 2             
//Bit  1: 0, reg_mcdi_bimvdstsgnshft	                  shift for neighboring distance of bi-mv, default = 0
#define MCDI_SAD_GAIN                              0x2f07
//Bit 31:19, reserved  
//Bit 18:17, reg_mcdi_unisadcorepxlgain                   uni-sad core pixels gain, default = 3
//Bit 16,    reg_mcdi_unisadcorepxlnormen                 enable uni-sad core pixels normalization, default = 0 
//Bit 15:11, reserved
//Bit 10: 9, reg_mcdi_bisadcorepxlgain                    bi-sad core pixels gain, default = 3
//Bit  8,    reg_mcdi_bisadcorepxlnormen                  enable bi-sad core pixels normalization, default = 1 
//Bit  7: 3, reserved
//Bit  2: 1, reg_mcdi_biqsadcorepxlgain                   bi-qsad core pixels gain, default = 3
//Bit  0,    reg_mcdi_biqsadcorepxlnormen                 enable bi-qsad core pixels normalization, default = 1              
#define MCDI_TXT_THD                               0x2f08
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_txtminmaxdifthd,                    min max dif threshold (>=) for texture detection, default = 24
//Bit 15: 8, reg_mcdi_txtmeandifthd,                      mean dif threshold (<) for texture detection, default = 9
//Bit  7: 3, reserved
//Bit  2: 0, reg_mcdi_txtdetthd,                          texture detecting threshold, 0~4, default = 2
#define MCDI_FLT_MODESEL                           0x2f09
//Bit 31	 reserved
//Bit 30:28, reg_mcdi_flthorlineselmode                   mode for horizontal line detecting flat calculation, default = 1, same as below
//Bit 27	 reserved
//Bit 26:24, reg_mcdi_fltgmvselmode                       mode for gmv flat calculation, default = 4, same as below
//Bit 23,	 reserved
//Bit 22:20, reg_mcdi_fltsadselmode                       mode for sad flat calculation, default = 2, same as below
//Bit 19,	 reserved
//Bit 18:16, reg_mcdi_fltbadwselmode                      mode for badw flat calculation, default = 3, same as below
//Bit 15,	 reserved
//Bit 14:12, reg_mcdi_fltrptmvselmode                     mode for repeat mv flat calculation, default = 4, same as below
//Bit 11,	 reserved
//Bit 10: 8, reg_mcdi_fltbadrelselmode                    mode for bad rel flat calculation, default = 4, same as below
//Bit  7,	 reserved
//Bit  6: 4, reg_mcdi_fltcolcfdselmode                    mode for col cfd flat calculation, default = 2, same as below
//Bit  3,	 reserved
//Bit  2: 0, reg_mcdi_fltpd22chkselmode                   mode for pd22 check flat calculation, default = 2, # 0:cur dif h, 1: cur dif v, 2: pre dif h, 3: pre dif v, 4: cur flt, 5: pre flt, 6: cur+pre, 7: max all(cur,pre)
#define MCDI_CHK_EDGE_THD                          0x2f0a
//Bit 23:28, reserved.
//Bit 27:24, reg_mcdi_chkedgedifsadthd.                   thd (<=) for sad dif check, 0~8, default = 1
//Bit 23:16, reserved.
//Bit 15:12, reg_mcdi_chkedgemaxedgethd.                  max drt of edge, default = 15
//Bit 11: 8, reg_mcdi_chkedgeminedgethd.                  min drt of edge, default = 2
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_chkedgevdifthd.                     thd for vertical dif in check edge, default = 14
#define MCDI_CHK_EDGE_GAIN_OFFST                   0x2f0b
//Bit 31:24, reserved.
//Bit 23:20, reg_mcdi_chkedgedifthd1.                     thd1 for edge dif check (<=), default = 4
//Bit 19:16, reg_mcdi_chkedgedifthd0.                     thd0 for edge dif check (>=), default = 15
//Bit   :15, reserved.
//Bit 14:10, reg_mcdi_chkedgechklen.                      total check length for edge check, 1~24 (>0), default = 24
//Bit  9: 8, reg_mcdi_chkedgeedgesel.                     final edge select mode, 0: original start edge, 1: lpf start edge, 2: orignal start+end edge, 3: lpf start+end edge, default = 1
//Bit  7: 3, reg_mcdi_chkedgesaddstgain.                  distance gain for sad calc while getting edges, default = 4
//Bit     2, reg_mcdi_chkedgechkmode.                     edge used in check mode, 0: original edge, 1: lpf edge, defautl = 1
//Bit     1, reg_mcdi_chkedgestartedge.                   edge mode for start edge, 0: original edge, 1: lpf edge, defautl = 0
//Bit     0, reg_mcdi_chkedgeedgelpf.                     edge lpf mode, 0:[0,2,4,2,0], 1:[1,2,2,2,1], default = 0
#define MCDI_LMV_RT                                0x2f0c
//BIt 31:15, reserved
//Bit 14:12, reg_mcdi_lmvvalidmode                        valid mode for lmv calc., 100b: use char det, 010b: use flt, 001b: use hori flg
//Bit 11:10, reg_mcdi_lmvgainmvmode                       four modes of mv selection for lmv weight calucluation, default = 1
//                                                        0: cur(x-3), lst(x-1,x,x+1); 1: cur(x-4,x-3), lst(x,x+1); 2: cur(x-5,x-4,x-3), lst(x-1,x,x+1,x+2,x+3); 3: cur(x-6,x-5,x-4,x-3), lst(x-1,x,x+1,x+2);
//Bit  9,    reg_mcdi_lmvinitmode                         initial lmvs at first row of input field, 0: intial value = 0; 1: inital = 32 (invalid), default = 0
//Bit  8,    reserved
//Bit  7: 4, reg_mcdi_lmvrt0                              ratio of max mv, default = 5
//Bit  3: 0, reg_mcdi_lmvrt1                              ratio of second max mv, default = 5
#define MCDI_LMV_GAINTHD                           0x2f0d
//Bit 31:24, reg_mcdi_lmvvxmaxgain                        max gain of lmv weight, default = 96
//Bit 23,    reserved
//Bit 22:20, reg_mcdi_lmvdifthd0                          dif threshold 0 (<) for small lmv, default = 1
//Bit 19:17, reg_mcdi_lmvdifthd1                          dif threshold 1 (<) for median lmv, default = 2
//Bit 16:14, reg_mcdi_lmvdifthd2                          dif threshold 2 (<) for large lmv, default = 3
//Bit 13: 8, reg_mcdi_lmvnumlmt                           least/limit number of (total number - max0), default = 20
//Bit  7: 0, reg_mcdi_lmvfltthd                           flt cnt thd (<) for lmv, default = 9
#define MCDI_RPTMV_THD0                            0x2f0e
//Bit 31:25, reg_mcdi_rptmvslpthd2			  slope thd (>=) between i and i+3/i-3 (i+4/i-4), default = 64
//Bit 24:20, reg_mcdi_rptmvslpthd1                        slope thd (>=) between i and i+2/i-2, default = 4
//Bit 19:10, reg_mcdi_rptmvampthd2                        amplitude thd (>=) between max and min, when count cycles, default = 300
//Bit  9: 0, reg_mcdi_rptmvampthd1                        amplitude thd (>=) between average of max and min, default = 400
#define MCDI_RPTMV_THD1                            0x2f0f
//Bit 31:28, reserved
//Bit 27:25, reg_mcdi_rptmvcyccntthd                      thd (>=) of total cycles count, default = 2
//Bit 24:21, reg_mcdi_rptmvcycdifthd                      dif thd (<) of cycles length, default = 3
//Bit 20:18, reg_mcdi_rptmvcycvldthd                      thd (>) of valid cycles number, default = 1
//Bit 17:15, reg_mcdi_rptmvhalfcycminthd                  min length thd (>=) of half cycle, default = 2
//Bit 14:11, reg_mcdi_rptmvhalfcycdifthd                  neighboring half cycle length dif thd (<), default = 5
//Bit 10: 8, reg_mcdi_rptmvminmaxcntthd                   least number of valid max and min, default = 2
//Bit  7: 5, reg_mcdi_rptmvcycminthd                      min length thd (>=) of cycles, default = 2
//Bit  4: 0, reg_mcdi_rptmvcycmaxthd                      max length thd (<) of cycles, default = 17
#define MCDI_RPTMV_THD2                            0x2f10
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_rptmvhdifthd0                       higher hdif thd (>=) (vertical edge) for rpt detection, default = 8
//Bit 15: 8, reg_mcdi_rptmvhdifthd1                       hdif thd (>=) (slope edge) for rpt detection, default = 4
//Bit  7: 0, reg_mcdi_rptmvvdifthd                        vdif thd (>=) (slope edge) for rpt detection, default = 1
#define MCDI_RPTMV_SAD                             0x2f11
//Bit 31:26, reserved
//Bit 25:16, reg_mcdi_rptmvsaddifthdgain                  7x3x(16/16), gain for sad dif thd in rpt mv detection, 0~672, normalized 16 as '1', default = 336
//Bit 15:10, reserved
//Bit  9: 0, reg_mcdi_rptmvsaddifthdoffst                 offset for sad dif thd in rpt mv detection, -512~511, default = 16
#define MCDI_RPTMV_FLG                             0x2f12
//Bit 31:18,  reserved                                    
//Bit 17:16,  reg_mcdi_rptmvmode                          select mode of mvs for repeat motion estimation, 0: hmv, 1: qmv/2, 2 or 3: qmv/4, default = 2
//Bit 15: 8,  reg_mcdi_rptmvflgcntthd                     thd (>=) of min count number for rptmv of whole field, for rptmv estimation, default = 64
//Bit  7: 5,  reserved
//Bit  4: 0,  reg_mcdi_rptmvflgcntrt                      4/32, ratio for repeat mv flag count, normalized 32 as '1', set 31 to 32, 
#define MCDI_RPTMV_GAIN                            0x2f13
//Bit 31:24, reg_mcdi_rptmvlftgain                        up repeat mv gain for hme, default = 96
//Bit 23:16, reg_mcdi_rptmvuplftgain                      up left repeat mv gain for hme, default = 32
//Bit 15: 8, reg_mcdi_rptmvupgain                         up repeat mv gain for hme, default = 64
//Bit  7: 0, reg_mcdi_rptmvuprightgain                    up right repeat mv gain for hme, default = 32
#define MCDI_GMV_RT                                0x2f14
//Bit 31,    reserved
//Bit 30:24, reg_mcdi_gmvmtnrt0                           ratio 0 for motion senario, set 127 to 128, normalized 128 as '1', default =32
//Bit 23,    reserved
//Bit 22:16, reg_mcdi_gmvmtnrt1                           ratio 1 for motion senario, set 127 to 128, normalized 128 as '1', default = 56
//Bit 15,    reserved
//Bit 14: 8, reg_mcdi_gmvstlrt0                           ratio 0 for still senario, set 127 to 128, normalized 128 as '1', default = 56
//Bit  7,    reserved
//Bit  6: 0, reg_mcdi_gmvstlrt1                           ratio 1 for still senario, set 127 to 128, normalized 128 as '1', default = 80
#define MCDI_GMV_GAIN                              0x2f15
//Bit 31:25, reg_mcdi_gmvzeromvlockrt0                    ratio 0 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 100
//Bit 24:18, reg_mcdi_gmvzeromvlockrt1                    ratio 1 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 112
//Bit 17:16, reg_mcdi_gmvvalidmode                        valid mode for gmv calc., 10b: use flt, 01b: use hori flg, default = 3
//Bit 15: 8, reg_mcdi_gmvvxgain                           gmv's vx gain when gmv locked for hme, default = 0
//Bit  7: 0, reg_mcdi_gmvfltthd                           flat thd (<) for gmv calc. default = 3
#define MCDI_HOR_SADOFST                           0x2f16
//Bit 31:25, reserved
//Bit 24:16, reg_mcdi_horsaddifthdgain                    21*1/8, gain/divisor for sad dif threshold in hor line detection, normalized 8 as '1', default = 21
//Bit 15: 8, reg_mcdi_horsaddifthdoffst                   offset for sad dif threshold in hor line detection, -128~127, default = 0
//Bit  7: 0, reg_mcdi_horvdifthd                          threshold (>=) of vertical dif of next block for horizontal line detection, default = 24
#define MCDI_REF_MV_NUM                            0x2f17
//Bit 31: 2, reserved
//Bit  1: 0, reg_mcdi_refmcmode.         motion compensated mode used in refinement, 0: pre, 1: next, 2: (pre+next)/2, default = 0
#define MCDI_REF_BADW_THD_GAIN                     0x2f18
//Bit 31:28, reserved 
//Bit 27:24, reg_mcdi_refbadwcnt2gain.   gain for badwv count num==3, default = 6
//Bit 23:20, reg_mcdi_refbadwcnt1gain.   gain for badwv count num==2, default = 3
//Bit 19:16, reg_mcdi_refbadwcnt0gain.   gain for badwv count num==1, default = 1
//Bit 15:12, reg_mcdi_refbadwthd3.       threshold 3 for detect badweave with largest average luma, default = 4
//Bit 11: 8, reg_mcdi_refbadwthd2.       threshold 2 for detect badweave with third smallest average luma, default = 3
//Bit  7: 4, reg_mcdi_refbadwthd1.       threshold 1 for detect badweave with second smallest average luma, default = 2
//Bit  3: 0, reg_mcdi_refbadwthd0.       threshold 0 for detect badweave with smallest average luma, default = 1
#define MCDI_REF_BADW_SUM_GAIN                     0x2f19
//Bit 31:13, reserved
//Bit 12: 8, reg_mcdi_refbadwsumgain0.   sum gain for r channel, 0~16, default = 8
//Bit  7: 5, reserved
//Bit     4, reg_mcdi_refbadwcalcmode.   mode for badw calculation, 0:sum, 1:max, default = 0
//Bit  3: 0, reserved
#define MCDI_REF_BS_THD_GAIN                       0x2f1a
//Bit 31:28, reg_mcdi_refbsudgain1.      up & down block stregth gain1, normalized to 8 as '1', default = 2
//Bit 27:24, reg_mcdi_refbsudgain0.      up & down block stregth gain0, normalized to 8 as '1', default = 4
//Bit 23:19, reserved
//Bit 18:16, reg_mcdi_refbslftgain.      left block strength gain, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_refbsthd1.         threshold 1 for detect block stregth in refinment, default = 16
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_refbsthd0.         threshold 0 for detect block stregth in refinment, default = 8
#define MCDI_REF_ERR_GAIN0                         0x2f1b
//Bit    31, reserved
//Bit 30:24, reg_mcdi_referrnbrdstgain.            neighoring mv distances gain for err calc. in ref, normalized to 8 as '1', default = 48
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_referrbsgain.                bs gain for err calc. in ref, normalized to 8 as '1', default = 4
//Bit    15, reserved
//Bit 14: 8, reg_mcdi_referrbadwgain.              badw gain for err calc. in ref, normalized to 8 as '1', default = 64
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_referrsadgain.               sad gain for err calc. in ref, normalized to 8 as '1', default = 4
#define MCDI_REF_ERR_GAIN1                         0x2f1c
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_referrchkedgegain.           check edge gain for err calc. in ref, normalized to 8 as '1', default = 4
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_referrlmvgain.               (locked) lmv gain for err calc. in ref, normalized to 8 as '1', default = 0
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_referrgmvgain.               (locked) gmv gain for err calc. in ref, normalized to 8 as '1', default = 0
#define MCDI_REF_ERR_FRQ_CHK                       0x2f1d
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_referrfrqgain.               gain for mv frquency, normalized to 4 as '1', default = 10
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_referrfrqmax.                max gain for mv frquency check, default = 31
//Bit    15, reserved
//Bit 14:12, reg_mcdi_ref_errfrqmvdifthd2.         mv dif threshold 2 (<) for mv frquency check, default = 3
//Bit    11, reserved
//Bit 10: 8, reg_mcdi_ref_errfrqmvdifthd1.         mv dif threshold 1 (<) for mv frquency check, default = 2
//Bit     7, reserved
//Bit  6: 4, reg_mcdi_ref_errfrqmvdifthd0.         mv dif threshold 0 (<) for mv frquency check, default = 1
//Bit  3: 0, reserved
#define MCDI_QME_LPF_MSK                           0x2f1e
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_qmechkedgelpfmsk0.           lpf mask0 for chk edge in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_qmebslpfmsk0.                lpf mask0 for bs in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_qmebadwlpfmsk0.              lpf mask0 for badw in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_qmesadlpfmsk0.               lpf mask0 for sad in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
#define MCDI_REL_DIF_THD_02                        0x2f1f
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldifthd2.                  thd (<) for (hdif+vdif), default = 9
//Bit 15: 8, reg_mcdi_reldifthd1.                  thd (<) for (vdif), default = 5
//Bit  7: 0, reg_mcdi_reldifthd0.                  thd (>=) for (hdif-vdif), default = 48
#define MCDI_REL_DIF_THD_34                        0x2f20
//Bit 31:16, reserved.
//Bit 15: 8, reg_mcdi_reldifthd4.                  thd (<) for (hdif), default = 255
//Bit  7: 0, reg_mcdi_reldifthd3.                  thd (>=) for (vdif-hdif), default = 48
#define MCDI_REL_BADW_GAIN_OFFST_01                0x2f21
//Bit 31:24, reg_mcdi_relbadwoffst1.               offset for badw adj, for flat block, -128~127, default = 0
//Bit 23:16, reg_mcdi_relbadwgain1.                gain for badw adj, for flat block, default = 128
//Bit 15: 8, reg_mcdi_relbadwoffst0.               offset for badw adj, for vertical block, -128~127, default = 0
//Bit  7: 0, reg_mcdi_relbadwgain0.                gain for badw adj, for vertical block, default = 160
#define MCDI_REL_BADW_GAIN_OFFST_23                0x2f22
//Bit 31:24, reg_mcdi_relbadwoffst3.               offset for badw adj, for other block, -128~127, default = 0
//Bit 23:16, reg_mcdi_relbadwgain3.                gain for badw adj, for other block, default = 48
//Bit 15: 8, reg_mcdi_relbadwoffst2.               offset for badw adj, for horizontal block, -128~127, default = 0
//Bit  7: 0, reg_mcdi_relbadwgain2.                gain for badw adj, for horizontal block, default = 48
#define MCDI_REL_BADW_THD_GAIN_OFFST               0x2f23
//Bit 31:23, reserved.
//Bit 22:16, reg_mcdi_relbadwoffst.                offset for badw thd adj, -64~63, default = 0
//Bit 15: 8, reserved.
//Bit  7: 0, reg_mcdi_relbadwthdgain.              gain0 for badw thd adj, normalized to 16 as '1', default = 16
#define MCDI_REL_BADW_THD_MIN_MAX                  0x2f24
//Bit 31:18, reserved.
//Bit 17: 8, reg_mcdi_relbadwthdmax.               max for badw thd adj, default = 256
//Bit  7: 0, reg_mcdi_relbadwthdmin.               min for badw thd adj, default = 16
#define MCDI_REL_SAD_GAIN_OFFST_01                 0x2f25
//Bit 31:24, reg_mcdi_relsadoffst1.                offset for sad adj, for flat block, -128~127, default = 0
//Bit 23:20, reserved.
//Bit 19:16, reg_mcdi_relsadgain1.                 gain for sad adj, for flat block, normalized to 8 as '1', default = 8
//Bit 15: 8, reg_mcdi_relsadoffst0.                offset for sad adj, for vertical block, -128~127, default = 0
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_relsadgain0.                 gain for sad adj, for vertical block, normalized to 8 as '1', default = 6
#define MCDI_REL_SAD_GAIN_OFFST_23                 0x2f26
//Bit 31:24, reg_mcdi_relsadoffst3.                offset for sad adj, for other block, -128~127, default = 0
//Bit 23:20, reserved.
//Bit 19:16, reg_mcdi_relsadgain3.                 gain for sad adj, for other block, normalized to 8 as '1', default = 8
//Bit 15: 8, reg_mcdi_relsadoffst2.                offset for sad adj, for horizontal block, -128~127, default = 0
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_relsadgain2.                 gain for sad adj, for horizontal block, normalized to 8 as '1', default = 12
#define MCDI_REL_SAD_THD_GAIN_OFFST                0x2f27
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_relsadoffst.                 offset for sad thd adj, -128~127, default = 0
//Bit 15:10, reserved.
//Bit  9: 0, reg_mcdi_relsadthdgain.               gain for sad thd adj, 21*2/16, normalized to 16 as '1', default = 42
#define MCDI_REL_SAD_THD_MIN_MAX                   0x2f28
//Bit 31:27, reserved.
//Bit 26:16, reg_mcdi_relsadthdmax.                max for sad thd adj, 21*32, default = 672
//Bit 15: 9, reserved.
//Bit  8: 0, reg_mcdi_relsadthdmin.                min for sad thd adj, 21*2, default = 42
#define MCDI_REL_DET_GAIN_00                       0x2f29
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain0.               gain0 (gmv locked) for bs, for det. calc. normalized to 16 as '1', default = 8
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain0.             gain0 (gmv locked) for badw, for det. calc. normalized to 16 as '1', default = 12
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain0.              gain0 (gmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
#define MCDI_REL_DET_GAIN_01                       0x2f2a
//Bit 31:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain0.          gain0 (gmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 2
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain0.           gain0 (gmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
#define MCDI_REL_DET_GAIN_10                       0x2f2b
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain1.               gain1 (lmv locked) for bs, for det. calc. normalized to 16 as '1', default = 0
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain1.             gain1 (lmv locked) for badw, for det. calc. normalized to 16 as '1', default = 8
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain1.              gain1 (lmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
#define MCDI_REL_DET_GAIN_11                       0x2f2c
//Bit 31:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain1.          gain1 (lmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 0
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain1.           gain1 (lmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
#define MCDI_REL_DET_GAIN_20                       0x2f2d
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain2.               gain2 (no locked) for bs, for det. calc. normalized to 16 as '1', default = 12
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain2.             gain2 (no locked) for badw, for det. calc. normalized to 16 as '1', default = 32
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain2.              gain2 (no locked) for qsad, for det. calc. normalized to 16 as '1', default = 16
#define MCDI_REL_DET_GAIN_21                       0x2f2e
//Bit 31:26, reserved
//Bit 25:16, reg_mcdi_reldetoffst.                 offset for rel calculation, for det. calc. -512~511,  default = 0
//Bit 15:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain2.          gain2 (no locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 10
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain2.           gain2 (no locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 32
#define MCDI_REL_DET_GMV_DIF_CHK                   0x2f2f
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldetgmvfltthd.             flat thd (>=) for gmv lock decision, default = 0
//Bit    15, reserved.
//Bit 14:12, reg_mcdi_reldetgmvdifthd.             dif thd (>=) for current mv different from gmv for gmv dif check, actually used in Lmv lock check, default = 3
//Bit    11, reserved.
//Bit 10: 8, reg_mcdi_reldetgmvdifmin.             min mv dif for gmv dif check, default = 1, note: dif between reg_mcdi_rel_det_gmv_dif_max and reg_mcdi_rel_det_gmv_dif_min should be; 0,1,3,7, not work for others 
//Bit  7: 4, reg_mcdi_reldetgmvdifmax.             max mv dif for gmv dif check, default = 4
//Bit  3: 1, reserved
//Bit     0, reg_mcdi_reldetgmvdifmvmode.          mv mode used for gmv dif check, 0: use refmv, 1: use qmv, default = 0
#define MCDI_REL_DET_LMV_DIF_CHK                   0x2f30
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldetlmvfltthd.             flat thd (>=) for lmv lock decision, default = 12
//Bit 15:14, reserved.
//Bit 13:12, reg_mcdi_reldetlmvlockchkmode.        lmv lock check mode, 0:cur Lmv, 1: cur & (last | next), 2: last & cur & next Lmv, default = 1
//Bit    11, reserved.
//Bit 10: 8, reg_mcdi_reldetlmvdifmin.             min mv dif for lmv dif check, default = 1, note: dif between reg_mcdi_rel_det_lmv_dif_max and reg_mcdi_rel_det_lmv_dif_min should be; 0,1,3,7, not work for others 
//Bit  7: 4, reg_mcdi_reldetlmvdifmax.             max mv dif for lmv dif check, default = 4
//Bit  3: 1, reserved
//Bit     0, reg_mcdi_reldetlmvdifmvmode.          mv mode used for lmv dif check, 0: use refmv, 1: use qmv, default = 0
#define MCDI_REL_DET_FRQ_CHK                       0x2f31
//Bit 31:12, reserved.
//Bit 11: 8, reg_mcdi_reldetfrqgain.               gain for frequency check, normalized to 4 as '1', default = 10
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetfrqmax.                max value for frequency check, default = 31
#define MCDI_REL_DET_PD22_CHK                      0x2f32
//Bit 31:18, reserved.
//Bit 17: 8, reg_mcdi_reldetpd22chkoffst.          offset for pd22 check happened, default = 512
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetpd22chkgain.           gain for pd22 check happened, normalized to 8 as '1', default = 12
#define MCDI_REL_DET_RPT_CHK_ROW                   0x2f33
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_reldetrptchkendrow.          end row (<) number for repeat check, default = 2047
//Bit 15:11, reserved
//Bit 10: 0, reg_mcdi_reldetrptchkstartrow.        start row (>=) number for repeat check, default = 0
#define MCDI_REL_DET_RPT_CHK_GAIN_QMV              0x2f34
//Bit 31:30, reserved
//Bit 29:24, reg_mcdi_reldetrptchkqmvmax.          max thd (<) of abs qmv for repeat check, default = 15, note that quarter mv's range is -63~63
//Bit 23:22, reserved
//Bit 21:16, reg_mcdi_reldetrptchkqmvmin.          min thd (>=) of abs qmv for repeat check, default = 10, note that quarter mv's range is -63~63
//Bit    15, reserved/
//Bit 14: 4, reg_mcdi_reldetrptchkoffst.           offset for repeat check, default = 512
//Bit  3: 0, reg_mcdi_reldetrptchkgain.            gain for repeat check, normalized to 8 as '1', default = 4
#define MCDI_REL_DET_RPT_CHK_THD_0                 0x2f35
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_reldetrptchkzerosadthd.      zero sad thd (<) for repeat check, default = 255
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetrptchkzerobadwthd.     zero badw thd (>=) for repeat check, default = 16
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_reldetrptchkfrqdifthd.       frequency dif thd (<) for repeat check, 0~10, default = 5
#define MCDI_REL_DET_RPT_CHK_THD_1                 0x2f36
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_reldetrptchkvdifthd.         vertical dif thd (<) for repeat check, default = 16
//Bit  7: 0, reg_mcdi_reldetrptchkhdifthd.         horizontal dif thd (>=) for repeat check, default = 16
#define MCDI_REL_DET_LPF_DIF_THD                   0x2f37
//Bit 31:24, reg_mcdi_reldetlpfdifthd3.            hdif thd (<) for lpf selection of horizontal block, default = 9
//Bit 23:16, reg_mcdi_reldetlpfdifthd2.            vdif-hdif thd (>=) for lpf selection of horizontal block, default = 48
//Bit 15: 8, reg_mcdi_reldetlpfdifthd1.            vdif thd (<) for lpf selection of vertical block, default = 9
//Bit  7: 0, reg_mcdi_reldetlpfdifthd0.            hdif-vdif thd (>=) for lpf selection of vertical block, default = 48
#define MCDI_REL_DET_LPF_MSK_00_03                 0x2f38
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk03.              det lpf mask03 for gmv/lmv locked mode, 0~16, default = 1
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk02.              det lpf mask02 for gmv/lmv locked mode, 0~16, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk01.              det lpf mask01 for gmv/lmv locked mode, 0~16, default = 5
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk00.              det lpf mask00 for gmv/lmv locked mode, 0~16, default = 8
#define MCDI_REL_DET_LPF_MSK_04_12                 0x2f39
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk12.              det lpf mask12 for vertical blocks, 0~16, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk11.              det lpf mask11 for vertical blocks, 0~16, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk10.              det lpf mask10 for vertical blocks, 0~16, default = 16
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk04.              det lpf mask04 for gmv/lmv locked mode, 0~16, default = 1
#define MCDI_REL_DET_LPF_MSK_13_21                 0x2f3a
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk21.              det lpf mask21 for horizontal blocks, 0~16, default = 6
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk20.              det lpf mask20 for horizontal blocks, 0~16, default = 8
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk14.              det lpf mask14 for vertical blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk13.              det lpf mask13 for vertical blocks, 0~16, default = 0
#define MCDI_REL_DET_LPF_MSK_22_30                 0x2f3b
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk30.              det lpf mask30 for other blocks, 0~16, default = 16
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk24.              det lpf mask24 for horizontal blocks, 0~16, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk23.              det lpf mask23 for horizontal blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk22.              det lpf mask22 for horizontal blocks, 0~16, default = 1
#define MCDI_REL_DET_LPF_MSK_31_34                 0x2f3c
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk34.              det lpf mask34 for other blocks, 0~16, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk33.              det lpf mask33 for other blocks, 0~16, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk32.              det lpf mask32 for other blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk31.              det lpf mask31 for other blocks, 0~16, default = 0
//Note: there are four group lpf masks from addr 37~3b, each group sum equal to 16.
#define MCDI_REL_DET_MIN                           0x2f3d
//Bit 31: 7, reserved
//Bit  6: 0, reg_mcdi_reldetmin.                   min of detected value, default = 16
#define MCDI_REL_DET_LUT_0_3                       0x2f3e
//Bit 31:24, reg_mcdi_reldetmaplut3.               default = 8
//Bit 23:16, reg_mcdi_reldetmaplut2.               default = 4
//Bit 15: 8, reg_mcdi_reldetmaplut1.               default = 2
//Bit  7: 0, reg_mcdi_reldetmaplut0.               default = 0
#define MCDI_REL_DET_LUT_4_7                       0x2f3f
//Bit 31:24, reg_mcdi_reldetmaplut7.               default = 64
//Bit 23:16, reg_mcdi_reldetmaplut6.               default = 48
//Bit 15: 8, reg_mcdi_reldetmaplut5.               default = 32
//Bit  7: 0, reg_mcdi_reldetmaplut4.               default = 16
#define MCDI_REL_DET_LUT_8_11                      0x2f40
//Bit 31:24, reg_mcdi_reldetmaplut11.              default = 160
//Bit 23:16, reg_mcdi_reldetmaplut10.              default = 128
//Bit 15: 8, reg_mcdi_reldetmaplut9.               default = 96
//Bit  7: 0, reg_mcdi_reldetmaplut8.               default = 80
#define MCDI_REL_DET_LUT_12_15                     0x2f41
//Bit 31:24, reg_mcdi_reldetmaplut15.              default = 255
//Bit 23:16, reg_mcdi_reldetmaplut14.              default = 240
//Bit 15: 8, reg_mcdi_reldetmaplut13.              default = 224
//Bit  7: 0, reg_mcdi_reldetmaplut12.              default = 192
#define MCDI_REL_DET_COL_CFD_THD                   0x2f42
//Bit 31:24, reg_mcdi_reldetcolcfdfltthd.          thd for flat smaller than (<) of column cofidence, default = 5
//Bit 23:16, reg_mcdi_reldetcolcfdthd1.            thd for rel larger than (>=) in rel calc. mode col confidence without gmv locking, default = 160
//Bit 15: 8, reg_mcdi_reldetcolcfdthd0.            thd for rel larger than (>=) in rel calc. mode col confidence when gmv locked, default = 100
//Bit  7: 2, reg_mcdi_reldetcolcfdbadwthd.         thd for badw larger than (>=) in qbadw calc. mode of column cofidence, default = 16
//Bit     1, reserved
//Bit     0, reg_mcdi_reldetcolcfdcalcmode.        calc. mode for column cofidence, 0: use rel, 1: use qbadw, default = 0
#define MCDI_REL_DET_COL_CFD_AVG_LUMA              0x2f43
//Bit 31:24, reg_mcdi_reldetcolcfdavgmin1.         avg luma min1 (>=) for column cofidence, valid between 16~235, default = 235
//Bit 23:16, reg_mcdi_reldetcolcfdavgmax1.         avg luma max1 (<)  for column cofidence, valid between 16~235, default = 235
//Bit 15: 8, reg_mcdi_reldetcolcfdavgmin0.         avg luma min0 (>=) for column cofidence, valid between 16~235, default = 16
//Bit  7: 0, reg_mcdi_reldetcolcfdavgmax0.         avg luma max0 (<)  for column cofidence, valid between 16~235, default = 21
#define MCDI_REL_DET_BAD_THD_0                     0x2f44
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_reldetbadsadthd.             thd (>=) for bad sad, default = 120 (480/4)
//Bit  7: 6, reserved
//Bit  5: 0, reg_mcdi_reldetbadbadwthd.            thd (>=) for bad badw, 0~42, default = 12
#define MCDI_REL_DET_BAD_THD_1                     0x2f45
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_reldetbadrelfltthd.          thd (>=) of flat for bad rel detection, default = 4
//Bit 15: 8, reg_mcdi_reldetbadrelthd1.            thd (>=) for bad rel without gmv/lmv locked, default = 160
//Bit  7: 0, reg_mcdi_reldetbadrelthd0.            thd (>=) for bad rel with gmv/lmv locked, default = 120
#define MCDI_PD22_CHK_THD                          0x2f46
//Bit 31:25, reserved
//Bit 24:16, reg_mcdi_pd22chksaddifthd.            sad dif thd (>=) for (pd22chksad - qsad) for pd22 check, default = 64
//Bit 15:14, reserved
//Bit 13: 8, reg_mcdi_pd22chkqmvthd.               thd (>=) of abs qmv for pd22 check, default = 2
//Bit  7: 0, reg_mcdi_pd22chkfltthd.               thd (>=) of flat for pd22 check, default = 4
#define MCDI_PD22_CHK_GAIN_OFFST_0                 0x2f47
//Bit 31:24, reg_mcdi_pd22chkedgeoffst0.           offset0 of pd22chkedge from right film22 phase, -128~127, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_pd22chkedgegain0.            gain0 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_pd22chkbadwoffst0.           offset0 of pd22chkbadw from right film22 phase, -8~7, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkbadwgain0.            gain0 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 8
#define MCDI_PD22_CHK_GAIN_OFFST_1                 0x2f48
//Bit 31:24, reg_mcdi_pd22chkedgeoffst1.           offset1 of pd22chkedge from right film22 phase, -128~127, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_pd22chkedgegain1.            gain1 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_pd22chkbadwoffst1.           offset1 of pd22chkbadw from right film22 phase, -8~7, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkbadwgain1.            gain1 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 12
#define MCDI_LMV_LOCK_CNT_THD_GAIN                 0x2f49
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_lmvlockcntmax.               max lmv lock count number, default = 6
//Bit 15:12, reg_mcdi_lmvlockcntoffst.             offset for lmv lock count, -8~7, default =  0
//Bit 11: 8, reg_mcdi_lmvlockcntgain.              gain for lmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_lmvlockcntthd.               lmv count thd (>=) before be locked, 1~31, default = 4 
#define MCDI_LMV_LOCK_ABS_DIF_THD                  0x2f4a
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_lmvlockdifthd2.              lmv dif thd for third part, before locked, default = 1
//Bit    23, reserved
//Bit 22:20, reg_mcdi_lmvlockdifthd1.              lmv dif thd for second part, before locked, default = 1
//Bit    19, reserved
//Bit 18:16, reg_mcdi_lmvlockdifthd0.              lmv dif thd for first part, before locked, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_lmvlockabsmax.               max abs (<) of lmv to be locked, default = 24 
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_lmvlockabsmin.               min abs (>=) of lmv to be locked, default = 1 
#define MCDI_LMV_LOCK_ROW                          0x2f4b
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_lmvlockendrow.               end row (<) for lmv lock, default = 2047
//Bit 15:11, reserved
//Bit 10: 0, reg_mcdi_lmvlockstartrow.             start row (>=) for lmv lock, default = 0
#define MCDI_LMV_LOCK_RT_MODE                      0x2f4c
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_lmvlockextmode.              extend lines for lmv lock check, check how many lines for lmv locking, default = 2
//Bit 23:16, reg_mcdi_lmvlockfltcntrt.             ratio of flt cnt for lock check, normalized 256 as '1', 255 is set to 256, default = 32
//Bit 15: 8, reg_mcdi_lmvlocklmvcntrt1.            ratio when use non-zero lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 48
//Bit  7: 0, reg_mcdi_lmvlocklmvcntrt0.            ratio when use max lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 106
#define MCDI_GMV_LOCK_CNT_THD_GAIN                 0x2f4d
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_gmvlockcntmax.               max gmv lock count number, default = 6
//Bit 15:12, reg_mcdi_gmvlockcntoffst.             offset for gmv lock count, -8~7, default =  0
//Bit 11: 8, reg_mcdi_gmvlockcntgain.              gain for gmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_gmvlockcntthd.               gmv count thd (>=) before be locked, 1~31, default = 4 
#define MCDI_GMV_LOCK_ABS_DIF_THD                  0x2f4e
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_gmvlockdifthd2.              gmv dif thd for third part, before locked, default = 3
//Bit    23, reserved
//Bit 22:20, reg_mcdi_gmvlockdifthd1.              gmv dif thd for second part, before locked, default = 2
//Bit    19, reserved
//Bit 18:16, reg_mcdi_gmvlockdifthd0.              gmv dif thd for first part, before locked, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_gmvlockabsmax.               max abs of gmv to be locked, default = 15 
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_gmvlockabsmin.               min abs of gmv to be locked, default = 1 
#define MCDI_HIGH_VERT_FRQ_DIF_THD                 0x2f4f
//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifthd.     high_vert_frq field average luma dif thd (>=), 3*Blk_Width*Blk_Height, set by software, default = 103680
#define MCDI_HIGH_VERT_FRQ_DIF_DIF_THD             0x2f50
//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifdifthd.  high_vert_frq field average luma dif's dif thd (<), 3*Blk_Width*Blk_Height, set by software, default = 103680
#define MCDI_HIGH_VERT_FRQ_RT_GAIN                 0x2f51
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_highvertfrqcntthd.           high_vert_frq count thd (>=) before locked, 1~31, default = 4
//Bit 15: 8, reg_mcdi_highvertfrqbadsadrt.         ratio for high_vert_frq bad sad count, normalized 256 as '1', 255 is set to 256, default = 24
//Bit  7: 0, reg_mcdi_highvertfrqbadbadwrt.        ratio for high_vert_frq badw count, normalized 256 as '1', 255 is set to 256, default = 130
#define MCDI_MOTION_PARADOX_THD                    0x2f52
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_motionparadoxcntthd.         motion paradox count thd (>=) before locked, 1~31, default = 4
//Bit 23:22, reserved
//Bit 21:16, reg_mcdi_motionparadoxgmvthd.         abs gmv thd (<) of motion paradox, 0~32, note that 32 means invalid gmv, be careful, default = 32 
//Bit 15: 0, reserved
#define MCDI_MOTION_PARADOX_RT                     0x2f53
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_motionparadoxbadsadrt.       ratio for field bad sad count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 24
//Bit 15: 8, reg_mcdi_motionparadoxbadrelrt.       ratio for field bad reliabilty count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 120
//Bit  7: 0, reg_mcdi_motionparadoxmtnrt.          ratio for field motion count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 218
#define MCDI_MOTION_REF_THD                        0x2f54
//Bit 31:24, reserved
//Bit 23:20, reg_mcdi_motionrefoffst.              motion ref additive offset, default = 15
//Bit 19:16, reg_mcdi_motionrefgain.               motion ref gain, normalized 8 as '1', default = 8
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_motionrefrptmvthd.           abs thd (>=) of rpt mv (0~31, 32 means invalid) for motion ref, default = 1
//Bit  7: 2, reg_mcdi_motionrefqmvthd.             min thd (>=) of abs qmv for motion ref, note that quarter mv's range is -63~63, default = 2
//Bit  1: 0, reg_mcdi_motionreflpfmode.            Mv and (8 x repeat flg) 's lpf mode of motion refinement, 0: no lpf, 1: [1 2 1], 2: [1 2 2 2 1], default = 1
#define MCDI_REL_COL_REF_RT                        0x2f55
//Bit 31: 8, reserved
//Bit  7: 0, reg_mcdi_relcolrefrt.                 ratio for column cofidence level against column number, for refinement, default = 135
#define MCDI_PD22_CHK_THD_RT                       0x2f56
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_pd22chkfltcntrt.             ratio for flat count of field pulldown 22 check, normalized 2048 as '1', 2047 is set to 2048, default = 1
//Bit 15: 8, reg_mcdi_pd22chkcntrt.                ratio of pulldown 22 check count, normalized 256 as '1', 255 is set to 256, default = 100
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkcntthd.               thd (>=) for pd22 count before locked, 1~31, default = 4
#define MCDI_CHAR_DET_DIF_THD                      0x2f57
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_chardetminmaxdifthd.         thd (>=) for dif between min and max value, default = 64
//Bit 15: 8, reg_mcdi_chardetmaxdifthd.            thd (<) for dif between max value, default = 17
//Bit  7: 0, reg_mcdi_chardetmindifthd.            thd (<) for dif between min value, default = 17
#define MCDI_CHAR_DET_CNT_THD                      0x2f58
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_chardettotcntthd.            thd (>=) for total count, 0~21, default = 18
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_chardetmaxcntthd.            thd (>=) for max count, 0~21, default = 1
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_chardetmincntthd.            thd (>=) for min count, 0~21, default = 1
#define MCDI_FIELD_MV                              0x2f60
//Bit 31:24, reg_mcdi_pd22chkcnt                   
//Bit 23:16, reg_mcdi_fieldgmvcnt
//Bit    15, reg_mcdi_pd22chkflg
//Bit    14, reg_mcdi_fieldgmvlock
//Bit 13: 8, reg_mcdi_fieldrptmv.    	           last field rpt mv 
//Bit  7: 6, reserved
//Bit  5: 0, reg_mcdi_fieldgmv.                    last field gmv 
#define MCDI_FIELD_HVF_PRDX_CNT                    0x2f61
//Bit 31:24, reg_mcdi_motionparadoxcnt.
//Bit 23:17, reserved
//Bit    16, reg_mcdi_motionparadoxflg.
//Bit 15: 8, reg_mcdi_highvertfrqcnt.    
//Bit  7: 4, reserved	          
//Bit  3: 2, reg_mcdi_highvertfrqphase.
//Bit     1, reserved
//Bit     0, reg_mcdi_highvertfrqflg.              
#define MCDI_FIELD_LUMA_AVG_SUM_0                  0x2f62
//Bit 31: 0, reg_mcdi_fld_luma_avg_sum0.           
#define MCDI_FIELD_LUMA_AVG_SUM_1                  0x2f63
//Bit 31: 0, reg_mcdi_fld_luma_avg_sum1.
#define MCDI_YCBCR_BLEND_CRTL                      0x2f64
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_ycbcrblendgain.              ycbcr blending gain for cbcr in ycbcr. default = 0
//Bit  7: 2, reserved.
//Bit  1: 0, reg_mcdi_ycbcrblendmode.              0:y+cmb(cb,cr), 1:med(r,g,b), 2:max(r,g,b), default = 2              
#define MCDI_MCVECWR_CANVAS_SIZE                   0x2f65
#define MCDI_MCVECRD_CANVAS_SIZE                   0x2f66
#define MCDI_MCINFOWR_CANVAS_SIZE                  0x2f67
#define MCDI_MCINFORD_CANVAS_SIZE                  0x2f68
#define MCDI_MCVECWR_X                             0x2f92
#define MCDI_MCVECWR_Y                             0x2f93
#define MCDI_MCVECWR_CTRL                          0x2f94
#define MCDI_MCVECRD_X                             0x2f95
#define MCDI_MCVECRD_Y                             0x2f96
#define MCDI_MCVECRD_CTRL                          0x2f97
#define MCDI_MCINFOWR_X                            0x2f98
#define MCDI_MCINFOWR_Y                            0x2f99
#define MCDI_MCINFOWR_CTRL                         0x2f9a
#define MCDI_MCINFORD_X                            0x2f9b
#define MCDI_MCINFORD_Y                            0x2f9c
#define MCDI_MCINFORD_CTRL                         0x2f9d
// ================================================================== MC registers ========================================================================================================
#define MCDI_MC_CRTL                               0x2f70
//Bit 31: 9, reserved
//Bit     8, reg_mcdi_mcpreflg.                    flag to use previous field for MC, 0:forward field, 1: previous field, default = 1 
//Bit     7, reg_mcdi_mcrelrefbycolcfden.          enable rel refinement by column cofidence in mc blending, default = 1
//Bit  6: 5, reg_mcdi_mclpfen.                     enable mc pixles/rel lpf, 0:disable, 1: lpf rel, 2: lpf mc pxls, 3: lpf both rel and mc pxls, default = 0
//Bit  4: 2, reg_mcdi_mcdebugmode.                 enable mc debug mode, 0:disable, 1: split left/right, 2: split top/bottom, 3: debug mv, 4: debug rel, default = 0
//Bit  1: 0, reg_mcdi_mcen.                        mcdi enable mode, 0:disable, 1: blend with ma, 2: full mc, default = 1
#define MCDI_MC_LPF_MSK_0                          0x2f71
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk02.                  mc lpf coef. 2 for pixel 0 of current block, normalized 16 as '1', default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk01.                  mc lpf coef. 1 for pixel 0 of current block, normalized 16 as '1', default = 9
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk00.                  mc lpf coef. 0 for pixel 0 of current block, normalized 16 as '1', default = 7
#define MCDI_MC_LPF_MSK_1                          0x2f72
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk12.                  mc lpf coef. 2 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk11.                  mc lpf coef. 1 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 11
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk10.                  mc lpf coef. 0 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 5
#define MCDI_MC_LPF_MSK_2                          0x2f73
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk22.                  mc lpf coef. 2 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk21.                  mc lpf coef. 1 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 14
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk20.                  mc lpf coef. 0 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
#define MCDI_MC_LPF_MSK_3                          0x2f74
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk32.                  mc lpf coef. 2 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 5
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk31.                  mc lpf coef. 1 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 11
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk30.                  mc lpf coef. 0 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 0
#define MCDI_MC_LPF_MSK_4                          0x2f75
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk42.                  mc lpf coef. 2 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 7
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk41.                  mc lpf coef. 1 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 9
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk40.                  mc lpf coef. 0 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 0
#define MCDI_MC_REL_GAIN_OFFST_0                   0x2f76
//Bit 31:26, reserved
//Bit    25, reg_mcdi_mcmotionparadoxflg.          flag of motion paradox, initial with 0 and read from software, default = 0
//Bit    24, reg_mcdi_mchighvertfrqflg.            flag of high vert frq, initial with 0 and read from software, default = 0
//Bit 23:16, reg_mcdi_mcmotionparadoxoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 128
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_mcmotionparadoxgain.         gain for rel (MC blending coef.) refinement if motion paradox detected before MC blending, normalized 8 as '1', set 15 to 16, default = 8
//Bit  7: 4, reg_mcdi_mchighvertfrqoffst.          minus offset (alpha - offset) for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, default = 15
//Bit  3: 0, reg_mcdi_mchighvertfrqgain.           gain for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, normalized 8 as '1', set 15 to 16, default = 8
#define MCDI_MC_REL_GAIN_OFFST_1                   0x2f77
//Bit 31:24, reg_mcdi_mcoutofboundrayoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending before MC blending, default = 255
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_mcoutofboundraygain.         gain for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending, normalized 8 as '1', set 15 to 16, default = 8
//Bit 15: 8, reg_mcdi_mcrelrefbycolcfdoffst.       offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 255
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_mcrelrefbycolcfdgain.        gain for rel (MC blending coef.) refinement if column cofidence failed before MC blending, normalized 8 as '1', set 15 to 16, default = 8
#define MCDI_MC_COL_CFD_0                          0x2f78
//Bit 31: 0, mcdi_mc_col_cfd_0.                    column cofidence value 0 read from software. initial = 0
#define MCDI_MC_COL_CFD_1                          0x2f79
//Bit 31: 0, mcdi_mc_col_cfd_1.                    column cofidence value 1 read from software. initial = 0
#define MCDI_MC_COL_CFD_2                          0x2f7a
//Bit 31: 0, mcdi_mc_col_cfd_2.                    column cofidence value 2 read from software. initial = 0
#define MCDI_MC_COL_CFD_3                          0x2f7b
//Bit 31: 0, mcdi_mc_col_cfd_3.                    column cofidence value 3 read from software. initial = 0
#define MCDI_MC_COL_CFD_4                          0x2f7c
//Bit 31: 0, mcdi_mc_col_cfd_4.                    column cofidence value 4 read from software. initial = 0
#define MCDI_MC_COL_CFD_5                          0x2f7d
//Bit 31: 0, mcdi_mc_col_cfd_5.                    column cofidence value 5 read from software. initial = 0
#define MCDI_MC_COL_CFD_6                          0x2f7e
//Bit 31: 0, mcdi_mc_col_cfd_6.                    column cofidence value 6 read from software. initial = 0
#define MCDI_MC_COL_CFD_7                          0x2f7f
//Bit 31: 0, mcdi_mc_col_cfd_7.                    column cofidence value 7 read from software. initial = 0
#define MCDI_MC_COL_CFD_8                          0x2f80
//Bit 31: 0, mcdi_mc_col_cfd_8.                    column cofidence value 8 read from software. initial = 0
#define MCDI_MC_COL_CFD_9                          0x2f81
//Bit 31: 0, mcdi_mc_col_cfd_9.                    column cofidence value 9 read from software. initial = 0
#define MCDI_MC_COL_CFD_10                         0x2f82
//Bit 31: 0, mcdi_mc_col_cfd_10.                   column cofidence value 10 read from software. initial = 0
#define MCDI_MC_COL_CFD_11                         0x2f83
//Bit 31: 0, mcdi_mc_col_cfd_11.                   column cofidence value 11 read from software. initial = 0
#define MCDI_MC_COL_CFD_12                         0x2f84
//Bit 31: 0, mcdi_mc_col_cfd_12.                   column cofidence value 12 read from software. initial = 0
#define MCDI_MC_COL_CFD_13                         0x2f85
//Bit 31: 0, mcdi_mc_col_cfd_13.                   column cofidence value 13 read from software. initial = 0
#define MCDI_MC_COL_CFD_14                         0x2f86
//Bit 31: 0, mcdi_mc_col_cfd_14.                   column cofidence value 14 read from software. initial = 0
#define MCDI_MC_COL_CFD_15                         0x2f87
//Bit 31: 0, mcdi_mc_col_cfd_15.                   column cofidence value 15 read from software. initial = 0
#define MCDI_MC_COL_CFD_16                         0x2f88
//Bit 31: 0, mcdi_mc_col_cfd_16.                   column cofidence value 16 read from software. initial = 0
#define MCDI_MC_COL_CFD_17                         0x2f89
//Bit 31: 0, mcdi_mc_col_cfd_17.                   column cofidence value 17 read from software. initial = 0
#define MCDI_MC_COL_CFD_18                         0x2f8a
//Bit 31: 0, mcdi_mc_col_cfd_18.                   column cofidence value 18 read from software. initial = 0
#define MCDI_MC_COL_CFD_19                         0x2f8b
//Bit 31: 0, mcdi_mc_col_cfd_19.                   column cofidence value 19 read from software. initial = 0
#define MCDI_MC_COL_CFD_20                         0x2f8c
//Bit 31: 0, mcdi_mc_col_cfd_20.                   column cofidence value 20 read from software. initial = 0
#define MCDI_MC_COL_CFD_21                         0x2f8d
//Bit 31: 0, mcdi_mc_col_cfd_21.                   column cofidence value 21 read from software. initial = 0
#define MCDI_MC_COL_CFD_22                         0x2f8e
//Bit 31: 0, mcdi_mc_col_cfd_22.                   column cofidence value 22 read from software. initial = 0
#define MCDI_MC_COL_CFD_23                         0x2f8f
//Bit 31: 0, mcdi_mc_col_cfd_23.                   column cofidence value 23 read from software. initial = 0
#define MCDI_MC_COL_CFD_24                         0x2f90
//Bit 31: 0, mcdi_mc_col_cfd_24.                   column cofidence value 24 read from software. initial = 0
#define MCDI_MC_COL_CFD_25                         0x2f91
//Bit 31: 0, mcdi_mc_col_cfd_25.                   column cofidence value 25 read from software. initial = 0
// ===================================================================================== PRE RO Registers ==========================================================================================
#define MCDI_RO_FLD_LUMA_AVG_SUM                   0x2fa0
//Bit 31: 0, ro_mcdi_fldlumaavgsum.                block's luma avg sum of current filed (block based). initial = 0
#define MCDI_RO_GMV_VLD_CNT                        0x2fa1
//Bit 31: 0, ro_mcdi_gmvvldcnt.                    valid gmv's count of pre one filed (block based). initial = 0
#define MCDI_RO_RPT_FLG_CNT                        0x2fa2
//Bit 31: 0, ro_mcdi_rptflgcnt.                    repeat mv's count of pre one filed (block based). initial = 0
#define MCDI_RO_FLD_BAD_SAD_CNT                    0x2fa3
//Bit 31: 0, ro_mcdi_fldbadsadcnt.                 bad sad count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_BAD_BADW_CNT                   0x2fa4
//Bit 31: 0, ro_mcdi_fldbadbadwcnt.                bad badw count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_BAD_REL_CNT                    0x2fa5
//Bit 31: 0, ro_mcdi_fldbadrelcnt.                 bad rel count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_MTN_CNT                        0x2fa6
//Bit 31: 0, ro_mcdi_fldmtncnt.                    motion count of whole pre one field (pixel based). initial = 0
#define MCDI_RO_FLD_VLD_CNT                        0x2fa7
//Bit 31: 0, ro_mcdi_fldvldcnt.                    valid motion count of whole pre one field (pixel based). initial = 0
#define MCDI_RO_FLD_PD_22_PRE_CNT                  0x2fa8
//Bit 31: 0, ro_mcdi_fldpd22precnt.                prevoius pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FOR_CNT                  0x2fa9
//Bit 31: 0, ro_mcdi_fldpd22forcnt.                forward pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FLT_CNT                  0x2faa
//Bit 31: 0, ro_mcdi_fldpd22fltcnt.                flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define MCDI_RO_HIGH_VERT_FRQ_FLG                  0x2fab
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_highvertfrqcnt.               high vertical frequency count till prevoius one field. initial = 0
//Bit  7: 3, reserved.
//Bit  2: 1, ro_mcdi_highvertfrqphase.             high vertical frequency phase of prevoius one field. initial = 2
//Bit     0, ro_mcdi_highvertfrqflg.               high vertical frequency flag of prevoius one field. initial = 0
#define MCDI_RO_GMV_LOCK_FLG                       0x2fac
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_gmvlckcnt.                    global mv lock count till prevoius one field. initial = 0
//Bit  7: 2, ro_mcdi_gmv.                          global mv of prevoius one field. -31~31, initial = 32 (invalid value)
//Bit     1, ro_mcdi_zerogmvlckflg.                zero global mv lock flag of prevoius one field. initial = 0
//Bit     0, ro_mcdi_gmvlckflg.                    global mv lock flag of prevoius one field. initial = 0
#define MCDI_RO_RPT_MV                             0x2fad
//Bit 5: 0, ro_mcdi_rptmv.                         repeate mv of prevoius one field. -31~31, initial = 32 (invalid value)
#define MCDI_RO_MOTION_PARADOX_FLG                 0x2fae
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_motionparadoxcnt.             motion paradox count till prevoius one field. initial = 0
//Bit  7: 1, reserved. 
//Bit     0, ro_mcdi_motionparadoxflg.             motion paradox flag of prevoius one field. initial = 0
#define MCDI_RO_PD_22_FLG                          0x2faf
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_pd22cnt.                      pull down 22 count till prevoius one field. initial = 0
//Bit  7: 1, reserved. 
//Bit     0, ro_mcdi_pd22flg.                      pull down 22 flag of prevoius one field. initial = 0
#define MCDI_RO_COL_CFD_0                          0x2fb0
//Bit 31: 0, ro_mcdi_col_cfd_0.                    column cofidence value 0. initial = 0
#define MCDI_RO_COL_CFD_1                          0x2fb1
//Bit 31: 0, ro_mcdi_col_cfd_1.                    column cofidence value 1. initial = 0
#define MCDI_RO_COL_CFD_2                          0x2fb2
//Bit 31: 0, ro_mcdi_col_cfd_2.                    column cofidence value 2. initial = 0
#define MCDI_RO_COL_CFD_3                          0x2fb3
//Bit 31: 0, ro_mcdi_col_cfd_3.                    column cofidence value 3. initial = 0
#define MCDI_RO_COL_CFD_4                          0x2fb4
//Bit 31: 0, ro_mcdi_col_cfd_4.                    column cofidence value 4. initial = 0
#define MCDI_RO_COL_CFD_5                          0x2fb5
//Bit 31: 0, ro_mcdi_col_cfd_5.                    column cofidence value 5. initial = 0
#define MCDI_RO_COL_CFD_6                          0x2fb6
//Bit 31: 0, ro_mcdi_col_cfd_6.                    column cofidence value 6. initial = 0
#define MCDI_RO_COL_CFD_7                          0x2fb7
//Bit 31: 0, ro_mcdi_col_cfd_7.                    column cofidence value 7. initial = 0
#define MCDI_RO_COL_CFD_8                          0x2fb8
//Bit 31: 0, ro_mcdi_col_cfd_8.                    column cofidence value 8. initial = 0
#define MCDI_RO_COL_CFD_9                          0x2fb9
//Bit 31: 0, ro_mcdi_col_cfd_9.                    column cofidence value 9. initial = 0
#define MCDI_RO_COL_CFD_10                         0x2fba
//Bit 31: 0, ro_mcdi_col_cfd_10.                   column cofidence value 10. initial = 0
#define MCDI_RO_COL_CFD_11                         0x2fbb
//Bit 31: 0, ro_mcdi_col_cfd_11.                   column cofidence value 11. initial = 0
#define MCDI_RO_COL_CFD_12                         0x2fbc
//Bit 31: 0, ro_mcdi_col_cfd_12.                   column cofidence value 12. initial = 0
#define MCDI_RO_COL_CFD_13                         0x2fbd
//Bit 31: 0, ro_mcdi_col_cfd_13.                   column cofidence value 13. initial = 0
#define MCDI_RO_COL_CFD_14                         0x2fbe
//Bit 31: 0, ro_mcdi_col_cfd_14.                   column cofidence value 14. initial = 0
#define MCDI_RO_COL_CFD_15                         0x2fbf
//Bit 31: 0, ro_mcdi_col_cfd_15.                   column cofidence value 15. initial = 0
#define MCDI_RO_COL_CFD_16                         0x2fc0
//Bit 31: 0, ro_mcdi_col_cfd_16.                   column cofidence value 16. initial = 0
#define MCDI_RO_COL_CFD_17                         0x2fc1
//Bit 31: 0, ro_mcdi_col_cfd_17.                   column cofidence value 17. initial = 0
#define MCDI_RO_COL_CFD_18                         0x2fc2
//Bit 31: 0, ro_mcdi_col_cfd_18.                   column cofidence value 18. initial = 0
#define MCDI_RO_COL_CFD_19                         0x2fc3
//Bit 31: 0, ro_mcdi_col_cfd_19.                   column cofidence value 19. initial = 0
#define MCDI_RO_COL_CFD_20                         0x2fc4
//Bit 31: 0, ro_mcdi_col_cfd_20.                   column cofidence value 20. initial = 0
#define MCDI_RO_COL_CFD_21                         0x2fc5
//Bit 31: 0, ro_mcdi_col_cfd_21.                   column cofidence value 21. initial = 0
#define MCDI_RO_COL_CFD_22                         0x2fc6
//Bit 31: 0, ro_mcdi_col_cfd_22.                   column cofidence value 22. initial = 0
#define MCDI_RO_COL_CFD_23                         0x2fc7
//Bit 31: 0, ro_mcdi_col_cfd_23.                   column cofidence value 23. initial = 0
#define MCDI_RO_COL_CFD_24                         0x2fc8
//Bit 31: 0, ro_mcdi_col_cfd_24.                   column cofidence value 24. initial = 0
#define MCDI_RO_COL_CFD_25                         0x2fc9
//Bit 31: 0, ro_mcdi_col_cfd_25.                   column cofidence value 25. initial = 0
// add space 8'hd0-8'hef
//
// Reading file:  dipd_regs.h
//
// synopsys translate_off
// synopsys translate_on
// using 8'he0-8'hef
#define DIPD_COMB_CTRL0                            0x2fd0
//Bit 31:0,								reg_pd_comb_ctrl0
#define DIPD_COMB_CTRL1                            0x2fd1
//Bit 31:0,								reg_pd_comb_ctrl1
#define DIPD_COMB_CTRL2                            0x2fd2
//Bit 31:0,								reg_pd_comb_ctrl2
#define DIPD_COMB_CTRL3                            0x2fd3
//Bit 31:0,								reg_pd_comb_ctrl3
#define DIPD_COMB_CTRL4                            0x2fd4
//Bit 31:0,								reg_pd_comb_ctrl4
#define DIPD_COMB_CTRL5                            0x2fd5
//Bit 31:0,								reg_pd_comb_ctrl5
#define DIPD_RO_COMB_0                             0x2fd6
//Bit 31:0,								ro_pd_comb_0
#define DIPD_RO_COMB_1                             0x2fd7
//Bit 31:0,								ro_pd_comb_1
#define DIPD_RO_COMB_2                             0x2fd8
//Bit 31:0,								ro_pd_comb_2
#define DIPD_RO_COMB_3                             0x2fd9
//Bit 31:0,								ro_pd_comb_3
#define DIPD_RO_COMB_4                             0x2fda
//Bit 31:0,								ro_pd_comb_4
#define DIPD_RO_COMB_5                             0x2fdb
//Bit 31:0,								ro_pd_comb_5
#define DIPD_RO_COMB_6                             0x2fdc
//Bit 31:0,								ro_pd_comb_6
#define DIPD_RO_COMB_7                             0x2fdd
//Bit 31:0,								ro_pd_comb_7
#define DIPD_RO_COMB_8                             0x2fde
//Bit 31:0,								ro_pd_comb_8
#define DIPD_RO_COMB_9                             0x2fdf
//Bit 31:0,								ro_pd_comb_9
#define DIPD_RO_COMB_10                            0x2fe0
//Bit 31:0,								ro_pd_comb_10
#define DIPD_RO_COMB_11                            0x2fe1
//Bit 31:0,								ro_pd_comb_11
#define DIPD_RO_COMB_12                            0x2fe2
//Bit 31:0,								ro_pd_comb_12
#define DIPD_RO_COMB_13                            0x2fe3
//Bit 31:0,								ro_pd_comb_13
#define DIPD_RO_COMB_14                            0x2fe4
//Bit 31:0,								ro_pd_comb_14
#define DIPD_RO_COMB_15                            0x2fe5
//Bit 31:0,								ro_pd_comb_15
#define DIPD_RO_COMB_16                            0x2fe6
//Bit 31:0,								ro_pd_comb_16
#define DIPD_RO_COMB_17                            0x2fe7
//Bit 31:0,								ro_pd_comb_17
#define DIPD_RO_COMB_18                            0x2fe8
//Bit 31:0,								ro_pd_comb_18
#define DIPD_RO_COMB_19                            0x2fe9
//Bit 31:0,								ro_pd_comb_19
#define DIPD_RO_COMB_20                            0x2fea
//Bit 31:0,								ro_pd_comb_20
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dipd_regs.h
//
// addr space 8'hf0-8'hff 
//
// Reading file:  nr3_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPPB_VCBUS_BASE = 0xfe
// -----------------------------------------------
// using 8'hf0-8'hff
#define NR3_MODE                                   0xfef0
//Bit    5,   reg_3dnr_nr3_vtxt_mode         ;
//Bit    4,   reg_3dnr_nr3_cbyy_ignor_coop   ; // u1: ignore coop condition for cbyy motion decision
//Bit    3,   reg_3dnr_nr3_ybyc_ignor_cnoop  ; // u1: ignore cnoop condition for ybyc motion decision
//Bit  2:0,   reg_3dnr_nr3_suremot_txt_mode  ; // u3: 0: cur, 1:p2; 2: (cur+p2)/2; 3/up: min(cur,p2)
#define NR3_COOP_PARA                              0xfef1
//Bit 21:20,   reg_3dnr_nr3_coop_mode         ; // u2  0 original pixel 1: [1 2 1]/4 lpf; 2: [1 2 2 2 1]/8; 3: 3x3 lpf
//Bit 19:16,   reg_3dnr_nr3_coop_ratio        ; // u4  cur and p2 color oop decision ratio:  (avg1<(MAX(sat0,sat2)*ratio/8 + ofst));	
//Bit 15:8,    reg_3dnr_nr3_coop_ofset        ; // s8  cur and p2 color oop decision ofst:  (avg1<(MAX(sat0,sat2)*ratio/8 + ofst));	
//Bit  7:0,    reg_3dnr_nr3_coop_sat_thrd     ; // u8  cur and p2 color oop decision min(sat0,sat1) threshold;		
#define NR3_CNOOP_GAIN                             0xfef2
//Bit 23:20,   reg_3dnr_nr3_cnoop_ratio0      ; // u4   cur and p2 color noop decision ratio0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));		
//Bit 19:16,   reg_3dnr_nr3_cnoop_ratio1      ; // u4	cur and p2 color noop decision ratio1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
//Bit 15:8,    reg_3dnr_nr3_cnoop_ofset0      ; // s8	cur and p2 color noop decision ofset0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
//Bit  7:0,    reg_3dnr_nr3_cnoop_ofset1      ; // s8   cur and p2 color noop decision ofset1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
#define NR3_YMOT_PARA                              0xfef3
//Bit    19,   reg_3dnr_nr3_ymot_only_en      ; // u1: enable signal for ignor chroma motion: (ytxt &coop)
//Bit    18,   reg_3dnr_nr3_ymot_only_cmtmode ; // u1: 0: cmot=ymot; 1: cmot = MIN(ymot, cmot)
//Bit 17:16,   reg_3dnr_nr3_ymot_only_txtmode ; // u2: 0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
//Bit 15:8,    reg_3dnr_nr3_ymot_only_txtthrd ; // u8: threshold to luma texture to decide use ymot only
//Bit  7:0,    reg_3dnr_nr3_ymot_only_motthrd ; // u8: threshold to luma motion to decide use ymot only
#define NR3_CMOT_PARA                              0xfef4
//Bit    19,   reg_3dnr_nr3_cmot_only_en      ; // u1: enable signal for ignor luma motion: (ctxt &cnoop)
//Bit    18,   reg_3dnr_nr3_cmot_only_ymtmode ; // u1: 0: ymot=cmot+ymot/4; 1: ymot = MIN(ymot, cmot)
//Bit 17:16,   reg_3dnr_nr3_cmot_only_txtmode ; // u2: 0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
//Bit 15:8,    reg_3dnr_nr3_cmot_only_txtthrd ; // u8: threshold to chroma texture to decide use cmot only
//Bit  7:0,    reg_3dnr_nr3_cmot_only_motthrd ; // u8: threshold to chroma motion to decide use cmot only
#define NR3_SUREMOT_YGAIN                          0xfef5
//Bit 31:24,   reg_3dnr_nr3_suremot_dec_yrate ; // u8: (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 23:16,   reg_3dnr_nr3_suremot_dec_yofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 15:8,    reg_3dnr_nr3_suremot_frc_ygain ; // u8: (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit  7:0,    reg_3dnr_nr3_suremot_frc_yofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
#define NR3_SUREMOT_CGAIN                          0xfef6
//Bit 31:24,   reg_3dnr_nr3_suremot_dec_crate ; // u8: (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 23:16,   reg_3dnr_nr3_suremot_dec_cofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 15:8,    reg_3dnr_nr3_suremot_frc_cgain ; // u8: (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit  7:0,    reg_3dnr_nr3_suremot_frc_cofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  nr3_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  mcdi_regs.h
//
//  VPU_VLOCK register    (16'h3000 - 16'h30ff)
//========================================================================
//`define VPU_VLOCK_VCBUS_BASE                   8'h30
//
// Reading file:  vpu_vlock_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// VPU_VLOCK 0x30  
// ----------------------------
// -----------------------------------------------
// CBUS_BASE:  VPU_VLOCK_VCBUS_BASE = 0x30
// -----------------------------------------------
#define VPU_VLOCK_CTRL                             0x3000
#define VPU_VLOCK_MISC_CTRL                        0x3001
#define VPU_VLOCK_LOOP0_ACCUM_LMT                  0x3002
#define VPU_VLOCK_LOOP0_CTRL0                      0x3003
#define VPU_VLOCK_LOOP1_CTRL0                      0x3004
#define VPU_VLOCK_LOOP1_IMISSYNC_MAX               0x3005
#define VPU_VLOCK_LOOP1_IMISSYNC_MIN               0x3006
#define VPU_VLOCK_OVWRITE_ACCUM0                   0x3007
#define VPU_VLOCK_OVWRITE_ACCUM1                   0x3008
#define VPU_VLOCK_OUTPUT0_CAPT_LMT                 0x3009
#define VPU_VLOCK_OUTPUT0_PLL_LMT                  0x300a
#define VPU_VLOCK_OUTPUT1_CAPT_LMT                 0x300b
#define VPU_VLOCK_OUTPUT1_PLL_LMT                  0x300c
#define VPU_VLOCK_LOOP1_PHSDIF_TGT                 0x300d
#define VPU_VLOCK_RO_LOOP0_ACCUM                   0x300e
#define VPU_VLOCK_RO_LOOP1_ACCUM                   0x300f
#define VPU_VLOCK_OROW_OCOL_MAX                    0x3010
#define VPU_VLOCK_RO_VS_I_DIST                     0x3011
#define VPU_VLOCK_RO_VS_O_DIST                     0x3012
#define VPU_VLOCK_RO_LINE_PIX_ADJ                  0x3013
#define VPU_VLOCK_RO_OUTPUT_00_01                  0x3014
#define VPU_VLOCK_RO_OUTPUT_10_11                  0x3015
#define VPU_VLOCK_MX4096                           0x3016
#define VPU_VLOCK_STBDET_WIN0_WIN1                 0x3017
#define VPU_VLOCK_STBDET_CLP                       0x3018
#define VPU_VLOCK_STBDET_ABS_WIN0                  0x3019
#define VPU_VLOCK_STBDET_ABS_WIN1                  0x301a
#define VPU_VLOCK_STBDET_SGN_WIN0                  0x301b
#define VPU_VLOCK_STBDET_SGN_WIN1                  0x301c
#define VPU_VLOCK_ADJ_EN_SYNC_CTRL                 0x301d
#define VPU_VLOCK_GCLK_EN                          0x301e
#define VPU_VLOCK_LOOP1_ACCUM_LMT                  0x301f
#define VPU_VLOCK_RO_M_INT_FRAC                    0x3020
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_vlock_reg.h
//
//`define VPPB_VCBUS_BASE                8'h31 
//
// Reading file:  srscl_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPPB_VCBUS_BASE = 0x31
// -----------------------------------------------
////=================================================================////
//// super scaler core 0
////=================================================================////
#define SRSCL0_HV_SIZEIN                           0x3100
//Bit 31:29, reserved  
//Bit 28:16, reg_srscl0_hsize               image horizontal size (number of cols)   default=1024 
//Bit 15:13, reserved                       
//Bit 12: 0, reg_srscl0_vsize               image vertical size   (number of rows)   default=1024
#define SRSCL0_CTRL_MODE                           0x3101
//Bit 31:15, reserved     
//Bit 14,    reg_srscl0_horz_outphs          phase for super-scalar output under xVx1H ration: 0: 0 phase, 1: 1/2 phase     default = 0
//Bit 13,    reg_srscl0_cmpmux_aft           u1: 0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB; default = 0
//Bit 12,    reg_srscl0_cmpmux_bef           u1: 0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR; default = 0
//Bit 11,    reg_srscl0_bic_norm             normalization of bicubical: 0: 128|128; 1: 64|64  default = 0
//Bit 10,    reg_srscl0_3dint_mode           option for line-by-line 3D cases     default = 0
//Bit 9,     reg_srscl0_3dint_hadj_cub       option for using cubic interpolation for horizontal adjacent pixels     default = 0
//Bit 8,     reg_srscl0_vert_outphs          phase for super-scalar output under 1Vx2H ration: 0: 0 phase, 1: 1/2 phase     default = 0
//Bit 7,     reg_srscl0_cuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
//Bit 6,     reg_srscl0_yuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
//Bit 5,     reg_srscl0_cuse_bic             inside demo window luma use bicubical interpolation 
//                                           0: demo window us SR scalar for chroma channel;  
//                                           1: demo window use Bi-cubic scalar for chroma channel        default = 0
//Bit 4,     reg_srscl0_yuse_bic             inside demo window luma use bicubical interpolation 
//                                           0: demo window us SR scalar for luma channel;  
//                                           1: demo window use Bi-cubic scalar for luma channel        default = 0
//Bit 3,     reg_srscl0_use_3lrln            Options to extend 3 lines low-resolution data to 5-lines for SR scalar, (for core_0):
//                                           0: normal working mode, using 5 lines 
//                                           1: extend effective 3 lines to 5 lines; (will be used in line-by-line 3D contents)         default = 
//Bit 2,     reg_srscl0_vert_ratio           Vertical scalar ratio of Super Scalar core_0;
//                                           0: 1x scale; 1: 2x scale;    default = 
//Bit 1,     reg_srscl0_hori_ratio           Horizontal scalar ratio of Super Scalar core_0;
//                                           0: 1x scale; 1: 2x scale;    default = 
//Bit 0,     reg_srscl0_enable               Enable of Super Scalar core_0: 
//                                           0: disable (bypass) 1: enable    default = 
#define SRSCL0_YBIC_HCOEF                          0x3102
//Bit 31:24, reg_srscl0_y_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                          Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl0_y_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl0_y_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl0_y_bic_hcoef0         the same as above; default=-8
#define SRSCL0_CBIC_HCOEF                          0x3103
//Bit 31:24, reg_srscl0_c_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl0_c_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl0_c_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl0_c_bic_hcoef0         the same as above; default=-8
#define SRSCL0_YBIC_VCOEF                          0x3104
//Bit 31:24, reg_srscl0_y_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl0_y_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl0_y_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl0_y_bic_vcoef0         the same as above; default=-8
#define SRSCL0_CBIC_VCOEF                          0x3105
//Bit 31:24, reg_srscl0_c_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl0_c_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl0_c_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl0_c_bic_vcoef0         the same as above; default=-8
#define SRSCL0_VAR_PARA                            0x3106
//Bit 31:26, reserved  
//Bit 25:24, reg_srscl0_var_adja_rs          Horizontal/vertical adjacent pixel noise normalized variance value right shift bits.  default= 2   
//Bit 23:16, reg_srscl0_var_adja             Horizontal/vertical adjacent pixel noise normalized variance value. 
//                                           Var2 = (2^(11+rs))/gain; default= 68
//Bit 15:10, reserved  
//Bit  9: 8, reg_srscl0_var_diag_rs          Diagonal pixel noise normalized variance value right shift bits. default= 3    
//Bit  7: 0, reg_srscl0_var_diag             Diagonal pixel noise normalized variance value. Var2 = (2^(11+rs))/gain; default= 68
#define SRSCL0_CONST_PARA                          0x3107
//Bit 31:16, reserved  
//Bit 15: 8, reg_srscl0_c_adja               Constant for d_adja calculation from wk_nrm; Normalize 128 as “1” default= 32     
//Bit  7: 0, reg_srscl0_c_diag               Constant for d_diag calculation from wk_nrm; Normalize 128 as “1” default= 32
#define SRSCL0_RKE_EXTWIN                          0x3108
//Bit 31:23, reserved  
//Bit 22:20, reg_srscl0_rke_extwin         Window size for Rke horizontal extension: Win_size = 2x+1 scope: 0~5;  default= 4
//Bit 19:16, reg_srscl0_rke_coring         Coring to Rke default= 10
//Bit 15:13, reserved  
//Bit 12: 8, reg_srscl0_rke_extwin_core    Coring to Rks before local window maximum value calculation     default= 10 
//Bit  7: 0, reg_srscl0_rke_extwin_rate    Rate to blender strength (gamma), gamma is used to blend local maximum Rke and current Rke; the rate is normalized to 16 as “1”  default= 12
#define SRSCL0_UK_GRAD2DDIAG_TH_RATE               0x3109
//reg_srscl0_uk_grad2ddiag (0 1 5 6)  Wk_nrm to d_diag mapping curve parameter for UK calculation:         
//Bit 31:24, reg_srscl0_uk_grad2ddiag_rate1 rate1, d_diag level trasition rate 2nd towards 3rd piece;   default = 20;
//Bit 23:16, reg_srscl0_uk_grad2ddiag_rate0 rate0, d_diag level trasition rate 2nd towards 1st piece;   default = 80;
//Bit 15: 8, reg_srscl0_uk_grad2ddiag_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
//Bit  7: 0, reg_srscl0_uk_grad2ddiag_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
#define SRSCL0_UK_GRAD2DDIAG_LIMIT                 0x310a
//reg_srscl0_uk_grad2ddiag (2 3 4)            
//Bit 31:24, reserved 
//Bit 23:16, reg_srscl0_uk_grad2ddiag_lv2   lev2, d_diag level limit for 3rd piece;   default = 128;
//Bit 15: 8, reg_srscl0_uk_grad2ddiag_lv1   lev1, d_diag level limit for 2nd piece;   default = 128;
//Bit  7: 0, reg_srscl0_uk_grad2ddiag_lv0   lev0, d_diag level limit for 1st piece;   default = 128;
#define SRSCL0_UK_GRAD2DADJA_TH_RATE               0x310b
//reg_srscl0_uk_grad2adja (0 1 5 6)  Wk_nrm to d_adja mapping curve parameter for UK calculation:         
//Bit 31:24, reg_srscl0_uk_grad2dadja_rate1 rate1, d_adja level trasition rate 2nd towards 3rd piece;   default = 20;
//Bit 23:16, reg_srscl0_uk_grad2dadja_rate0 rate0, d_adja level trasition rate 2nd towards 1st piece;   default = 80;
//Bit 15: 8, reg_srscl0_uk_grad2dadja_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
//Bit  7: 0, reg_srscl0_uk_grad2dadja_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
#define SRSCL0_UK_GRAD2DADJA_LIMIT                 0x310c
//reg_srscl0_uk_grad2dadja (2 3 4)            
//Bit 31:24, reserved    
//Bit 23:16, reg_srscl0_uk_grad2dadja_lv2   lev2, d_adja level limit for 3rd piece;   default = 128;
//Bit 15: 8, reg_srscl0_uk_grad2dadja_lv1   lev1, d_adja level limit for 2nd piece;   default = 128;
//Bit  7: 0, reg_srscl0_uk_grad2dadja_lv0   lev0, d_adja level limit for 1st piece;   default = 128;
#define SRSCL0_UK_BST_GAIN                         0x310d
//Bit 31:24, reg_srscl0_bst_cgain           Gain to Uk_diag, normalized to 32 as “1”  default = 122;
//Bit 23:16, reg_srscl0_bst_ygain           Gain to Uk_adja, normalized to 32 as “1”  default = 122;
//Bit 15: 8, reg_srscl0_uk_adja_gain        Boost gain to delta component of SR scalar refine for luma channel. It is applied to tDiv.
//                                          Normalized to 128 as “1”  default = 58;
//Bit  7: 0, reg_srscl0_uk_diag_gain        Boost gain to delta component of SR scalar refine for chroma channel. It is applied to tDiv.
//                                          Normalized to 128 as “1”  default = 80;
#define SRSCL0_HVBLEND_TH                          0x310e
//Bit 31:29, reserved 
//Bit 28:24, reg_srscl0_hvblend_th3         Rate threshold to decide HV protection blend rate, default = 8;
//Bit 23:21, reserved 
//Bit 20:16, reg_srscl0_hvblend_th2         the same as above;  default = 8;
//Bit 15:13, reserved 
//Bit 12: 8, reg_srscl0_hvblend_th1         the same as above;  default = 4;
//Bit  7: 5, reserved 
//Bit  4: 0, reg_srscl0_hvblend_th0         the same as above;  default = 4;
#define SRSCL0_DEMO_WIND_TB                        0x310f
//Bit 31:29, reserved 
//Bit 28:16, reg_srscl0_demo_wind_top       Demo mode window vertical top boundary range;  default = 8191;
//Bit 15:13, reserved 
//Bit 12: 0, reg_srscl0_demo_wind_bot       Demo mode window vertical bottom boundary range;  default = 0;
#define SRSCL0_DEMO_WIND_LR                        0x3110
//Bit 31:29, reserved 
//Bit 28:16, reg_srscl0_demo_wind_right     Demo mode window vertical right boundary range;  default = 8191;
//Bit 15:13, reserved 
//Bit 12: 0, reg_srscl0_demo_wind_left      Demo mode window vertical left boundary range;  default = 0;
#define SRSCL0_INT_BLANK_NUM                       0x3111
//Bit 31:21, reserved  
//Bit    20, reg_srscl0_rst_syn_en          for syn same control reg to rst_n posedge. default=0;  
//Bit 19:16, reg_srscl0_inbuf_hsk_stuff     default=2
//Bit 15: 8, reg_srscl0_int_vbk_num         interpolation vertical   blank num   default=24
//Bit  7: 0, reg_srscl0_int_hbk_num         interpolation horizontal blank num   default=8
#define SRSCL0_YBIC_HCOEF0                         0x3112
//Bit 31:24, reg_srscl0_y_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl0_y_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl0_y_bic_hcoef01         the same as above; default=128                        
//Bit  7: 0, reg_srscl0_y_bic_hcoef00         the same as above; default=0
#define SRSCL0_CBIC_HCOEF0                         0x3113
//Bit 31:24, reg_srscl0_c_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl0_c_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl0_c_bic_hcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl0_c_bic_hcoef00         the same as above; default=0
#define SRSCL0_YBIC_VCOEF0                         0x3114
//Bit 31:24, reg_srscl0_y_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl0_y_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl0_y_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl0_y_bic_vcoef00         the same as above; default=0
#define SRSCL0_CBIC_VCOEF0                         0x3115
//Bit 31:24, reg_srscl0_c_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl0_c_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl0_c_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl0_c_bic_vcoef00         the same as above; default=0
////=================================================================////
//// super scaler core 1
////=================================================================////
#define SRSCL1_HV_SIZEIN                           0x3118
//Bit 31:29, reserved  
//Bit 28:16, reg_srscl1_hsize               image horizontal size (number of cols)   default=2048 
//Bit 15:13, reserved                       
//Bit 12: 0, reg_srscl1_vsize               image vertical size   (number of rows)   default=2048
#define SRSCL1_CTRL_MODE                           0x3119
//Bit 31:15, reserved     
//Bit 14,    reg_srscl1_horz_outphs          phase for super-scalar output under xVx1H ration: 0: 0 phase, 1: 1/2 phase     default = 0
//Bit 13,    reg_srscl1_cmpmux_aft           u1: 0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB; default = 0
//Bit 12,    reg_srscl1_cmpmux_bef           u1: 0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR; default = 0
//Bit 11,    reg_srscl1_bic_norm             normalization of bicubical: 0: 128|128; 1: 64|64  default = 0
//Bit 10,    reg_srscl1_3dint_mode           option for line-by-line 3D cases     default = 0
//Bit 9,     reg_srscl1_3dint_hadj_cub       option for using cubic interpolation for horizontal adjacent pixels     default = 0
//Bit 8,     reg_srscl1_vert_outphs          phase for super-scalar output under 1Vx2H ration: 0: 0 phase, 1: 1/2 phase     default = 0
//Bit 7,     reg_srscl1_cuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
//Bit 6,     reg_srscl1_yuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
//Bit 5,     reg_srscl1_cuse_bic             inside demo window luma use bicubical interpolation 
//                                           0: demo window us SR scalar for chroma channel;  
//                                           1: demo window use Bi-cubic scalar for chroma channel        default = 0
//Bit 4,     reg_srscl1_yuse_bic             inside demo window luma use bicubical interpolation 
//                                           0: demo window us SR scalar for luma channel;  
//                                           1: demo window use Bi-cubic scalar for luma channel        default = 0
//Bit 3,     reg_srscl1_use_3lrln            Options to extend 3 lines low-resolution data to 5-lines for SR scalar, (for core_0):
//                                           0: normal working mode, using 5 lines 
//                                           1: extend effective 3 lines to 5 lines; (will be used in line-by-line 3D contents)         default = 
//Bit 2,     reg_srscl1_vert_ratio           Vertical scalar ratio of Super Scalar core_0;
//                                           0: 1x scale; 1: 2x scale;    default = 
//Bit 1,     reg_srscl1_hori_ratio           Horizontal scalar ratio of Super Scalar core_0;
//                                           0: 1x scale; 1: 2x scale;    default = 
//Bit 0,     reg_srscl1_enable               Enable of Super Scalar core_0: 
//                                           0: disable (bypass) 1: enable    default = 
#define SRSCL1_YBIC_HCOEF                          0x311a
//Bit 31:24, reg_srscl1_y_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_y_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_y_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_y_bic_hcoef0         the same as above; default=-8
#define SRSCL1_CBIC_HCOEF                          0x311b
//Bit 31:24, reg_srscl1_c_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_c_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_c_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_c_bic_hcoef0         the same as above; default=-8
#define SRSCL1_YBIC_VCOEF                          0x311c
//Bit 31:24, reg_srscl1_y_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_y_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_y_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_y_bic_vcoef0         the same as above; default=-8
#define SRSCL1_CBIC_VCOEF                          0x311d
//Bit 31:24, reg_srscl1_c_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_c_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_c_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_c_bic_vcoef0         the same as above; default=-8
#define SRSCL1_VAR_PARA                            0x311e
//Bit 31:26, reserved  
//Bit 25:24, reg_srscl1_var_adja_rs          Horizontal/vertical adjacent pixel noise normalized variance value right shift bits.  default= 2   
//Bit 23:16, reg_srscl1_var_adja             Horizontal/vertical adjacent pixel noise normalized variance value. 
//                                           Var2 = (2^(11+rs))/gain; default= 68
//Bit 15:10, reserved  
//Bit  9: 8, reg_srscl1_var_diag_rs          Diagonal pixel noise normalized variance value right shift bits. default= 3    
//Bit  7: 0, reg_srscl1_var_diag             Diagonal pixel noise normalized variance value. Var2 = (2^(11+rs))/gain; default= 68
#define SRSCL1_CONST_PARA                          0x311f
//Bit 31:16, reserved  
//Bit 15: 8, reg_srscl1_c_adja               Constant for d_adja calculation from wk_nrm; Normalize 128 as “1” default= 32     
//Bit  7: 0, reg_srscl1_c_diag               Constant for d_diag calculation from wk_nrm; Normalize 128 as “1” default= 32
#define SRSCL1_RKE_EXTWIN                          0x3120
//Bit 31:23, reserved  
//Bit 22:20, reg_srscl1_rke_extwin         Window size for Rke horizontal extension: Win_size = 2x+1 scope: 0~5;  default= 4
//Bit 19:16, reg_srscl1_rke_coring         Coring to Rke default= 10
//Bit 15:13, reserved  
//Bit 12: 8, reg_srscl1_rke_extwin_core    Coring to Rks before local window maximum value calculation     default= 10 
//Bit  7: 0, reg_srscl1_rke_extwin_rate    Rate to blender strength (gamma), gamma is used to blend local maximum Rke and current Rke; the rate is normalized to 16 as “1”  default= 12
#define SRSCL1_UK_GRAD2DDIAG_TH_RATE               0x3121
//reg_srscl1_uk_grad2ddiag (0 1 5 6)  Wk_nrm to d_diag mapping curve parameter for UK calculation:         
//Bit 31:24, reg_srscl1_uk_grad2ddiag_rate1 rate1, d_diag level trasition rate 2nd towards 3rd piece;   default = 20;
//Bit 23:16, reg_srscl1_uk_grad2ddiag_rate0 rate0, d_diag level trasition rate 2nd towards 1st piece;   default = 80;
//Bit 15: 8, reg_srscl1_uk_grad2ddiag_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
//Bit  7: 0, reg_srscl1_uk_grad2ddiag_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
#define SRSCL1_UK_GRAD2DDIAG_LIMIT                 0x3122
//reg_srscl1_uk_grad2ddiag (2 3 4)            
//Bit 31:24, reserved 
//Bit 23:16, reg_srscl1_uk_grad2ddiag_lv2   lev2, d_diag level limit for 3rd piece;   default = 128;
//Bit 15: 8, reg_srscl1_uk_grad2ddiag_lv1   lev1, d_diag level limit for 2nd piece;   default = 128;
//Bit  7: 0, reg_srscl1_uk_grad2ddiag_lv0   lev0, d_diag level limit for 1st piece;   default = 128;
#define SRSCL1_UK_GRAD2DADJA_TH_RATE               0x3123
//reg_srscl1_uk_grad2adja (0 1 5 6)  Wk_nrm to d_adja mapping curve parameter for UK calculation:         
//Bit 31:24, reg_srscl1_uk_grad2dadja_rate1 rate1, d_adja level trasition rate 2nd towards 3rd piece;   default = 20;
//Bit 23:16, reg_srscl1_uk_grad2dadja_rate0 rate0, d_adja level trasition rate 2nd towards 1st piece;   default = 80;
//Bit 15: 8, reg_srscl1_uk_grad2dadja_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
//Bit  7: 0, reg_srscl1_uk_grad2dadja_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
#define SRSCL1_UK_GRAD2DADJA_LIMIT                 0x3124
//reg_srscl1_uk_grad2dadja (2 3 4)            
//Bit 31:24, reserved    
//Bit 23:16, reg_srscl1_uk_grad2dadja_lv2   lev2, d_adja level limit for 3rd piece;   default = 128;
//Bit 15: 8, reg_srscl1_uk_grad2dadja_lv1   lev1, d_adja level limit for 2nd piece;   default = 128;
//Bit  7: 0, reg_srscl1_uk_grad2dadja_lv0   lev0, d_adja level limit for 1st piece;   default = 128;
#define SRSCL1_UK_BST_GAIN                         0x3125
//Bit 31:24, reg_srscl1_bst_cgain           Gain to Uk_diag, normalized to 32 as “1”  default = 122;
//Bit 23:16, reg_srscl1_bst_ygain           Gain to Uk_adja, normalized to 32 as “1”  default = 122;
//Bit 15: 8, reg_srscl1_uk_adja_gain        Boost gain to delta component of SR scalar refine for luma channel. It is applied to tDiv.
//                                          Normalized to 128 as “1”  default = 58;
//Bit  7: 0, reg_srscl1_uk_diag_gain        Boost gain to delta component of SR scalar refine for chroma channel. It is applied to tDiv.
//                                          Normalized to 128 as “1”  default = 80;
#define SRSCL1_HVBLEND_TH                          0x3126
//Bit 31:29, reserved 
//Bit 28:24, reg_srscl1_hvblend_th3         Rate threshold to decide HV protection blend rate, default = 8;
//Bit 23:21, reserved 
//Bit 20:16, reg_srscl1_hvblend_th2         the same as above;  default = 8;
//Bit 15:13, reserved 
//Bit 12: 8, reg_srscl1_hvblend_th1         the same as above;  default = 4;
//Bit  7: 5, reserved 
//Bit  4: 0, reg_srscl1_hvblend_th0         the same as above;  default = 4;
#define SRSCL1_DEMO_WIND_TB                        0x3127
//Bit 31:29, reserved 
//Bit 28:16, reg_srscl1_demo_wind_top       Demo mode window vertical top boundary range;  default = 8191;
//Bit 15:13, reserved 
//Bit 12: 0, reg_srscl1_demo_wind_bot       Demo mode window vertical bottom boundary range;  default = 0;
#define SRSCL1_DEMO_WIND_LR                        0x3128
//Bit 31:29, reserved 
//Bit 28:16, reg_srscl1_demo_wind_right     Demo mode window vertical right boundary range;  default = 8191;
//Bit 15:13, reserved 
//Bit 12: 0, reg_srscl1_demo_wind_left      Demo mode window vertical left boundary range;  default = 0;
#define SRSCL1_INT_BLANK_NUM                       0x3129
//Bit 31:21, reserved  
//Bit    20, reg_srscl1_rst_syn_en          for syn same control reg to rst_n posedge. default=0;
//Bit 19:16, reg_srscl1_inbuf_hsk_stuff     default=2
//Bit 15: 8, reg_srscl1_int_vbk_num         interpolation vertical   blank num   default=24
//Bit  7: 0, reg_srscl1_int_hbk_num         interpolation horizontal blank num   default=8
#define SRSCL_FRM_END_STAT                         0x312a
//Bit 31: 1, reserved  
//Bit     0, reg_frm_end_stat               frame end status   default=0
#define SRSCL1_YBIC_HCOEF0                         0x312b
//Bit 31:24, reg_srscl1_y_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_y_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_y_bic_hcoef01         the same as above; default=128                        
//Bit  7: 0, reg_srscl1_y_bic_hcoef00         the same as above; default=0
#define SRSCL1_CBIC_HCOEF0                         0x312c
//Bit 31:24, reg_srscl1_c_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_c_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_c_bic_hcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_c_bic_hcoef00         the same as above; default=0
#define SRSCL1_YBIC_VCOEF0                         0x312d
//Bit 31:24, reg_srscl1_y_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_y_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_y_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_y_bic_vcoef00         the same as above; default=0
#define SRSCL1_CBIC_VCOEF0                         0x312e
//Bit 31:24, reg_srscl1_c_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_c_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_c_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_c_bic_vcoef00         the same as above; default=0
////=================================================================////
//// super scaler core 1
////=================================================================////
#define OSDSR_HV_SIZEIN                            0x3130
//Bit 31:29, reserved  
//Bit 28:16, reg_srscl1_hsize               image horizontal size (number of cols)   default=2048 
//Bit 15:13, reserved                       
//Bit 12: 0, reg_srscl1_vsize               image vertical size   (number of rows)   default=2048
#define OSDSR_CTRL_MODE                            0x3131
//Bit 31:16, reserved     
//Bit 15,    reg_srscl1_cmpmux_aft           u1: 0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB; default = 0
//Bit 14,    reg_srscl1_cmpmux_bef           u1: 0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR; default = 0
//Bit 13,    reg_srscl1_bic_norm             normalization of bicubical: 0: 128|128; 1: 64|64  default = 0
//Bit 12,    reg_srscl1_3dint_mode           option for line-by-line 3D cases     default = 0
//Bit 11,    reg_srscl1_3dint_hadj_cub       option for using cubic interpolation for horizontal adjacent pixels     default = 0
//Bit 10,    reg_srscl1_3dint_phase          phase for super-scalar output under 1Vx2H ration: 0: 0 phase, 1: 1/2 phase     default = 0
//Bit 9,     reg_srscl1_cuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
//Bit 8,     reg_srscl1_yuse_bic_od          outside demo window luma use bicubical interpolation    default = 0
//Bit 7,     reg_srscl1_ause_bic_od          outside demo window alpha use bicubical interpolation    default = 0
//Bit 6,     reg_srscl1_cuse_bic             inside demo window luma use bicubical interpolation 
//                                           0: demo window us SR scalar for chroma channel;  
//                                           1: demo window use Bi-cubic scalar for chroma channel        default = 0
//Bit 5,     reg_srscl1_yuse_bic             inside demo window luma use bicubical interpolation 
//                                           0: demo window us SR scalar for luma channel;  
//                                           1: demo window use Bi-cubic scalar for luma channel        default = 0
//Bit 4,     reg_srscl1_ause_bic             inside demo window alpha use bicubical interpolation 
//                                           0: demo window us SR scalar for alpha channel;  
//                                           1: demo window use Bi-cubic scalar for alpha channel        default = 0
//Bit 3,     reg_srscl1_use_3lrln            Options to extend 3 lines low-resolution data to 5-lines for SR scalar, (for core_0):
//                                           0: normal working mode, using 5 lines 
//                                           1: extend effective 3 lines to 5 lines; (will be used in line-by-line 3D contents)         default = 
//Bit 2,     reg_srscl1_vert_ratio           Vertical scalar ratio of Super Scalar core_0;
//                                           0: 1x scale; 1: 2x scale;    default = 
//Bit 1,     reg_srscl1_hori_ratio           Horizontal scalar ratio of Super Scalar core_0;
//                                           0: 1x scale; 1: 2x scale;    default = 
//Bit 0,     reg_srscl1_enable               Enable of Super Scalar core_0: 
//                                           0: disable (bypass) 1: enable    default = 
#define OSDSR_ABIC_HCOEF                           0x3132
//Bit 31:24, reg_srscl1_a_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of alpha channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_a_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_a_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_a_bic_hcoef0         the same as above; default=-8
#define OSDSR_YBIC_HCOEF                           0x3133
//Bit 31:24, reg_srscl1_y_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_y_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_y_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_y_bic_hcoef0         the same as above; default=-8
#define OSDSR_CBIC_HCOEF                           0x3134
//Bit 31:24, reg_srscl1_c_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_c_bic_hcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_c_bic_hcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_c_bic_hcoef0         the same as above; default=-8
#define OSDSR_ABIC_VCOEF                           0x3135
//Bit 31:24, reg_srscl1_a_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of alpha channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_a_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_a_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_a_bic_vcoef0         the same as above; default=-8
#define OSDSR_YBIC_VCOEF                           0x3136
//Bit 31:24, reg_srscl1_y_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_y_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_y_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_y_bic_vcoef0         the same as above; default=-8
#define OSDSR_CBIC_VCOEF                           0x3137
//Bit 31:24, reg_srscl1_c_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                           Filter will be normalized to 128 as ‘1’; default=-8                         
//Bit 23:16, reg_srscl1_c_bic_vcoef2         the same as above; default=72                         
//Bit 15: 8, reg_srscl1_c_bic_vcoef1         the same as above; default=72                         
//Bit  7: 0, reg_srscl1_c_bic_vcoef0         the same as above; default=-8
#define OSDSR_VAR_PARA                             0x3138
//Bit 31:26, reserved  
//Bit 25:24, reg_srscl1_var_adja_rs          Horizontal/vertical adjacent pixel noise normalized variance value right shift bits.  default= 2   
//Bit 23:16, reg_srscl1_var_adja             Horizontal/vertical adjacent pixel noise normalized variance value. 
//                                           Var2 = (2^(11+rs))/gain; default= 68
//Bit 15:10, reserved  
//Bit  9: 8, reg_srscl1_var_diag_rs          Diagonal pixel noise normalized variance value right shift bits. default= 3    
//Bit  7: 0, reg_srscl1_var_diag             Diagonal pixel noise normalized variance value. Var2 = (2^(11+rs))/gain; default= 68
#define OSDSR_CONST_PARA                           0x3139
//Bit 31:16, reserved  
//Bit 15: 8, reg_srscl1_c_adja               Constant for d_adja calculation from wk_nrm; Normalize 128 as “1” default= 32     
//Bit  7: 0, reg_srscl1_c_diag               Constant for d_diag calculation from wk_nrm; Normalize 128 as “1” default= 32
#define OSDSR_RKE_EXTWIN                           0x313a
//Bit 31:23, reserved  
//Bit 22:20, reg_srscl1_rke_extwin         Window size for Rke horizontal extension: Win_size = 2x+1 scope: 0~5;  default= 4
//Bit 19:16, reg_srscl1_rke_coring         Coring to Rke default= 10
//Bit 15:13, reserved  
//Bit 12: 8, reg_srscl1_rke_extwin_core    Coring to Rks before local window maximum value calculation     default= 10 
//Bit  7: 0, reg_srscl1_rke_extwin_rate    Rate to blender strength (gamma), gamma is used to blend local maximum Rke and current Rke; the rate is normalized to 16 as “1”  default= 12
#define OSDSR_UK_GRAD2DDIAG_TH_RATE                0x313b
//reg_srscl1_uk_grad2ddiag (0 1 5 6)  Wk_nrm to d_diag mapping curve parameter for UK calculation:         
//Bit 31:24, reg_srscl1_uk_grad2ddiag_rate1 rate1, d_diag level trasition rate 2nd towards 3rd piece;   default = 20;
//Bit 23:16, reg_srscl1_uk_grad2ddiag_rate0 rate0, d_diag level trasition rate 2nd towards 1st piece;   default = 80;
//Bit 15: 8, reg_srscl1_uk_grad2ddiag_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
//Bit  7: 0, reg_srscl1_uk_grad2ddiag_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
#define OSDSR_UK_GRAD2DDIAG_LIMIT                  0x313c
//reg_srscl1_uk_grad2ddiag (2 3 4)            
//Bit 31:24, reserved 
//Bit 23:16, reg_srscl1_uk_grad2ddiag_lv2   lev2, d_diag level limit for 3rd piece;   default = 128;
//Bit 15: 8, reg_srscl1_uk_grad2ddiag_lv1   lev1, d_diag level limit for 2nd piece;   default = 128;
//Bit  7: 0, reg_srscl1_uk_grad2ddiag_lv0   lev0, d_diag level limit for 1st piece;   default = 128;
#define OSDSR_UK_GRAD2DADJA_TH_RATE                0x313d
//reg_srscl1_uk_grad2adja (0 1 5 6)  Wk_nrm to d_adja mapping curve parameter for UK calculation:         
//Bit 31:24, reg_srscl1_uk_grad2dadja_rate1 rate1, d_adja level trasition rate 2nd towards 3rd piece;   default = 20;
//Bit 23:16, reg_srscl1_uk_grad2dadja_rate0 rate0, d_adja level trasition rate 2nd towards 1st piece;   default = 80;
//Bit 15: 8, reg_srscl1_uk_grad2dadja_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
//Bit  7: 0, reg_srscl1_uk_grad2dadja_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
#define OSDSR_UK_GRAD2DADJA_LIMIT                  0x313e
//reg_srscl1_uk_grad2dadja (2 3 4)            
//Bit 31:24, reserved    
//Bit 23:16, reg_srscl1_uk_grad2dadja_lv2   lev2, d_adja level limit for 3rd piece;   default = 128;
//Bit 15: 8, reg_srscl1_uk_grad2dadja_lv1   lev1, d_adja level limit for 2nd piece;   default = 128;
//Bit  7: 0, reg_srscl1_uk_grad2dadja_lv0   lev0, d_adja level limit for 1st piece;   default = 128;
#define OSDSR_UK_BST_GAIN                          0x313f
//Bit 31:24, reg_srscl1_bst_cgain           Gain to Uk_diag, normalized to 32 as “1”  default = 122;
//Bit 23:16, reg_srscl1_bst_ygain           Gain to Uk_adja, normalized to 32 as “1”  default = 122;
//Bit 15: 8, reg_srscl1_uk_adja_gain        Boost gain to delta component of SR scalar refine for luma channel. It is applied to tDiv.
//                                          Normalized to 128 as “1”  default = 58;
//Bit  7: 0, reg_srscl1_uk_diag_gain        Boost gain to delta component of SR scalar refine for chroma channel. It is applied to tDiv.
//                                          Normalized to 128 as “1”  default = 80;
#define OSDSR_HVBLEND_TH                           0x3140
//Bit 31:29, reserved 
//Bit 28:24, reg_srscl1_hvblend_th3         Rate threshold to decide HV protection blend rate, default = 8;
//Bit 23:21, reserved 
//Bit 20:16, reg_srscl1_hvblend_th2         the same as above;  default = 8;
//Bit 15:13, reserved 
//Bit 12: 8, reg_srscl1_hvblend_th1         the same as above;  default = 4;
//Bit  7: 5, reserved 
//Bit  4: 0, reg_srscl1_hvblend_th0         the same as above;  default = 4;
#define OSDSR_DEMO_WIND_TB                         0x3141
//Bit 31:29, reserved 
//Bit 28:16, reg_srscl1_demo_wind_top       Demo mode window vertical top boundary range;  default = 8191;
//Bit 15:13, reserved 
//Bit 12: 0, reg_srscl1_demo_wind_bot       Demo mode window vertical bottom boundary range;  default = 0;
#define OSDSR_DEMO_WIND_LR                         0x3142
//Bit 31:29, reserved 
//Bit 28:16, reg_srscl1_demo_wind_right     Demo mode window vertical right boundary range;  default = 8191;
//Bit 15:13, reserved 
//Bit 12: 0, reg_srscl1_demo_wind_left      Demo mode window vertical left boundary range;  default = 0;
#define OSDSR_INT_BLANK_NUM                        0x3143
//Bit 31:21, reserved  
//Bit    20, reg_srscl1_rst_syn_en          for syn same control reg to rst_n posedge. default=0;
//Bit 19:16, reg_srscl1_inbuf_hsk_stuff     default=2
//Bit 15: 8, reg_srscl1_int_vbk_num         interpolation vertical   blank num   default=24
//Bit  7: 0, reg_srscl1_int_hbk_num         interpolation horizontal blank num   default=8
#define OSDSR_FRM_END_STAT                         0x3144
//Bit 31: 1, reserved  
//Bit     0, reg_frm_end_stat               frame end status   default=0
#define OSDSR_ABIC_HCOEF0                          0x3145
//Bit 31:24, reg_srscl1_a_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_a_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_a_bic_hcoef01         the same as above; default=128                        
//Bit  7: 0, reg_srscl1_a_bic_hcoef00         the same as above; default=0
#define OSDSR_YBIC_HCOEF0                          0x3146
//Bit 31:24, reg_srscl1_y_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_y_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_y_bic_hcoef01         the same as above; default=128                        
//Bit  7: 0, reg_srscl1_y_bic_hcoef00         the same as above; default=0
#define OSDSR_CBIC_HCOEF0                          0x3147
//Bit 31:24, reg_srscl1_c_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_c_bic_hcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_c_bic_hcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_c_bic_hcoef00         the same as above; default=0
#define OSDSR_ABIC_VCOEF0                          0x3148
//Bit 31:24, reg_srscl1_a_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_a_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_a_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_a_bic_vcoef00         the same as above; default=0
#define OSDSR_YBIC_VCOEF0                          0x3149
//Bit 31:24, reg_srscl1_y_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_y_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_y_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_y_bic_vcoef00         the same as above; default=0
#define OSDSR_CBIC_VCOEF0                          0x314a
//Bit 31:24, reg_srscl1_c_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
//                                            Filter will be normalized to 128 as ‘1’; default=0                         
//Bit 23:16, reg_srscl1_c_bic_vcoef02         the same as above; default=0                         
//Bit 15: 8, reg_srscl1_c_bic_vcoef01         the same as above; default=128                         
//Bit  7: 0, reg_srscl1_c_bic_vcoef00         the same as above; default=0
//
// Reading file:  xvycc_regs.h
//
// synopsys translate_off
// synopsys translate_on
//    `define XVYCC_VCBUS_BASE	   8'hfe
#define XVYCC_INV_LUT_Y_ADDR_PORT                  0x3158
//Bit 31:7, reserved  
//Bit  6:0,  xvycc_inv_lut_y_addr;
#define XVYCC_INV_LUT_Y_DATA_PORT                  0x3159
//Bit 31:12, reserved  
//Bit  11:0, xvycc_inv_lut_y_data;
#define XVYCC_INV_LUT_U_ADDR_PORT                  0x315a
//Bit 31:6, reserved  
//Bit  5:0,  xvycc_inv_lut_u_addr;
#define XVYCC_INV_LUT_U_DATA_PORT                  0x315b
//Bit 31:12, reserved  
//Bit  11:0, xvycc_inv_lut_u_data;
#define XVYCC_INV_LUT_V_ADDR_PORT                  0x315c
//Bit 31:6, reserved  
//Bit  5:0,  xvycc_inv_lut_v_addr;
#define XVYCC_INV_LUT_V_DATA_PORT                  0x315d
//Bit 31:12, reserved  
//Bit  11:0, xvycc_inv_lut_v_data;
#define XVYCC_LUT_R_ADDR_PORT                      0x315e
//Bit 31:7, reserved  
//Bit  6:0,  xvycc_lut_r_addr;
#define XVYCC_LUT_R_DATA_PORT                      0x315f
//Bit 31:10, reserved  
//Bit  9:0,  xvycc_lut_r_data;
#define XVYCC_LUT_G_ADDR_PORT                      0x3160
//Bit 31:7, reserved  
//Bit  6:0,  xvycc_lut_g_addr;
#define XVYCC_LUT_G_DATA_PORT                      0x3161
//Bit 31:10, reserved  
//Bit  9:0,  xvycc_lut_g_data;
#define XVYCC_LUT_B_ADDR_PORT                      0x3162
//Bit 31:7, reserved  
//Bit  6:0,  xvycc_lut_b_addr;
#define XVYCC_LUT_B_DATA_PORT                      0x3163
//Bit 31:10, reserved  
//Bit  9:0,  xvycc_lut_b_data;
#define XVYCC_INV_LUT_CTL                          0x3164
//Bit 31:15, reserved  
//Bit 14:12, reg_xvycc_cmpr_invlut_enable    enable for xvycc compression inverse-lut [2] for Y, [1] for U, [0] for V default=0
//Bit 11:10, reg_xvycc_cmpr_invlut_vscl_1   v LUT input scale for positive portion   default=0
//Bit  9: 8, reg_xvycc_cmpr_invlut_vscl_0   v LUT input scale for negative portion   default=0
//Bit  7: 6, reg_xvycc_cmpr_invlut_uscl_1   u LUT input scale for positive portion   default=0
//Bit  5: 4, reg_xvycc_cmpr_invlut_uscl_0   u LUT input scale for negative portion   default=0
//Bit  3: 2, reg_xvycc_cmpr_invlut_yscl_1   y LUT input scale for positive portion   default=0
//Bit  1: 0, reg_xvycc_cmpr_invlut_yscl_0   y LUT input scale for negative portion   default=0
#define XVYCC_LUT_CTL                              0x3165
//Bit 31: 7, reserved  
//Bit  6: 4, reg_xvycc_lut_enable  LUT enable [6] for R, [5] for G, [4] for B  default=0
//Bit  3: 2, reg_xvycc_lut_scl_1   LUT input scale for positive portion   default=0
//Bit  1: 0, reg_xvycc_lut_scl_0   LUT input scale for negative portion   default=0
#define XVYCC_VADJ1_CURV_0                         0x3166
//Bit 31:24, vadj1_softcon_curv0_ci                         default=0
//Bit 23:12, vadj1_softcon_curv0_b                          default=0
//Bit 11: 0, vadj1_softcon_curv0_a                          default=0
#define XVYCC_VADJ1_CURV_1                         0x3167
//Bit 31:13, reserved
//Bit 12: 4, vadj1_softcon_curv0_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj1_softcon_curv0_cs                         default=0
#define XVYCC_VADJ1_CURV_2                         0x3168
//Bit 31:24, vadj1_softcon_curv1_ci                         default=0
//Bit 23:12, vadj1_softcon_curv1_b                          default=0
//Bit 11: 0, vadj1_softcon_curv1_a                          default=0
#define XVYCC_VADJ1_CURV_3                         0x3169
//Bit 31:13, reserved
//Bit 12: 4, vadj1_softcon_curv1_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj1_softcon_curv1_cs                         default=0
#define XVYCC_VADJ2_CURV_0                         0x316a
//Bit 31:24, vadj2_softcon_curv0_ci                         default=0
//Bit 23:12, vadj2_softcon_curv0_b                          default=0
//Bit 11: 0, vadj2_softcon_curv0_a                          default=0
#define XVYCC_VADJ2_CURV_1                         0x316b
//Bit 31:13, reserved
//Bit 12: 4, vadj2_softcon_curv0_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj2_softcon_curv0_cs                         default=0
#define XVYCC_VADJ2_CURV_2                         0x316c
//Bit 31:24, vadj2_softcon_curv1_ci                         default=0
//Bit 23:12, vadj2_softcon_curv1_b                          default=0
//Bit 11: 0, vadj2_softcon_curv1_a                          default=0
#define XVYCC_VADJ2_CURV_3                         0x316d
//Bit 31:13, reserved
//Bit 12: 4, vadj2_softcon_curv1_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj2_softcon_curv1_cs                         default=0
#define XVYCC_VD1_RGB_CTRST                        0x3170
//Bit 31:28, reserved    
//Bit 27:16, reg_vd1_rgb_ctrst        u12, contrast in rgb.      default=1024
//Bit 15:14, reserved  
//Bit 13: 4, reg_vd1_rgb_ctrst_blklvl u10, contrast blacklevel   default=64 
//Bit  3: 2, reserved  
//Bit     1, reg_vd1_rgbbst_en         u1, enable rgbbst         default=0 
//Bit     0, reg_vd1_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1 
#define XVYCC_VD1_RGB_BRGHT                        0x3171
//Bit 31:16, reserved
//Bit 15: 4, reg_vd1_rgb_brght        s12, brightness level in rgb domain                              default=0 
//Bit  3: 2, reserved
//Bit     1, reg_vd1_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
//Bit     0, reg_vd1_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
#define XVYCC_VD1_RGB_DLUT_0_3                     0x3172
//Bit 31:24, reg_vd1_rgbbst_dlut0      u8,   default = 255
//Bit 23:16, reg_vd1_rgbbst_dlut1      u8,   default = 205
//Bit 15: 8, reg_vd1_rgbbst_dlut2      u8,   default = 171
//Bit  7: 0, reg_vd1_rgbbst_dlut3      u8,   default = 147 
#define XVYCC_VD1_RGB_DLUT_4_7                     0x3173
//Bit 31:24, reg_vd1_rgbbst_dlut4      u8,   default = 128
//Bit 23:16, reg_vd1_rgbbst_dlut5      u8,   default = 113
//Bit 15: 8, reg_vd1_rgbbst_dlut6      u8,   default = 102
//Bit  7: 0, reg_vd1_rgbbst_dlut7      u8,   default = 93 
#define XVYCC_VD1_RGB_DLUT_8_11                    0x3174
//Bit 31:24, reg_vd1_rgbbst_dlut8      u8,   default = 85
//Bit 23:16, reg_vd1_rgbbst_dlut9      u8,   default = 78
//Bit 15: 8, reg_vd1_rgbbst_dlut10     u8,   default = 73
//Bit  7: 0, reg_vd1_rgbbst_dlut11     u8,   default = 68 
#define XVYCC_POST_RGB_CTRST                       0x3175
//Bit 31:28, reserved    
//Bit 27:16, reg_post_rgb_ctrst        u12, contrast in rgb.      default=1024
//Bit 15:14, reserved  
//Bit 13: 4, reg_post_rgb_ctrst_blklvl u10, contrast blacklevel   default=64 
//Bit  3: 2, reserved 
//Bit     1, reg_post_rgbbst_en         u1, enable rgbbst         default=0 
//Bit     0, reg_post_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1 
#define XVYCC_POST_RGB_BRGHT                       0x3176
//Bit 31:16, reserved
//Bit 15: 4, reg_post_rgb_brght        s12, brightness level in rgb domain                              default=0 
//Bit  3: 2, reserved
//Bit     1, reg_post_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
//Bit     0, reg_post_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
#define XVYCC_POST_RGB_DLUT_0_3                    0x3177
//Bit 31:24, reg_post_rgbbst_dlut0      u8,   default = 255
//Bit 23:16, reg_post_rgbbst_dlut1      u8,   default = 205
//Bit 15: 8, reg_post_rgbbst_dlut2      u8,   default = 171
//Bit  7: 0, reg_post_rgbbst_dlut3      u8,   default = 147 
#define XVYCC_POST_RGB_DLUT_4_7                    0x3178
//Bit 31:24, reg_post_rgbbst_dlut4      u8,   default = 128
//Bit 23:16, reg_post_rgbbst_dlut5      u8,   default = 113
//Bit 15: 8, reg_post_rgbbst_dlut6      u8,   default = 102
//Bit  7: 0, reg_post_rgbbst_dlut7      u8,   default = 93 
#define XVYCC_POST_RGB_DLUT_8_11                   0x3179
//Bit 31:24, reg_post_rgbbst_dlut8      u8,   default = 85
//Bit 23:16, reg_post_rgbbst_dlut9      u8,   default = 78
//Bit 15: 8, reg_post_rgbbst_dlut10     u8,   default = 73
//Bit  7: 0, reg_post_rgbbst_dlut11     u8,   default = 68 
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  xvycc_regs.h
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
//  index + data
/////////////////////////////////////////////////////////////////////////////////////////////////////
//// // note there are some space in the header
//// 
//// 
//// //////////////////////////////////////////////////////////////////////////////////////////////////////
//// // read-only registers
//// //////////////////////////////////////////////////////////////////////////////////////////////////////
//// 
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  srscl_reg.h
//
//
// Reading file:  sharp_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define SHARP_HVSIZE                               0x3180
//Bit 31:29,        reserved                           
//Bit 28:16,        reg_pknr_hsize                                                                                                              . unsigned  , default = 1920
//Bit 15:13,        reserved                           
//Bit 12: 0,        reg_pknr_vsize                                                                                                              . unsigned  , default = 1080
#define SHARP_HVBLANK_NUM                          0x3181
//Bit 31:16,        reserved                           
//Bit 15: 8,        reg_pknr_hblank_num                                                                                                         . unsigned  , default = 20   
//Bit  7: 0,        reg_pknr_vblank_num                                                                                                         . unsigned  , default = 60   
#define NR_GAUSSIAN_MODE                           0x3182
//Bit 31: 5,        reserved                           
//Bit  4,            reg_nr_gau_ymode                            : 0 3x3 filter; 1: 5x5 filter                                                   . unsigned  , default = 1   
//Bit  3: 1,        reserved                           
//Bit  0,            reg_nr_gau_cmode                            : 0 3x3 filter; 1: 5x5 filter                                                   . unsigned  , default = 1   
#define PK_HVCON_LPF_MODE                          0x3183
//Bit 31:30,        reserved                           
//Bit 29:28,        reg_pk_hconhpf_mode                         : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
//Bit 27:26,        reserved                           
//Bit 25:24,        reg_pk_hconbpf_mode                         : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
//Bit 23:22,        reserved                           
//Bit 21:20,        reg_pk_hconlbpf_mode                        : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
//Bit 19:18,        reserved                           
//Bit 17:16,        reg_pk_hconllbpf_mode                       : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
//Bit 15:14,        reserved                           
//Bit 13:12,        reg_pk_vconhpf_mode                         : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
//Bit 11:10,        reserved                           
//Bit  9: 8,        reg_pk_vconbpf_mode                         : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
//Bit  7: 6,        reserved                           
//Bit  5: 4,        reg_pk_vconlbpf_mode                        : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
//Bit  3: 2,        reserved                           
//Bit  1: 0,        reg_pk_vconllbpf_mode                       : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
#define PK_CON_BLEND_GAIN                          0x3184
//Bit 31:28,        reg_pk_hpcon_hpgain                         : 8 as normalized 1                                                             . unsigned  , default = 4   
//Bit 27:24,        reg_pk_hpcon_bpgain                         : 8 as normalized 1                                                             . unsigned  , default = 4   
//Bit 23:20,        reg_pk_hpcon_lbpgain                        : 8 as normalized 1                                                             . unsigned  , default = 0   
//Bit 19:16,        reg_pk_hpcon_llbpgain                       : 8 as normalized 1                                                             . unsigned  , default = 0   
//Bit 15:12,        reg_pk_bpcon_hpgain                         : 8 as normalized 1                                                             . unsigned  , default = 0   
//Bit 11: 8,        reg_pk_bpcon_bpgain                         : 8 as normalized 1                                                             . unsigned  , default = 2   
//Bit  7: 4,        reg_pk_bpcon_lbpgain                        : 8 as normalized 1                                                             . unsigned  , default = 6   
//Bit  3: 0,        reg_pk_bpcon_llbpgain                       : 8 as normalized 1                                                             . unsigned  , default = 0   
#define PK_CON_2CIRHPGAIN_TH_RATE                  0x3185
//Bit 31:24,        reg_pk_cirhpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 25  
//Bit 23:16,        reg_pk_cirhpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 60  
//Bit 15: 8,        reg_pk_cirhpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 80  
//Bit  7: 0,        reg_pk_cirhpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 20  
#define PK_CON_2CIRHPGAIN_LIMIT                    0x3186
//Bit 31:24,        reg_pk_cirhpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 96  
//Bit 23:16,        reg_pk_cirhpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 96  
//Bit 15: 8,        reg_pk_cirhpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 5   
//Bit  7: 0,        reserved                           
#define PK_CON_2CIRBPGAIN_TH_RATE                  0x3187
//Bit 31:24,        reg_pk_cirbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 20  
//Bit 23:16,        reg_pk_cirbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).. unsigned  , default = 50  
//Bit 15: 8,        reg_pk_cirbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 50  
//Bit  7: 0,        reg_pk_cirbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 25  
#define PK_CON_2CIRBPGAIN_LIMIT                    0x3188
//Bit 31:24,        reg_pk_cirbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 40  
//Bit 23:16,        reg_pk_cirbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 40  
//Bit 15: 8,        reg_pk_cirbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 5   
//Bit  7: 0,        reserved                           
#define PK_CON_2DRTHPGAIN_TH_RATE                  0x3189
//Bit 31:24,        reg_pk_drthpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 25  
//Bit 23:16,        reg_pk_drthpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 60  
//Bit 15: 8,        reg_pk_drthpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 80  
//Bit  7: 0,        reg_pk_drthpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 20  
#define PK_CON_2DRTHPGAIN_LIMIT                    0x318a
//Bit 31:24,        reg_pk_drthpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).. unsigned  , default = 90  
//Bit 23:16,        reg_pk_drthpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 96  
//Bit 15: 8,        reg_pk_drthpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 5   
//Bit  7: 0,        reserved                           
#define PK_CON_2DRTBPGAIN_TH_RATE                  0x318b
//Bit 31:24,        reg_pk_drtbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 20  
//Bit 23:16,        reg_pk_drtbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50  
//Bit 15: 8,        reg_pk_drtbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50  
//Bit  7: 0,        reg_pk_drtbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 25  
#define PK_CON_2DRTBPGAIN_LIMIT                    0x318c
//Bit 31:24,        reg_pk_drtbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40  
//Bit 23:16,        reg_pk_drtbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40  
//Bit 15: 8,        reg_pk_drtbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 5   
//Bit  7: 0,        reserved                           
#define PK_CIRFB_LPF_MODE                          0x318d
//Bit 31:30,        reserved                           
//Bit 29:28,        reg_cirhp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
//Bit 27:26,        reserved                           
//Bit 25:24,        reg_cirhp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
//Bit 23:22,        reserved                           
//Bit 21:20,        reg_cirhp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1   
//Bit 19:14,        reserved                           
//Bit 13:12,        reg_cirbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
//Bit 11:10,        reserved                           
//Bit  9: 8,        reg_cirbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
//Bit  7: 6,        reserved                           
//Bit  5: 4,        reg_cirbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1   
//Bit  3: 0,        reserved                           
#define PK_DRTFB_LPF_MODE                          0x318e
//Bit 31:30,        reserved                           
//Bit 29:28,        reg_drthp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
//Bit 27:26,        reserved                           
//Bit 25:24,        reg_drthp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
//Bit 23:22,        reserved                           
//Bit 21:20,        reg_drthp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1   
//Bit 19:14,        reserved                           
//Bit 13:12,        reg_drtbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
//Bit 11:10,        reserved                           
//Bit  9: 8,        reg_drtbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
//Bit  7: 6,        reserved                           
//Bit  5: 4,        reg_drtbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1   
//Bit  3: 0,        reserved                           
#define PK_CIRFB_HP_CORING                         0x318f
//Bit 31:22,        reserved                           
//Bit 21:16,        reg_cirhp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_cirhp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_cirhp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
#define PK_CIRFB_BP_CORING                         0x3190
//Bit 31:22,        reserved                           
//Bit 21:16,        reg_cirbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_cirbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_cirbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
#define PK_DRTFB_HP_CORING                         0x3191
//Bit 31:22,        reserved                           
//Bit 21:16,        reg_drthp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_drthp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_drthp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
#define PK_DRTFB_BP_CORING                         0x3192
//Bit 31:22,        reserved                           
//Bit 21:16,        reg_drtbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_drtbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_drtbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
#define PK_CIRFB_BLEND_GAIN                        0x3193
//Bit 31:28,        reg_hp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
//Bit 27:24,        reg_hp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
//Bit 23:20,        reg_hp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
//Bit 19:16,        reserved                           
//Bit 15:12,        reg_bp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
//Bit 11: 8,        reg_bp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
//Bit  7: 4,        reg_bp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
//Bit  3: 0,        reserved                           
#define NR_ALPY_SSD_GAIN_OFST                      0x3194
//Bit 31:16,        reserved                           
//Bit 15: 8,        reg_nr_alp0_ssd_gain                        : gain to max ssd normalized 16 as '1'                                          . unsigned  , default = 16  
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_nr_alp0_ssd_ofst                        : offset to ssd before dividing to min_err                                      . signed    , default = -2  
#define NR_ALP0Y_ERR2CURV_TH_RATE                  0x3195
//Bit 31:24,        reg_nr_alp0_minerr_ypar0                    : threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.. unsigned  , default = 10  
//Bit 23:16,        reg_nr_alp0_minerr_ypar1                    : threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25  
//Bit 15: 8,        reg_nr_alp0_minerr_ypar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80  
//Bit  7: 0,        reg_nr_alp0_minerr_ypar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64  
#define NR_ALP0Y_ERR2CURV_LIMIT                    0x3196
//Bit 31:24,        reg_nr_alp0_minerr_ypar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63  
//Bit 23:16,        reg_nr_alp0_minerr_ypar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0   
//Bit 15: 8,        reg_nr_alp0_minerr_ypar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63  
//Bit  7: 0,        reserved                           
#define NR_ALP0C_ERR2CURV_TH_RATE                  0x3197
//Bit 31:24,        reg_nr_alp0_minerr_cpar0                    : threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.. unsigned  , default = 10  
//Bit 23:16,        reg_nr_alp0_minerr_cpar1                    : threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25  
//Bit 15: 8,        reg_nr_alp0_minerr_cpar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80  
//Bit  7: 0,        reg_nr_alp0_minerr_cpar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64  
#define NR_ALP0C_ERR2CURV_LIMIT                    0x3198
//Bit 31:24,        reg_nr_alp0_minerr_cpar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63  
//Bit 23:16,        reg_nr_alp0_minerr_cpar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0   
//Bit 15: 8,        reg_nr_alp0_minerr_cpar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63  
//Bit  7: 0,        reserved                           
#define NR_ALP0_MIN_MAX                            0x3199
//Bit 31:30,        reserved                           
//Bit 29:24,        reg_nr_alp0_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 2   
//Bit 23:22,        reserved                           
//Bit 21:16,        reg_nr_alp0_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_nr_alp0_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 2   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_nr_alp0_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
#define NR_ALP1_MIERR_CORING                       0x319a
//Bit 31:17,        reserved                           
//Bit 16,            reg_nr_alp1_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 0   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_nr_alp1_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_nr_alp1_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 3   
#define NR_ALP1_ERR2CURV_TH_RATE                   0x319b
//Bit 31:24,        reg_nr_alp1_minerr_par0                     : threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.. unsigned  , default = 0   
//Bit 23:16,        reg_nr_alp1_minerr_par1                     : threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.. unsigned  , default = 24  
//Bit 15: 8,        reg_nr_alp1_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope.. unsigned  , default = 0   
//Bit  7: 0,        reg_nr_alp1_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. unsigned  , default = 20  
#define NR_ALP1_ERR2CURV_LIMIT                     0x319c
//Bit 31:24,        reg_nr_alp1_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.. unsigned  , default = 0   
//Bit 23:16,        reg_nr_alp1_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.. unsigned  , default = 16  
//Bit 15: 8,        reg_nr_alp1_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before. unsigned  , default = 63  
//Bit  7: 0,        reserved                           
#define NR_ALP1_MIN_MAX                            0x319d
//Bit 31:30,        reserved                           
//Bit 29:24,        reg_nr_alp1_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0   
//Bit 23:22,        reserved                           
//Bit 21:16,        reg_nr_alp1_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_nr_alp1_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_nr_alp1_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
#define PK_ALP2_MIERR_CORING                       0x319e
//Bit 31:17,        reserved                           
//Bit 16,            reg_pk_alp2_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 1   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_pk_alp2_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 13  
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_pk_alp2_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 1   
#define PK_ALP2_ERR2CURV_TH_RATE                   0x319f
//Bit 31:24,        reg_pk_alp2_minerr_par0                     : threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking.. unsigned  , default = 0   
//Bit 23:16,        reg_pk_alp2_minerr_par1                     : threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255.. unsigned  , default = 24  
//Bit 15: 8,        reg_pk_alp2_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 0   
//Bit  7: 0,        reg_pk_alp2_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 20  
#define PK_ALP2_ERR2CURV_LIMIT                     0x31a0
//Bit 31:24,        reg_pk_alp2_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255.. unsigned  , default = 0   
//Bit 23:16,        reg_pk_alp2_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255.. unsigned  , default = 16  
//Bit 15: 8,        reg_pk_alp2_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 63;. unsigned  , default = 255 
//Bit  7: 0,        reserved                           
#define PK_ALP2_MIN_MAX                            0x31a1
//Bit 31:14,        reserved                           
//Bit 13: 8,        reg_pk_alp2_min                             : normalized to 64 as '1'                                                       . unsigned  , default = 0   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_pk_alp2_max                             : normalized to 64 as '1'                                                       . unsigned  , default = 63  
#define PK_FINALGAIN_HP_BP                         0x31a2
//Bit 31:16,        reserved                           
//Bit 15: 8,        reg_hp_final_gain                           : gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 40  
//Bit  7: 0,        reg_bp_final_gain                           : gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 30  
#define PK_OS_HORZ_CORE_GAIN                       0x31a3
//Bit 31:24,        reg_pk_os_hsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8   
//Bit 23:16,        reg_pk_os_hsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
//Bit 15: 8,        reg_pk_os_hmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2   
//Bit  7: 0,        reg_pk_os_hmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
#define PK_OS_VERT_CORE_GAIN                       0x31a4
//Bit 31:24,        reg_pk_os_vsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8   
//Bit 23:16,        reg_pk_os_vsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
//Bit 15: 8,        reg_pk_os_vmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2   
//Bit  7: 0,        reg_pk_os_vmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
#define PK_OS_ADPT_MISC                            0x31a5
//Bit 31:24,        reg_pk_os_minerr_core                       : coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 40  
//Bit 23:16,        reg_pk_os_minerr_gain                       : gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255;. unsigned  , default = 6   
//Bit 15: 8,        reg_pk_os_adpt_max                          : maximum limit adaptive overshoot margin (4x). 0~255;                          . unsigned  , default = 200 
//Bit  7: 0,        reg_pk_os_adpt_min                          : minimun limit adaptive overshoot margin (1x). 0~255;                          . unsigned  , default = 20  
#define PK_OS_STATIC                               0x31a6
//Bit 31:30,        reserved                           
//Bit 29:28,        reg_pk_osh_mode                             : 0~3: (2x+1) window in H direction                                             . unsigned  , default = 2   
//Bit 27:26,        reserved                           
//Bit 25:24,        reg_pk_osv_mode                             : 0~3: (2x+1) window in V direction                                             . unsigned  , default = 2   
//Bit 23:22,        reserved                           
//Bit 21:12,        reg_pk_os_down                              : static negative overshoot margin. 0~1023;                                     . unsigned  , default = 200 
//Bit 11:10,        reserved                           
//Bit  9: 0,        reg_pk_os_up                                : static positive overshoot margin. 0~1023;                                     . unsigned  , default = 200 
#define PK_NR_ENABLE                               0x31a7
//Bit 31: 4,        reserved                           
//Bit  3: 2,        reg_3d_mode                                 , 0: no 3D; 1: L/R; 2: T/B; 3: horizontal interleaved, dft = 0                                             //. unsigned  , default = 0   
//Bit  1,            reg_pk_en                                                                                                                   . unsigned  , default = 1   
//Bit  0,            reg_nr_en                                                                                                                   . unsigned  , default = 1   
#define PK_DRT_SAD_MISC                            0x31a8
//Bit 31:24,        reg_pk_sad_ver_gain                         : gain to sad[4], 16 normalized to "1";                                         . unsigned  , default = 24  
//Bit 23:16,        reg_pk_sad_hor_gain                         : gain to sad[0], 16 normalized to "1";                                         . unsigned  , default = 24  
//Bit 15:11,        reserved                           
//Bit 10: 9,        reg_pk_bias_diag                            : bias towards diag                                                             . unsigned  , default = 0   
//Bit  8,            reg_pk_debug_edge                           : show color for edge                                                           . unsigned  , default = 0   
//Bit  7: 5,        reserved                           
//Bit  4: 0,        reg_pk_drt_force                            : force direction of drt peaking filter, h2b: 0:hp drt force, 1: bp drt force; 2: bp+hp drt force, 3: no force;. unsigned  , default = 24  
#define NR_TI_DNLP_BLEND                           0x31a9
//Bit 31:11,        reserved                           
//Bit 10: 8,        reg_dnlp_input_mode                         : dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os). unsigned  , default = 4   
//Bit  7: 4,        reserved                           
//Bit  3: 2,        reg_nr_cti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:cti; 2: (nr+cti)/2; 3:cti + dlt_nr  . unsigned  , default = 1   
//Bit  1: 0,        reg_nr_lti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:lti; 2: (nr+lti)/2; 3:lti + dlt_nr  . unsigned  , default = 1   
////////////////////////////////////////////////////////////////////////////////
// new ti regsters from here
////////////////////////////////////////////////////////////////////////////////
#define LTI_DIR_CORE_ALPHA                         0x31aa
//Bit 31:30,        reserved                           
//Bit 29:24,        reg_adp_lti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 10  
//Bit 23:20,        reserved                           
//Bit 19:16,        reg_adp_lti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_adp_lti_dir_alpmin                      : min value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=10              . unsigned  , default = 0   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_adp_lti_dir_alpmax                      : max value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=63              . unsigned  , default = 63  
#define CTI_DIR_ALPHA                              0x31ab
//Bit 31:30,        reserved                           
//Bit 29:24,        reg_adp_cti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 5   
//Bit 23:20,        reserved                           
//Bit 19:16,        reg_adp_cti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0   
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_adp_cti_dir_alpmin                      : min value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=10             . unsigned  , default = 0   
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_adp_cti_dir_alpmax                      : max value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=63             . unsigned  , default = 63  
#define LTI_CTI_DF_GAIN                            0x31ac
//Bit 31:30,        reserved                           
//Bit 29:24,        reg_adp_lti_hdf_gain                        : 8 normalized to "1";  default = 16                                            . unsigned  , default = 16  
//Bit 23:22,        reserved                           
//Bit 21:16,        reg_adp_lti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12  
//Bit 15:14,        reserved                           
//Bit 13: 8,        reg_adp_cti_hdf_gain                        : 8 normalized to "1";  default = 16                                            . unsigned  , default = 16  
//Bit  7: 6,        reserved                           
//Bit  5: 0,        reg_adp_cti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12  
#define LTI_CTI_DIR_AC_DBG                         0x31ad
//Bit 31,            reserved                           
//Bit 30,            reg_adp_lti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf                                               . unsigned  , default = 1   
//Bit 29,            reserved                           
//Bit 28,            reg_adp_lti_dir_difmode                     : 0: y_dif; 1: y_dif + (u_dif+v_dif)/2;                                         . unsigned  , default = 0   
//Bit 27,            reserved                           
//Bit 26,            reg_adp_cti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf  dft=1                                        . unsigned  , default = 1   
//Bit 25:24,        reg_adp_cti_dir_difmode                     : 0: (u_dif+v_dif); 1: y_dif/2 + (u_dif+v_dif)*3/4; 2: y_dif + (u_dif+v_dif)/2; 3: y_dif*2 (not recomended). unsigned  , default = 0   
//Bit 23:22,        reg_adp_hvlti_dcblend_mode                  : 0: hlti_dc; 1:vlti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3   
//Bit 21:20,        reg_adp_hvcti_dcblend_mode                  : 0: hcti_dc; 1:vcti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3   
//Bit 19:18,        reg_adp_hvlti_acblend_mode                  : hlti_ac; 1:vlti_ac; 2: add  3;:adaptive to alpha                              . unsigned  , default = 3   
//Bit 17:16,        reg_adp_hvcti_acblend_mode                  : hcti_ac; 1:vcti_ac; 2: add  3;: adaptive to alpha                             . unsigned  , default = 3   
//Bit 15,            reserved                           
//Bit 14:12,        reg_adp_hlti_debug                          , for hlti debug, default = 0                                                   . unsigned  , default = 0   
//Bit 11,            reserved                           
//Bit 10: 8,        reg_adp_vlti_debug                          , for vlti debug, default = 0                                                   . unsigned  , default = 0   
//Bit  7,            reserved                           
//Bit  6: 4,        reg_adp_hcti_debug                          , for hcti debug, default = 0                                                   . unsigned  , default = 0   
//Bit  3,            reserved                           
//Bit  2: 0,        reg_adp_vcti_debug                          , for vcti debug, default = 0                                                   . unsigned  , default = 0   
#define HCTI_FLT_CLP_DC                            0x31ae
//Bit 31:29,        reserved                           
//Bit 28,            reg_adp_hcti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1   
//Bit 27:26,        reg_adp_hcti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8  3:[1 0 2 0 1]/4, default = 3    . unsigned  , default = 3   
//Bit 25:24,        reg_adp_hcti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2   
//Bit 23:22,        reg_adp_hcti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3     . unsigned  , default = 3   
//Bit 21:20,        reg_adp_hcti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 2        . unsigned  , default = 2   
//Bit 19:18,        reg_adp_hcti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 2        . unsigned  , default = 2   
//Bit 17:16,        reg_adp_hcti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 2       . unsigned  , default = 2   
//Bit 15:12,        reg_adp_hcti_hard_clp_win                   , window size, 0~8, default = 7                                                 . unsigned  , default = 7   
//Bit 11: 8,        reg_adp_hcti_hard_win_min                   , window size, 0~8, default = 3                                                 . unsigned  , default = 3   
//Bit  7: 5,        reserved                           
//Bit  4,            reg_adp_hcti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 1                                   . unsigned  , default = 1   
//Bit  3,            reserved                           
//Bit  2: 0,        reg_adp_hcti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 0    . unsigned  , default = 0   
#define HCTI_BST_GAIN                              0x31af
//Bit 31:24,        reg_adp_hcti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 80                         . unsigned  , default = 80  
//Bit 23:16,        reg_adp_hcti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 96                          . unsigned  , default = 96  
//Bit 15: 8,        reg_adp_hcti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 64                          . unsigned  , default = 64  
//Bit  7: 0,        reg_adp_hcti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16  
#define HCTI_BST_CORE                              0x31b0
//Bit 31:24,        reg_adp_hcti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 0                          . unsigned  , default = 0   
//Bit 23:16,        reg_adp_hcti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 0                           . unsigned  , default = 0   
//Bit 15: 8,        reg_adp_hcti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 0                           . unsigned  , default = 0   
//Bit  7: 0,        reg_adp_hcti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 0                        . unsigned  , default = 0   
#define HCTI_CON_2_GAIN_0                          0x31b1
//Bit 31:29,        reg_adp_hcti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: .... default = 2. unsigned  , default = 2   
//Bit 28:26,        reg_adp_hcti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 3                       . unsigned  , default = 3   
//Bit 25:24,        reg_adp_hcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
//Bit 23:16,        reg_adp_hcti_con_2_gain0                    , default = 25                                                                  . unsigned  , default = 25  
//Bit 15: 8,        reg_adp_hcti_con_2_gain1                    , default = 60                                                                  . unsigned  , default = 60  
//Bit  7: 0,        reg_adp_hcti_con_2_gain2                    0;, default = 0                                                                 . unsigned  , default = 0   
#define HCTI_CON_2_GAIN_1                          0x31b2
//Bit 31:24,        reg_adp_hcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
//Bit 23:16,        reg_adp_hcti_con_2_gain4                    5;, default = 5                                                                 . unsigned  , default = 5   
//Bit 15: 8,        reg_adp_hcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
//Bit  7: 0,        reg_adp_hcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
#define HCTI_OS_MARGIN                             0x31b3
//Bit 31: 8,        reserved                           
//Bit  7: 0,        reg_adp_hcti_os_margin                      : margin for hcti overshoot, default = 0                                        . unsigned  , default = 0   
#define HLTI_FLT_CLP_DC                            0x31b4
//Bit 31:29,        reserved                           
//Bit 28,            reg_adp_hlti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1   
//Bit 27:26,        reg_adp_hlti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2   
//Bit 25:24,        reg_adp_hlti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2   
//Bit 23:22,        reg_adp_hlti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2   
//Bit 21:20,        reg_adp_hlti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 2        . unsigned  , default = 2   
//Bit 19:18,        reg_adp_hlti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 2        . unsigned  , default = 2   
//Bit 17:16,        reg_adp_hlti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 2       . unsigned  , default = 2   
//Bit 15:12,        reg_adp_hlti_hard_clp_win                   , window size, 0~8, default = 2                                                 . unsigned  , default = 2   
//Bit 11: 8,        reg_adp_hlti_hard_win_min                   , window size, 0~8, default = 1                                                 . unsigned  , default = 1   
//Bit  7: 5,        reserved                           
//Bit  4,            reg_adp_hlti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 0                                   . unsigned  , default = 0   
//Bit  3,            reserved                           
//Bit  2: 0,        reg_adp_hlti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 4    . unsigned  , default = 4   
#define HLTI_BST_GAIN                              0x31b5
//Bit 31:24,        reg_adp_hlti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 40                         . unsigned  , default = 40  
//Bit 23:16,        reg_adp_hlti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 48                          . unsigned  , default = 48  
//Bit 15: 8,        reg_adp_hlti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 32                          . unsigned  , default = 32  
//Bit  7: 0,        reg_adp_hlti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16  
#define HLTI_BST_CORE                              0x31b6
//Bit 31:24,        reg_adp_hlti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5   
//Bit 23:16,        reg_adp_hlti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5   
//Bit 15: 8,        reg_adp_hlti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5   
//Bit  7: 0,        reg_adp_hlti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 3   
#define HLTI_CON_2_GAIN_0                          0x31b7
//Bit 31:29,        reg_adp_hlti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: ....., default = 2. unsigned  , default = 2   
//Bit 28:26,        reg_adp_hlti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 3                       . unsigned  , default = 3   
//Bit 25:24,        reg_adp_hlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
//Bit 23:16,        reg_adp_hlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25  
//Bit 15: 8,        reg_adp_hlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60  
//Bit  7: 0,        reg_adp_hlti_con_2_gain2                    0;, default = 90                                                                . unsigned  , default = 90  
#define HLTI_CON_2_GAIN_1                          0x31b8
//Bit 31:24,        reg_adp_hlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
//Bit 23:16,        reg_adp_hlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95  
//Bit 15: 8,        reg_adp_hlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
//Bit  7: 0,        reg_adp_hlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
#define HLTI_OS_MARGIN                             0x31b9
//Bit 31: 8,        reserved                           
//Bit  7: 0,        reg_adp_hlti_os_margin                      : margin for hlti overshoot, default = 0                                        . unsigned  , default = 0   
#define VLTI_FLT_CON_CLP                           0x31ba
//Bit 31:15,        reserved                           
//Bit 14,            reg_adp_vlti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1   
//Bit 13:12,        reg_adp_vlti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit 11:10,        reg_adp_vlti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit  9: 8,        reg_adp_vlti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit  7: 6,        reg_adp_vlti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit  5: 4,        reg_adp_vlti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 2                         . unsigned  , default = 2   
//Bit  3,            reserved                           
//Bit  2,            reg_adp_vlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
//Bit  1,            reserved                           
//Bit  0,            reg_adp_vlti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 1                        . unsigned  , default = 1   
#define VLTI_BST_GAIN                              0x31bb
//Bit 31:24,        reserved                           
//Bit 23:16,        reg_adp_vlti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 32                                 . unsigned  , default = 32  
//Bit 15: 8,        reg_adp_vlti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 32                             . unsigned  , default = 32  
//Bit  7: 0,        reg_adp_vlti_bst_gain2                      : gain to boost filter usf, default = 32                                        . unsigned  , default = 32  
#define VLTI_BST_CORE                              0x31bc
//Bit 31:24,        reserved                           
//Bit 23:16,        reg_adp_vlti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5   
//Bit 15: 8,        reg_adp_vlti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5   
//Bit  7: 0,        reg_adp_vlti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3   
#define VLTI_CON_2_GAIN_0                          0x31bd
//Bit 31:24,        reg_adp_vlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25  
//Bit 23:16,        reg_adp_vlti_con_2_gain1                    60;, default = 69                                                               . unsigned  , default = 60  
//Bit 15: 8,        reg_adp_vlti_con_2_gain2                    0;, default = 90                                                                . unsigned  , default = 90  
//Bit  7: 0,        reg_adp_vlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
#define VLTI_CON_2_GAIN_1                          0x31be
//Bit 31:24,        reg_adp_vlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95  
//Bit 23:16,        reg_adp_vlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
//Bit 15: 8,        reg_adp_vlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
//Bit  7: 0,        reg_adp_vlti_os_margin                      : margin for vlti overshoot, default = 0                                        . unsigned  , default = 0   
#define VCTI_FLT_CON_CLP                           0x31bf
//Bit 31:15,        reserved                           
//Bit 14,            reg_adp_vcti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1   
//Bit 13:12,        reg_adp_vcti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit 11:10,        reg_adp_vcti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit  9: 8,        reg_adp_vcti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit  7: 6,        reg_adp_vcti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
//Bit  5: 4,        reg_adp_vcti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 2                         . unsigned  , default = 2   
//Bit  3,            reserved                           
//Bit  2,            reg_adp_vcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
//Bit  1,            reserved                           
//Bit  0,            reg_adp_vcti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 1                        . unsigned  , default = 1   
#define VCTI_BST_GAIN                              0x31c0
//Bit 31:24,        reserved                           
//Bit 23:16,        reg_adp_vcti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 0                                  . unsigned  , default = 0   
//Bit 15: 8,        reg_adp_vcti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 0                              . unsigned  , default = 0   
//Bit  7: 0,        reg_adp_vcti_bst_gain2                      : gain to boost filter usf, default = 0                                         . unsigned  , default = 0   
#define VCTI_BST_CORE                              0x31c1
//Bit 31:24,        reserved                           
//Bit 23:16,        reg_adp_vcti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 0                                . unsigned  , default = 0   
//Bit 15: 8,        reg_adp_vcti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 0                            . unsigned  , default = 0   
//Bit  7: 0,        reg_adp_vcti_bst_core2                      : coring to boost filter usf, default = 0                                       . unsigned  , default = 0   
#define VCTI_CON_2_GAIN_0                          0x31c2
//Bit 31:24,        reg_adp_vcti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25  
//Bit 23:16,        reg_adp_vcti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60  
//Bit 15: 8,        reg_adp_vcti_con_2_gain2                    0;, default = 90                                                                . unsigned  , default = 90  
//Bit  7: 0,        reg_adp_vcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
#define VCTI_CON_2_GAIN_1                          0x31c3
//Bit 31:24,        reg_adp_vcti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95  
//Bit 23:16,        reg_adp_vcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
//Bit 15: 8,        reg_adp_vcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
//Bit  7: 0,        reg_adp_vcti_os_margin                      : margin for vcti overshoot, default = 0                                        . unsigned  , default = 0   
#define SHARP_3DLIMIT                              0x31c4
//Bit 31:29,        reserved                           
//Bit 28:16,        reg_3d_mid_width                            ,width of left part of 3d input, dft = half size of input width  default = 0    . unsigned  , default = 960 
//Bit 15:13,        reserved                           
//Bit 12: 0,        reg_3d_mid_height                           ,height of left part of 3d input, dft = half size of input height  default = 0  . unsigned  , default = 540 
#define DNLP_EN                                    0x31c5
//Bit 31: 1,        reserved                           
//Bit  0,            reg_dnlp_en                                                                                                                 . unsigned  , default = 1   
#define DNLP_00                                    0x31c6
//Bit 31: 0,        reg_dnlp_ygrid0                             : dnlp00                                                                        . unsigned  , default = 32'h08060402
#define DNLP_01                                    0x31c7
//Bit 31: 0,        reg_dnlp_ygrid1                             : dnlp01                                                                        . unsigned  , default = 32'h100e0c0a
#define DNLP_02                                    0x31c8
//Bit 31: 0,        reg_dnlp_ygrid2                             : dnlp02                                                                        . unsigned  , default = 32'h1a171412
#define DNLP_03                                    0x31c9
//Bit 31: 0,        reg_dnlp_ygrid3                             : dnlp03                                                                        . unsigned  , default = 32'h2824201d
#define DNLP_04                                    0x31ca
//Bit 31: 0,        reg_dnlp_ygrid4                             : dnlp04                                                                        . unsigned  , default = 32'h3834302c
#define DNLP_05                                    0x31cb
//Bit 31: 0,        reg_dnlp_ygrid5                             : dnlp05                                                                        . unsigned  , default = 32'h4b45403c
#define DNLP_06                                    0x31cc
//Bit 31: 0,        reg_dnlp_ygrid6                             : dnlp06                                                                        . unsigned  , default = 32'h605b5550
#define DNLP_07                                    0x31cd
//Bit 31: 0,        reg_dnlp_ygrid7                             : dnlp07                                                                        . unsigned  , default = 32'h80787068
#define DNLP_08                                    0x31ce
//Bit 31: 0,        reg_dnlp_ygrid8                             : dnlp08                                                                        . unsigned  , default = 32'ha0989088
#define DNLP_09                                    0x31cf
//Bit 31: 0,        reg_dnlp_ygrid9                             : dnlp09                                                                        . unsigned  , default = 32'hb8b2aca6
#define DNLP_10                                    0x31d0
//Bit 31: 0,        reg_dnlp_ygrid10                            : dnlp10                                                                        . unsigned  , default = 32'hc8c4c0bc
#define DNLP_11                                    0x31d1
//Bit 31: 0,        reg_dnlp_ygrid11                            : dnlp11                                                                        . unsigned  , default = 32'hd4d2cecb
#define DNLP_12                                    0x31d2
//Bit 31: 0,        reg_dnlp_ygrid12                            : dnlp12                                                                        . unsigned  , default = 32'hdad8d7d6
#define DNLP_13                                    0x31d3
//Bit 31: 0,        reg_dnlp_ygrid13                            : dnlp13                                                                        . unsigned  , default = 32'he2e0dedc
#define DNLP_14                                    0x31d4
//Bit 31: 0,        reg_dnlp_ygrid14                            : dnlp14                                                                        . unsigned  , default = 32'hf0ece8e4
#define DNLP_15                                    0x31d5
//Bit 31: 0,        reg_dnlp_ygrid15                            : dnlp15                                                                        . unsigned  , default = 32'hfffcf8f4
#define DEMO_CRTL                                  0x31d6
//Bit 31:19,        reserved                           
//Bit 18:17,        demo_disp_position                                                                                                          . unsigned  , default = 2   
//Bit 16,            demo_hsvsharp_enable                                                                                                        . unsigned  , default = 0   
//Bit 15:13,        reserved                           
//Bit 12: 0,        demo_left_top_screen_width                  :                                                                               . unsigned  , default = 360 
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  sharp_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vcbus_regs.h
//

#endif // REGISTER_H

