// ----------------------------------------------------------------------
// This file is automatically generated from the script:
// 
// ./create_headers_from_register_map_h.pl
// 
// and was applied to the file
// 
// ./register_map.h
// 
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
// 
#ifdef C_ARC_POINTER_H
#else
#define C_ARC_POINTER_H


#include "dos_c_arc_pointer_reg.h"
//
// Reading file:  ./register_map.h
//
// synopsys translate_off
// synopsys translate_on
//
// Reading file:  stb_define.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  STB_CBUS_BASE = 0x16
// -----------------------------------------------
// There are two instantiations under one CBUS slave.  Each CBUS slave can support
// 256 registers.  Each demux is allocated 128 registers so set the offset in
// the middle
// Copy this define but don't add a base address
#define SECOND_DEMUX_OFFSET_0  0x50
#define THIRD_DEMUX_OFFSET_0   0xa0
//========================================================================
//  STB TOP Registers				    (8'hf0 - 8'hf7)
//========================================================================
// bit 30:28 -- ciplus_o_sel
// bit 27:26 -- ciplus_i_sel
// bit 25 -- use FAIL fro TS2
// bit 24 -- use FAIL fro TS1
// bit 23 -- use FAIL fro TS0
// bit 22 -- invert fec_error for S2P1
// bit 21 -- invert fec_data for S2P1
// bit 20 -- invert fec_sync for S2P1
// bit 19 -- invert fec_valid for S2P1
// bit 18 -- invert fec_clk for S2P1
// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
// Bit 15 -- enable_des_pl_clk
// Bit 14:13 -- reserved
// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
// bit 7 -- enable_des_pl
// bit 6 -- invert fec_error for S2P0
// bit 5 -- invert fec_data for S2P0
// bit 4 -- invert fec_sync for S2P0
// bit 3 -- invert fec_valid for S2P0
// bit 2 -- invert fec_clk for S2P0
// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
#define P_STB_TOP_CONFIG                           (volatile unsigned long *)0xc1105bc0
// 31:28 - s2p1_clk_div
// 27:24 - s2p0_clk_div
// 23    - s2p1_disable
// 22    - s2p0_disable
// 21    - Reserved
// 20 -- TS_OUT_error_INVERT
// 19 -- TS_OUT_data_INVERT
// 18 -- TS_OUT_sync_INVERT
// 17 -- TS_OUT_valid_INVERT
// 16 -- TS_OUT_clk_INVERT
// 15:8 -- TS_package_length_sub_1 (default : 187)
//  7:0 -- fec_sync_byte (default : 0x47)
#define P_TS_TOP_CONFIG                            (volatile unsigned long *)0xc1105bc4
// Bit 23:16 -- file_m2ts_skip_bytes
// Bit 15:8 -- des_out_dly
// Bit 7:6 -- transport_scrambling_control_odd // should be 3
// Bit 5 -- ts_hiu_enable
// Bit 4:0 -- fec_clk_div
#define P_TS_FILE_CONFIG                           (volatile unsigned long *)0xc1105bc8
// Bit 13:8 -- des ts pl state   -- Read Only
// Bit 3:0 PID index to 8 PID to get key-set
// auto increse after TS_PL_PID_DATA read/write
#define P_TS_PL_PID_INDEX                          (volatile unsigned long *)0xc1105bcc
// Bit 13 -- PID match disble
// Bit 12:0 -- PID
#define P_TS_PL_PID_DATA                           (volatile unsigned long *)0xc1105bd0
#define P_COMM_DESC_KEY0                           (volatile unsigned long *)0xc1105bd4
#define P_COMM_DESC_KEY1                           (volatile unsigned long *)0xc1105bd8
#define P_COMM_DESC_KEY_RW                         (volatile unsigned long *)0xc1105bdc
// CI+ Register defines
// Bits[31:0] of the key
#define P_CIPLUS_KEY0                              (volatile unsigned long *)0xc1105be0
// Bits[63:32] of the key
#define P_CIPLUS_KEY1                              (volatile unsigned long *)0xc1105be4
// Bits[95:64] of the key
#define P_CIPLUS_KEY2                              (volatile unsigned long *)0xc1105be8
// Bits[127:96] of the key
#define P_CIPLUS_KEY3                              (volatile unsigned long *)0xc1105bec
// bit[5] write AES IV B value
// bit[4] write AES IV A value
// bit[3] write AES B key
// bit[2] write AES A key
// bit[1] write DES B key
// bit[0] write DES A key
#define P_CIPLUS_KEY_WR                            (volatile unsigned long *)0xc1105bf0
// [15:8]   TS out delay.  This controls the rate at which the CIplus module drives TS out
// [3]      General enable for the ciplus module
// [2]      AES CBC disable (default should be 0 to enable AES CBC)
// [1]      AES Enable
// [0]      DES Eanble
#define P_CIPLUS_CONFIG                            (volatile unsigned long *)0xc1105bf4
// bit[31:28] AES IV endian
// bit[27:24] AES message out endian
// bit[23:20] AES message in endian
// bit[19:16] AES key endian
// bit[15:11]  unused
// bit[10:8]  DES message out endian
// bit[6:4]   DES message in endian
// bit[2:0]   DES key endian
#define P_CIPLUS_ENDIAN                            (volatile unsigned long *)0xc1105bf8
//
// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
//        Instead, since the demux has multiple instances (and many registers) use a separate
//        script to create a separate stb_define.h for C-code.  
//========================================================================
//  STB Registers				    (8'h00 - 8'h4f)
//
//========================================================================
// STB registers are 8'h0x
// Bit 15:0 -- version number : 0x0002  (v0.01)
// Bit 15 -- fec_core_select 1 - select descramble output
// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File 
// Bit 11 -- FEC_CLK
// Bit 10 -- SOP
// Bit 9 -- D_VALID
// Bit 8 -- D_FAIL
// Bit 7:0 -- D_DATA 7:0
// bit 31 -- enable_free_clk_fec_data_valid
// bit 30 -- enable_free_clk_stb_reg
// bit 29 -- reserved
// bit 28 -- disable_pre_incomplete_section_fix
// bit 27 -- pointer_field_multi_pre_en
// bit 26 -- ignore_pre_incomplete_section
// bit 25 -- video2_enable
// bit 24:22 -- video2_type
// bit 21 -- do_not_trust_pes_package_length
// bit 20 (bit 4) -- Bypass use recoder path
// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
// bit 18 (bit 2) -- Disable Splicing
// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
// Bit 15 - do not trust section length
// Bit 14 - om cmd push even zero
// Bit 13 - reserved
// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
// Bit 11 - discard_av_package -- for ts_recorder use only 
// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
// Bit 9 - ts_recorder_enable
// Bit 8 - (table_id == 0xff) means section_end
// Bit 7 - do not send uncomplete section
// Bit 6 - do not discard duplicate package
// Bit 5 - search SOP when trasport_error_indicator
// Bit 4 - stb demux enable
// Bit 3 - do not reset state machine on SOP
// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
// Bit 1 - do not use SOP input ( check FEC sync byte instead )
// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
// bit 15:8 demux package length - 1 ( default : 187 )
// bit 7:0 default is 0x47
// bit 31:16 -- filter memory write data hi[31:16]
// bit 15:0 -- filter memory write data low [15:0]
// bit 31:24 -- advanced setting hi
// bit 23:16 -- advanced setting low
// bit 15 -- filter memory write data request
// bit 7:0 -- filter memory write addr
// bit 13:8 demux state  -- read only
// bit 7:4 -- maxnum section filter compare address
// bit 3:0 -- maxnum PID filter compare address
// bit 15 - transport_error_indicator
// bit 14 - payload_unit_start_indicator
// bit 13 - transport_priority
// bit 12:0 - PID
// bit 7:6 transport_scrambling_control
// bit 5:4 adaptation_field_control
// bit 3:0 continuity_counter
// bit 15:12 -- om_cmd_count (read only)
// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
// bit   5:3 -- type_stb_om_w_rd (read only)
// bit     2 -- unit_start_stb_om_w_rd (read only)
// bit     1 -- om_cmd_overflow (read only)
// bit     0 -- om_cmd_pending (read) 
// bit     0 -- om_cmd_read_finished (write)
// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
// bit 11:0 -- offset for section data
// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
// bit 7:4 -- section buffer size for group 1
// bit 11:8 -- section buffer size for group 2
// bit 15:12 -- section buffer size for group 3
// section buffer busy status for buff 31:0 ( Read Only )
// section buffer write status for buff 31:0 -- Read
// clear buffer status ( buff READY and BUSY ) -- write
// bit 4:0 -- SEC_BUFFER_INDEX   RW
// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
// bit 14 -- output_section_buffer_valid
// bit 15 -- section_reset_busy (Read Only)
// bit 9:5 -- BYPASS PID number
// bit 4:0 -- PCR PID number
// bit 15:0 -- stream_id filter bit enable
// bit 7:0 -- stream_id filter target
// bit 12 -- PCR_EN
// bit 11:0 -- PCR90K_DIV
// bit 15:0 -- PCR[31:0] R/W
// bit 15:0 -- VPTS[31:0] R/W
// bit 15:0 -- VDTS[31:0] R/W
// bit 15:0 -- APTS[31:0] R/W
// bit 15:0 -- SPTS[31:0] R/W
// read -- status, write 1 clear status
// bit 15 -- SUB_PTS[32]
// bit 14 -- AUDIO_PTS[32]
// bit 13 -- VIDEO_DTS[32]
// bit 12 -- VIDEO_PTS[32]
// bit 3 -- sub_pts_ready
// bit 2 -- audio_pts_ready
// bit 1 -- video_dts_ready
// bit 0 -- video_pts_ready
// bit 3:0 --
//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0] 
//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
//  2 -- pes_package_bytes_left[15:0]
//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
// 
// read only
// default : 0x807f
// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40) 
// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
// 15:0  WRITE 1 CLEAR to clear interrupt source
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int 
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready 
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN 
// Bit 5:3 - demux om write endian control for bypass
// Bit 2:0 - demux om write endian control for section
// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
// Bit 17:15 - demux om write endian control for SUB_PACKET
// Bit 14:12 - demux om write endian control for AUDIO_PACKET
// Bit 11:9  - demux om write endian control for VIDEO_PACKET
// 
// When Bit 31 - 0 write will indicate all type else use Bit 8:6
// Bit 8:6 - demux om write endian control for else
// Bit 15:8 -- last_burst_threshold
// Bit 7 -- use hi_bsf interface
// Bit 6:2 - fec_clk_div
// Bit 1 ts_source_sel 
// Bit 0 - Hiu TS generate enable 
// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
// bit 10 -- mask bit for SUB_AHB_DMA_EN
// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
// bit 8 -- mask bit for SECTION_AHB_DMA_EN
// bit 7 -- mask bit for recoder stream
// bit 6:0 -- mask bit for each type
// bit 31:0 -- vb_wr_ptr for video PDTS 
// bit 31:0 -- ab_wr_ptr for audio PDTS
// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
// bit 19:0 -- SB_START (sb_start << 12 == byte address);  
// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun) 
// bit 31:0 -- sb_wr_ptr for sub PES
// bit 31:16 -- ob_wr_ptr for other PES
// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
// bit 19:0 -- OB_START (ob_start << 12 == byte address);  
// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun) 
// bit 31:0 -- ob_wr_ptr for sub PES
// 15:0  DEMUX interrupt MASK
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int 
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready 
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN 
// 31:16 VIDEO PID filter data
//15 -- splicing VIDEO PID change enable 
//14:10 -- VIDEO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only) 
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 31:16 AUDIO PID filter data
//15 -- splicing AUDIO PID change enable 
//14:10 -- AUDIO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only) 
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 23:16 M2TS_SKIP_BYTES
// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
// 7:0  PACKAGE BYTE COUNT (Read Only)
// 15:0 2 bytes strong sync add to PES
// bit 15 -- stb_om_ren
// bit 14:11 -- reserved
// bit  10:0 -- OM_DATA_RD_ADDR
// bit 15:0 -- OM_DATA_RD
// AUTO STOP SETTING for 32 channels
// 4-nbits per channel
// when write
// bit 3 -- set section active
// bit 2:0 -- auto stop after count (0 means never stop)
// when read
// bit 3 -- current active status (1 - active, 0 - stopped )
// bit 2:0 -- count down to auto stop
// section 31:24
// section 23:16
// section 15:8
// section 7:0
// bit 31:0 reset channel status - each bit reset each channel 
// read -- 32 channel status 
// bit 4 -- video_stamp_use_dts
// bit 3 -- audio_stamp_sync_1_en 
// bit 2 -- audio_stamp_insert_en 
// bit 1 -- video_stamp_sync_1_en 
// bit 0 -- video_stamp_insert_en 
// Write : Bit[4:0] secter filter number for reset
// Read  : select according to output_section_buffer_valid : 
//         per bit per section buffer valid status
//         or section_buffer_ignore
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  stb_define.h
//
//
// Reading file:  periphs_reg.h
//
// $periphs/rtl/periphs_core register defines for the 
// APB bus
// -------------------------------------------------------------------
// PSEL Group #0:  0x000 ~ 0xFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS0_CBUS_BASE = 0x20
// -----------------------------------------------
// The following are handled by $periphs/rtl/periphs_reg.v
#define P_PREG_CTLREG0_ADDR                        (volatile unsigned long *)0xc1108000
// ----------------------------
#define P_PREG_PAD_GPIO6_EN_N                      (volatile unsigned long *)0xc1108020
#define P_PREG_PAD_GPIO6_O                         (volatile unsigned long *)0xc1108024
#define P_PREG_PAD_GPIO6_I                         (volatile unsigned long *)0xc1108028
// ----------------------------
// ----------------------------
#define P_PREG_JTAG_GPIO_ADDR                      (volatile unsigned long *)0xc110802c
// ----------------------------
// Pre-defined GPIO addresses
// ----------------------------
#define P_PREG_PAD_GPIO0_EN_N                      (volatile unsigned long *)0xc1108030
#define P_PREG_PAD_GPIO0_O                         (volatile unsigned long *)0xc1108034
#define P_PREG_PAD_GPIO0_I                         (volatile unsigned long *)0xc1108038
// ----------------------------
#define P_PREG_PAD_GPIO1_EN_N                      (volatile unsigned long *)0xc110803c
#define P_PREG_PAD_GPIO1_O                         (volatile unsigned long *)0xc1108040
#define P_PREG_PAD_GPIO1_I                         (volatile unsigned long *)0xc1108044
// ----------------------------
#define P_PREG_PAD_GPIO2_EN_N                      (volatile unsigned long *)0xc1108048
#define P_PREG_PAD_GPIO2_O                         (volatile unsigned long *)0xc110804c
#define P_PREG_PAD_GPIO2_I                         (volatile unsigned long *)0xc1108050
// ----------------------------
#define P_PREG_PAD_GPIO3_EN_N                      (volatile unsigned long *)0xc1108054
#define P_PREG_PAD_GPIO3_O                         (volatile unsigned long *)0xc1108058
#define P_PREG_PAD_GPIO3_I                         (volatile unsigned long *)0xc110805c
// ----------------------------
#define P_PREG_PAD_GPIO4_EN_N                      (volatile unsigned long *)0xc1108060
#define P_PREG_PAD_GPIO4_O                         (volatile unsigned long *)0xc1108064
#define P_PREG_PAD_GPIO4_I                         (volatile unsigned long *)0xc1108068
// ----------------------------
#define P_PREG_PAD_GPIO5_EN_N                      (volatile unsigned long *)0xc110806c
#define P_PREG_PAD_GPIO5_O                         (volatile unsigned long *)0xc1108070
#define P_PREG_PAD_GPIO5_I                         (volatile unsigned long *)0xc1108074
// ----------------------------
// A9 and L2 cache
// ----------------------------
#define P_A9_STATUS1                               (volatile unsigned long *)0xc110807c
#define P_A9_CFG0                                  (volatile unsigned long *)0xc1108080
#define P_A9_CFG1                                  (volatile unsigned long *)0xc1108084
#define P_A9_CFG2                                  (volatile unsigned long *)0xc1108088
#define P_A9_PERIPH_BASE                           (volatile unsigned long *)0xc110808c
#define P_A9_L2_REG_BASE                           (volatile unsigned long *)0xc1108090
#define P_A9_L2_STATUS                             (volatile unsigned long *)0xc1108094
#define P_A9_POR_CFG                               (volatile unsigned long *)0xc1108098
#define P_A9_STATUS2                               (volatile unsigned long *)0xc110809c
#define P_AXI_REG_EN                               (volatile unsigned long *)0xc11080a0
#define P_A9_CFG3                                  (volatile unsigned long *)0xc11080a4
#define P_A9_CFG4                                  (volatile unsigned long *)0xc11080a8
#define P_A9_STATUS3                               (volatile unsigned long *)0xc11080ac
// ----------------------------
// Pin Mux  (9)
// ----------------------------
#define P_PERIPHS_PIN_MUX_0                        (volatile unsigned long *)0xc11080b0
#define P_PERIPHS_PIN_MUX_1                        (volatile unsigned long *)0xc11080b4
#define P_PERIPHS_PIN_MUX_2                        (volatile unsigned long *)0xc11080b8
#define P_PERIPHS_PIN_MUX_3                        (volatile unsigned long *)0xc11080bc
#define P_PERIPHS_PIN_MUX_4                        (volatile unsigned long *)0xc11080c0
#define P_PERIPHS_PIN_MUX_5                        (volatile unsigned long *)0xc11080c4
#define P_PERIPHS_PIN_MUX_6                        (volatile unsigned long *)0xc11080c8
#define P_PERIPHS_PIN_MUX_7                        (volatile unsigned long *)0xc11080cc
#define P_PERIPHS_PIN_MUX_8                        (volatile unsigned long *)0xc11080d0
#define P_PERIPHS_PIN_MUX_9                        (volatile unsigned long *)0xc11080d4
#define P_PERIPHS_PIN_MUX_10                       (volatile unsigned long *)0xc11080d8
#define P_PERIPHS_PIN_MUX_11                       (volatile unsigned long *)0xc11080dc
#define P_PERIPHS_PIN_MUX_12                       (volatile unsigned long *)0xc11080e0
// ----------------------------
// Pad conntrols
// ----------------------------
#define P_PAD_PULL_UP_REG6                         (volatile unsigned long *)0xc11080e4
#define P_PAD_PULL_UP_REG0                         (volatile unsigned long *)0xc11080e8
#define P_PAD_PULL_UP_REG1                         (volatile unsigned long *)0xc11080ec
#define P_PAD_PULL_UP_REG2                         (volatile unsigned long *)0xc11080f0
#define P_PAD_PULL_UP_REG3                         (volatile unsigned long *)0xc11080f4
#define P_PAD_PULL_UP_REG4                         (volatile unsigned long *)0xc11080f8
#define P_PAD_PULL_UP_REG5                         (volatile unsigned long *)0xc11080fc
// ----------------------------
// Random (2)
// ----------------------------
#define P_RAND64_ADDR0                             (volatile unsigned long *)0xc1108100
#define P_RAND64_ADDR1                             (volatile unsigned long *)0xc1108104
// ---------------------------
// Ethernet (1)
// ----------------------------
#define P_PREG_ETHERNET_ADDR0                      (volatile unsigned long *)0xc1108108
// ---------------------------
// AM_ANALOG_TOP
// ----------------------------
#define P_PREG_AM_ANALOG_ADDR                      (volatile unsigned long *)0xc110810c
// ---------------------------
// Mali55 (1)
// ----------------------------
#define P_PREG_MALI_BYTE_CNTL                      (volatile unsigned long *)0xc1108110
// ---------------------------
// WIFI (1)
// ----------------------------
#define P_PREG_WIFI_CNTL                           (volatile unsigned long *)0xc1108114
#define P_PAD_PULL_UP_EN_REG0                      (volatile unsigned long *)0xc1108120
#define P_PAD_PULL_UP_EN_REG1                      (volatile unsigned long *)0xc1108124
#define P_PAD_PULL_UP_EN_REG2                      (volatile unsigned long *)0xc1108128
#define P_PAD_PULL_UP_EN_REG3                      (volatile unsigned long *)0xc110812c
#define P_PAD_PULL_UP_EN_REG4                      (volatile unsigned long *)0xc1108130
#define P_PAD_PULL_UP_EN_REG5                      (volatile unsigned long *)0xc1108134
#define P_PAD_PULL_UP_EN_REG6                      (volatile unsigned long *)0xc1108138
// ---------------------------
// SATA 
// ----------------------------
// `define PREG_SATA_REG0                      8'h50
// `define PREG_SATA_REG1                      8'h51
// `define PREG_SATA_REG2                      8'h52
// `define PREG_SATA_REG3                      8'h53
// `define PREG_SATA_REG4                      8'h54
// `define PREG_SATA_REG5                      8'h55
// ---------------------------
// Generic production test
// ----------------------------
#define P_PROD_TEST_REG0                           (volatile unsigned long *)0xc11081a0
#define P_PROD_TEST_REG1                           (volatile unsigned long *)0xc110819c
// ---------------------------
// am_analog_top
// ----------------------------
#define P_METAL_REVISION                           (volatile unsigned long *)0xc11081a8
#define P_ADC_TOP_MISC                             (volatile unsigned long *)0xc11081ac
#define P_DPLL_TOP_MISC                            (volatile unsigned long *)0xc11081b0
#define P_ANALOG_TOP_MISC                          (volatile unsigned long *)0xc11081b4
#define P_AM_ANALOG_TOP_REG0                       (volatile unsigned long *)0xc11081b8
#define P_AM_ANALOG_TOP_REG1                       (volatile unsigned long *)0xc11081bc
// ---------------------------
// Sticky regs
// ----------------------------
#define P_PREG_STICKY_REG0                         (volatile unsigned long *)0xc11081f0
#define P_PREG_STICKY_REG1                         (volatile unsigned long *)0xc11081f4
#define P_PREG_WRITE_ONCE_REG                      (volatile unsigned long *)0xc11081f8
// ---------------------------
// AM Ring Oscillator 
// ----------------------------
#define P_AM_RING_OSC_REG0                         (volatile unsigned long *)0xc11081fc
// -------------------------------------------------------------------
// PSEL Group #1:  0x400 ~ 0x7FF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS1_CBUS_BASE = 0x21
// -----------------------------------------------
// ----------------------------
// $usb/rtl/usb_reg.v   (8)
// ----------------------------
// Moved to base 8'h22
// `define USB_ADDR0                      8'h00
// `define USB_ADDR1                      8'h01
// `define USB_ADDR2                      8'h02
// `define USB_ADDR3                      8'h03
// `define USB_ADDR4                      8'h04
// `define USB_ADDR5                      8'h05
// `define USB_ADDR6                      8'h06
// `define USB_ADDR7                      8'h07
// `define USB_ADDR8                      8'h08
// `define USB_ADDR9                      8'h09
// `define USB_ADDR10                     8'h0a
// `define USB_ADDR11                     8'h0b
// `define USB_ADDR12                     8'h0c
// `define USB_ADDR13                     8'h0d
// `define USB_ADDR14                     8'h0e
// `define USB_ADDR15                     8'h0f
// ----------------------------
// Smart Card (8)
// ----------------------------
#define P_SMARTCARD_REG0                           (volatile unsigned long *)0xc1108440
#define P_SMARTCARD_REG1                           (volatile unsigned long *)0xc1108444
#define P_SMARTCARD_REG2                           (volatile unsigned long *)0xc1108448
#define P_SMARTCARD_STATUS                         (volatile unsigned long *)0xc110844c
#define P_SMARTCARD_INTR                           (volatile unsigned long *)0xc1108450
#define P_SMARTCARD_REG5                           (volatile unsigned long *)0xc1108454
#define P_SMARTCARD_REG6                           (volatile unsigned long *)0xc1108458
#define P_SMARTCARD_FIFO                           (volatile unsigned long *)0xc110845c
#define P_SMARTCARD_REG8                           (volatile unsigned long *)0xc1108460
// ----------------------------
// IR Remote (8)
// ----------------------------
#define P_IR_DEC_LDR_ACTIVE                        (volatile unsigned long *)0xc1108480
#define P_IR_DEC_LDR_IDLE                          (volatile unsigned long *)0xc1108484
#define P_IR_DEC_LDR_REPEAT                        (volatile unsigned long *)0xc1108488
#define P_IR_DEC_BIT_0                             (volatile unsigned long *)0xc110848c
#define P_IR_DEC_REG0                              (volatile unsigned long *)0xc1108490
#define P_IR_DEC_FRAME                             (volatile unsigned long *)0xc1108494
#define P_IR_DEC_STATUS                            (volatile unsigned long *)0xc1108498
#define P_IR_DEC_REG1                              (volatile unsigned long *)0xc110849c
// ----------------------------
// Demod Sampling
// ----------------------------
#define P_DEMOD_ADC_SAMPLING                       (volatile unsigned long *)0xc11084b4
// ----------------------------
// WIFI
// ----------------------------
// `define WIFI_ADC_SAMPLING               8'h2e
// `define WIFI_ADC_READBACK               8'h2f
// ----------------------------
// UART0
// ----------------------------
#define P_UART0_WFIFO                              (volatile unsigned long *)0xc11084c0
#define P_UART0_RFIFO                              (volatile unsigned long *)0xc11084c4
#define P_UART0_CONTROL                            (volatile unsigned long *)0xc11084c8
#define P_UART0_STATUS                             (volatile unsigned long *)0xc11084cc
#define P_UART0_MISC                               (volatile unsigned long *)0xc11084d0
#define P_UART0_REG5                               (volatile unsigned long *)0xc11084d4
// ----------------------------
// UART1
// ----------------------------
#define P_UART1_WFIFO                              (volatile unsigned long *)0xc11084dc
#define P_UART1_RFIFO                              (volatile unsigned long *)0xc11084e0
#define P_UART1_CONTROL                            (volatile unsigned long *)0xc11084e4
#define P_UART1_STATUS                             (volatile unsigned long *)0xc11084e8
#define P_UART1_MISC                               (volatile unsigned long *)0xc11084ec
#define P_UART1_REG5                               (volatile unsigned long *)0xc11084f0
// ----------------------------
// I2C Master (8)
// ----------------------------
#define P_I2C_M_0_CONTROL_REG                      (volatile unsigned long *)0xc1108500
    #define     I2C_M_MANUAL_SDA_I        26
    #define     I2C_M_MANUAL_SCL_I        25
    #define     I2C_M_MANUAL_SDA_O        24
    #define     I2C_M_MANUAL_SCL_O        23
    #define     I2C_M_MANUAL_EN           22
    #define     I2C_M_DELAY_MSB           21
    #define     I2C_M_DELAY_LSB           12
    #define     I2C_M_DATA_CNT_MSB        11
    #define     I2C_M_DATA_CNT_LSB        8
    #define     I2C_M_CURR_TOKEN_MSB      7
    #define     I2C_M_CURR_TOKEN_LSB      4
    #define     I2C_M_ERROR               3
    #define     I2C_M_STATUS              2
    #define     I2C_M_ACK_IGNORE          1
    #define     I2C_M_START               0
#define P_I2C_M_0_SLAVE_ADDR                       (volatile unsigned long *)0xc1108504
#define P_I2C_M_0_TOKEN_LIST0                      (volatile unsigned long *)0xc1108508
#define P_I2C_M_0_TOKEN_LIST1                      (volatile unsigned long *)0xc110850c
#define P_I2C_M_0_WDATA_REG0                       (volatile unsigned long *)0xc1108510
#define P_I2C_M_0_WDATA_REG1                       (volatile unsigned long *)0xc1108514
#define P_I2C_M_0_RDATA_REG0                       (volatile unsigned long *)0xc1108518
#define P_I2C_M_0_RDATA_REG1                       (volatile unsigned long *)0xc110851c
// ----------------------------
// I2C Slave (3)
// ----------------------------
#define P_I2C_S_CONTROL_REG                        (volatile unsigned long *)0xc1108540
#define P_I2C_S_SEND_REG                           (volatile unsigned long *)0xc1108544
#define P_I2C_S_RECV_REG                           (volatile unsigned long *)0xc1108548
#define P_I2C_S_CNTL1_REG                          (volatile unsigned long *)0xc110854c
// ----------------------------
// PWM / DS A/B
// ----------------------------
#define P_PWM_PWM_A                                (volatile unsigned long *)0xc1108550
#define P_PWM_PWM_B                                (volatile unsigned long *)0xc1108554
#define P_PWM_MISC_REG_AB                          (volatile unsigned long *)0xc1108558
#define P_PWM_DELTA_SIGMA_AB                       (volatile unsigned long *)0xc110855c
// ---------------------------
// EFUSE (4)
// ----------------------------
// Moved to the Secure APB3 bus
// `define EFUSE_CNTL0                     8'h58
// `define EFUSE_CNTL1                     8'h59
// `define EFUSE_CNTL2                     8'h5a
// `define EFUSE_CNTL3                     8'h5b
// `define EFUSE_CNTL4                     8'h5c
// ---------------------------------------------
// Separate APB slave that shares the CBUS/APB
// register space of the static registers
// ---------------------------------------------
#define P_ATAPI_IDEREG0                            (volatile unsigned long *)0xc1108580
   #define IDE_UDMA_PIO_STATE         15
   #define IDE_BUSY                   14
   #define IDE_ERROR_BIT              13
   #define IDE_DMARQ_BIT              12
   #define IDE_IORDY_BIT              11
   #define IDE_IORDY_EN_BIT           10
   #define IDE_DIS_CSEL_BIT            9
   #define IDE_CSEL_BIT                8
   #define IDE_IRQ14                   2
   #define IDE_ATAPI_GPIO_EN           3
   #define IDE_DMARQ_FULL              1
   #define IDE_ENABLE                  0
#define P_ATAPI_IDEREG1                            (volatile unsigned long *)0xc1108584
#define P_ATAPI_IDEREG2                            (volatile unsigned long *)0xc1108588
    #define IDE_XFER_CNT_MSB_BIT      18
    #define IDE_XFER_CNT_LSB_BIT       0
#define P_ATAPI_CYCTIME                            (volatile unsigned long *)0xc110858c
#define P_ATAPI_IDETIME                            (volatile unsigned long *)0xc1108590
#define P_ATAPI_PIO_TIMING                         (volatile unsigned long *)0xc1108594
#define P_ATAPI_TABLE_ADD_REG                      (volatile unsigned long *)0xc1108598
#define P_ATAPI_IDEREG3                            (volatile unsigned long *)0xc110859c
#define P_ATAPI_UDMA_REG0                          (volatile unsigned long *)0xc11085a0
#define P_ATAPI_UDMA_REG1                          (volatile unsigned long *)0xc11085a4
// Room for registers here
#define P_TRANS_PWMA_REG0                          (volatile unsigned long *)0xc11085c0
#define P_TRANS_PWMA_REG1                          (volatile unsigned long *)0xc11085c4
#define P_TRANS_PWMA_MUX0                          (volatile unsigned long *)0xc11085c8
#define P_TRANS_PWMA_MUX1                          (volatile unsigned long *)0xc11085cc
#define P_TRANS_PWMA_MUX2                          (volatile unsigned long *)0xc11085d0
#define P_TRANS_PWMA_MUX3                          (volatile unsigned long *)0xc11085d4
#define P_TRANS_PWMA_MUX4                          (volatile unsigned long *)0xc11085d8
#define P_TRANS_PWMA_MUX5                          (volatile unsigned long *)0xc11085dc
#define P_TRANS_PWMB_REG0                          (volatile unsigned long *)0xc11085e0
#define P_TRANS_PWMB_REG1                          (volatile unsigned long *)0xc11085e4
#define P_TRANS_PWMB_MUX0                          (volatile unsigned long *)0xc11085e8
#define P_TRANS_PWMB_MUX1                          (volatile unsigned long *)0xc11085ec
#define P_TRANS_PWMB_MUX2                          (volatile unsigned long *)0xc11085f0
#define P_TRANS_PWMB_MUX3                          (volatile unsigned long *)0xc11085f4
#define P_TRANS_PWMB_MUX4                          (volatile unsigned long *)0xc11085f8
#define P_TRANS_PWMB_MUX5                          (volatile unsigned long *)0xc11085fc
// ----------------------------
// NAND (21)
// ----------------------------
#define P_NAND_START                               (volatile unsigned long *)0xc1108600
#define P_NAND_ADR_CMD                             (volatile unsigned long *)0xc1108628
#define P_NAND_ADR_STS                             (volatile unsigned long *)0xc110862c
#define P_NAND_END                                 (volatile unsigned long *)0xc110863c
// ----------------------------
// PWM / DS C/D
// ----------------------------
#define P_PWM_PWM_C                                (volatile unsigned long *)0xc1108650
#define P_PWM_PWM_D                                (volatile unsigned long *)0xc1108654
#define P_PWM_MISC_REG_CD                          (volatile unsigned long *)0xc1108658
#define P_PWM_DELTA_SIGMA_CD                       (volatile unsigned long *)0xc110865c
// ----------------------------
// ISP_FLASH_LED_CTRL
// ----------------------------
//bit 31, reg_led_en //rising pulse start, falling pulse stop for torch mode
//bit 30, reg_inc_i_st_lat //for as3685, dynamic increase current during st_latch
//bit 29:28, reg_inv_en_pol //bit[29], invert en1, bit [28], invert en2
//bit 27, reg_switch_en1en2  //switch output en1 and en2. For IS3231: en1 is EN, en2 is mode. 
//bit 26, reg_force_off_mode //1: reset state machine at the falling edge no matter which state it is in
//bit 25, reg_hold_nonstd_off_mode //hold the non-std led_off signal input before state "OFF"
//bit 24, reg_flash_mode_timeout_en  //force to exit the Tlat state when time out, for flash mode protection
//bit 23, reg_en1_st_ini_level //en1 level during state ST_INI
//bit 22, reg_en2_st_set_mp_level //en2 level during state ST_SET_MP_HI, ST_SET_MP_LO
//bit 21, reg_en1_st_off_level //en1 level during state ST_OFF
//bit 20, reg_en2_st_off_level //en2 level during state ST_OFF
//bit 19:12, reg_en1_mp_num  //en1 multi pulse number, up to 256 step current control
//bit 10:0, reg_t_st_ini //Max: 85.2 us under 24M clock input
#define P_ISP_LED_CTRL                             (volatile unsigned long *)0xc1108660
//bit 31:21, reg_t_en1_inc_i_st_lat_cnt //Max: 85.2us under 24M. for as3685, dynamic increase current during st_latch
//bit 20:10, reg_t_en2_lo_st_ini //Max: 85.2 us under 24M clock input
//bit 9:0, reg_t_en2_hi1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
#define P_ISP_LED_TIMING1                          (volatile unsigned long *)0xc1108664
//bit 31:21, reg_t_en1_mp_hi_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
//bit 20:10, reg_t_en1_mp_lo_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
//bit 9:0, reg_t_en2_lo1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
#define P_ISP_LED_TIMING2                          (volatile unsigned long *)0xc1108668
//bit 30:28, RO state
//bit 25:0, reg_flash_mode_timeout_cnt //up to 2.79s at 24Mhz clk input
#define P_ISP_LED_TIMING3                          (volatile unsigned long *)0xc110866c
//bit 25:0, reg_t_st_lat_cnt //up to 2.79s, keep the led on if it's 26'h3ffffff under torch mode
#define P_ISP_LED_TIMING4                          (volatile unsigned long *)0xc1108670
//bit 31:26, reg_t_st_off_cnt[5:0] //up to 85.2us OFF state.
//bit 25:0, reg_t_en2_hi2_st_lat_cnt //EN2 can output hi-lo-hi during ST_LATCH, this is the second hi -duration
#define P_ISP_LED_TIMING5                          (volatile unsigned long *)0xc1108674
//bit 30:26, reg_t_st_off_cnt[10:6] //up to 85.2us OFF state.
//bit 25:0, reg_t_en1_st_lat_hold_cnt //to make sure Tlat to meat it's minimum request 500us (since non-std led_off signal may comes in anytime)
#define P_ISP_LED_TIMING6                          (volatile unsigned long *)0xc1108678
// ----------------------------
// SAR ADC (16)
// ----------------------------
#define P_SAR_ADC_REG0                             (volatile unsigned long *)0xc1108680
#define P_SAR_ADC_CHAN_LIST                        (volatile unsigned long *)0xc1108684
#define P_SAR_ADC_AVG_CNTL                         (volatile unsigned long *)0xc1108688
#define P_SAR_ADC_REG3                             (volatile unsigned long *)0xc110868c
#define P_SAR_ADC_DELAY                            (volatile unsigned long *)0xc1108690
#define P_SAR_ADC_LAST_RD                          (volatile unsigned long *)0xc1108694
#define P_SAR_ADC_FIFO_RD                          (volatile unsigned long *)0xc1108698
#define P_SAR_ADC_AUX_SW                           (volatile unsigned long *)0xc110869c
#define P_SAR_ADC_CHAN_10_SW                       (volatile unsigned long *)0xc11086a0
#define P_SAR_ADC_DETECT_IDLE_SW                   (volatile unsigned long *)0xc11086a4
#define P_SAR_ADC_DELTA_10                         (volatile unsigned long *)0xc11086a8
// ----------------------------
// CTouch (16)
// ----------------------------
#define P_PWM_PWM_E                                (volatile unsigned long *)0xc11086c0
#define P_PWM_PWM_F                                (volatile unsigned long *)0xc11086c4
#define P_PWM_MISC_REG_EF                          (volatile unsigned long *)0xc11086c8
#define P_PWM_DELTA_SIGMA_EF                       (volatile unsigned long *)0xc11086cc
// ----------------------------
// UART2
// ----------------------------
#define P_UART2_WFIFO                              (volatile unsigned long *)0xc1108700
#define P_UART2_RFIFO                              (volatile unsigned long *)0xc1108704
#define P_UART2_CONTROL                            (volatile unsigned long *)0xc1108708
#define P_UART2_STATUS                             (volatile unsigned long *)0xc110870c
#define P_UART2_MISC                               (volatile unsigned long *)0xc1108710
#define P_UART2_REG5                               (volatile unsigned long *)0xc1108714
// ----------------------------
// UART3
// ----------------------------
#define P_UART3_WFIFO                              (volatile unsigned long *)0xc1108720
#define P_UART3_RFIFO                              (volatile unsigned long *)0xc1108724
#define P_UART3_CONTROL                            (volatile unsigned long *)0xc1108728
#define P_UART3_STATUS                             (volatile unsigned long *)0xc110872c
#define P_UART3_MISC                               (volatile unsigned long *)0xc1108730
#define P_UART3_REG5                               (volatile unsigned long *)0xc1108734
// ---------------------------
// RTC (4)
// ---------------------------
#define P_RTC_ADDR0                                (volatile unsigned long *)0xc1108740
#define P_RTC_ADDR1                                (volatile unsigned long *)0xc1108744
#define P_RTC_ADDR2                                (volatile unsigned long *)0xc1108748
#define P_RTC_ADDR3                                (volatile unsigned long *)0xc110874c
#define P_RTC_ADDR4                                (volatile unsigned long *)0xc1108750
// ----------------------------
// clock measure (4)
// ----------------------------
#define P_MSR_CLK_DUTY                             (volatile unsigned long *)0xc1108758
#define P_MSR_CLK_REG0                             (volatile unsigned long *)0xc110875c
#define P_MSR_CLK_REG1                             (volatile unsigned long *)0xc1108760
#define P_MSR_CLK_REG2                             (volatile unsigned long *)0xc1108764
// ----------------------------
// LED PWM
// ----------------------------
#define P_LED_PWM_REG0                             (volatile unsigned long *)0xc1108768
#define P_LED_PWM_REG1                             (volatile unsigned long *)0xc110876c
#define P_LED_PWM_REG2                             (volatile unsigned long *)0xc1108770
#define P_LED_PWM_REG3                             (volatile unsigned long *)0xc1108774
#define P_LED_PWM_REG4                             (volatile unsigned long *)0xc1108778
#define P_LED_PWM_REG5                             (volatile unsigned long *)0xc110877c
#define P_LED_PWM_REG6                             (volatile unsigned long *)0xc1108780
// ----------------------------
// VGHL PWM
// ----------------------------
#define P_VGHL_PWM_REG0                            (volatile unsigned long *)0xc1108784
#define P_VGHL_PWM_REG1                            (volatile unsigned long *)0xc1108788
#define P_VGHL_PWM_REG2                            (volatile unsigned long *)0xc110878c
#define P_VGHL_PWM_REG3                            (volatile unsigned long *)0xc1108790
#define P_VGHL_PWM_REG4                            (volatile unsigned long *)0xc1108794
#define P_VGHL_PWM_REG5                            (volatile unsigned long *)0xc1108798
#define P_VGHL_PWM_REG6                            (volatile unsigned long *)0xc110879c
// ----------------------------
// I2C Master
// ----------------------------
#define P_I2C_M_1_CONTROL_REG                      (volatile unsigned long *)0xc11087c0
#define P_I2C_M_1_SLAVE_ADDR                       (volatile unsigned long *)0xc11087c4
#define P_I2C_M_1_TOKEN_LIST0                      (volatile unsigned long *)0xc11087c8
#define P_I2C_M_1_TOKEN_LIST1                      (volatile unsigned long *)0xc11087cc
#define P_I2C_M_1_WDATA_REG0                       (volatile unsigned long *)0xc11087d0
#define P_I2C_M_1_WDATA_REG1                       (volatile unsigned long *)0xc11087d4
#define P_I2C_M_1_RDATA_REG0                       (volatile unsigned long *)0xc11087d8
#define P_I2C_M_1_RDATA_REG1                       (volatile unsigned long *)0xc11087dc
// ----------------------------
// I2C Master
// ----------------------------
#define P_I2C_M_2_CONTROL_REG                      (volatile unsigned long *)0xc11087e0
#define P_I2C_M_2_SLAVE_ADDR                       (volatile unsigned long *)0xc11087e4
#define P_I2C_M_2_TOKEN_LIST0                      (volatile unsigned long *)0xc11087e8
#define P_I2C_M_2_TOKEN_LIST1                      (volatile unsigned long *)0xc11087ec
#define P_I2C_M_2_WDATA_REG0                       (volatile unsigned long *)0xc11087f0
#define P_I2C_M_2_WDATA_REG1                       (volatile unsigned long *)0xc11087f4
#define P_I2C_M_2_RDATA_REG0                       (volatile unsigned long *)0xc11087f8
#define P_I2C_M_2_RDATA_REG1                       (volatile unsigned long *)0xc11087fc
// -------------------------------------------------------------------
// PSEL Group #2:  0x800 ~ 0xbFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS2_CBUS_BASE = 0x22
// -----------------------------------------------
#define P_USB_ADDR0                                (volatile unsigned long *)0xc1108800
#define P_USB_ADDR1                                (volatile unsigned long *)0xc1108804
#define P_USB_ADDR2                                (volatile unsigned long *)0xc1108808
#define P_USB_ADDR3                                (volatile unsigned long *)0xc110880c
#define P_USB_ADDR4                                (volatile unsigned long *)0xc1108810
#define P_USB_ADDR5                                (volatile unsigned long *)0xc1108814
#define P_USB_ADDR6                                (volatile unsigned long *)0xc1108818
#define P_USB_ADDR7                                (volatile unsigned long *)0xc110881c
#define P_USB_ADDR8                                (volatile unsigned long *)0xc1108820
#define P_USB_ADDR9                                (volatile unsigned long *)0xc1108824
#define P_USB_ADDR10                               (volatile unsigned long *)0xc1108828
#define P_USB_ADDR11                               (volatile unsigned long *)0xc110882c
#define P_USB_ADDR12                               (volatile unsigned long *)0xc1108830
#define P_USB_ADDR13                               (volatile unsigned long *)0xc1108834
#define P_USB_ADDR14                               (volatile unsigned long *)0xc1108838
#define P_USB_ADDR15                               (volatile unsigned long *)0xc110883c
#define P_USB_ADDR16                               (volatile unsigned long *)0xc1108840
#define P_USB_ADDR17                               (volatile unsigned long *)0xc1108844
#define P_USB_ADDR18                               (volatile unsigned long *)0xc1108848
#define P_USB_ADDR19                               (volatile unsigned long *)0xc110884c
#define P_USB_ADDR20                               (volatile unsigned long *)0xc1108850
#define P_USB_ADDR21                               (volatile unsigned long *)0xc1108854
#define P_USB_ADDR22                               (volatile unsigned long *)0xc1108858
#define P_USB_ADDR23                               (volatile unsigned long *)0xc110885c
#define P_USB_ADDR24                               (volatile unsigned long *)0xc1108860
#define P_USB_ADDR25                               (volatile unsigned long *)0xc1108864
#define P_USB_ADDR26                               (volatile unsigned long *)0xc1108868
#define P_USB_ADDR27                               (volatile unsigned long *)0xc110886c
#define P_USB_ADDR28                               (volatile unsigned long *)0xc1108870
#define P_USB_ADDR29                               (volatile unsigned long *)0xc1108874
#define P_USB_ADDR30                               (volatile unsigned long *)0xc1108878
#define P_USB_ADDR31                               (volatile unsigned long *)0xc110887c
// ----------------------------
// BLKMV (9)
// ----------------------------
#define P_NDMA_CNTL_REG0                           (volatile unsigned long *)0xc11089c0
    #define NDMA_STATUS                 26
    #define NDMA_PERIODIC_INT_DLY_MSB   25
    #define NDMA_PERIODIC_INT_DLY_LSB   16
    #define NDMA_PERIODIC_INT_EN        15
    #define NDMA_ENABLE                 14
    #define NDMA_AHB_DELAY_MSB          13
    #define NDMA_AHB_DELAY_LSB          0
#define P_NDMA_TABLE_ADD_REG                       (volatile unsigned long *)0xc11089c8
#define P_NDMA_TDES_KEY_LO                         (volatile unsigned long *)0xc11089cc
#define P_NDMA_TDES_KEY_HI                         (volatile unsigned long *)0xc11089d0
#define P_NDMA_TDES_CONTROL                        (volatile unsigned long *)0xc11089d4
#define P_NDMA_RIJNDAEL_CONTROL                    (volatile unsigned long *)0xc11089d8
#define P_NDMA_RIJNDAEL_RK_FIFO                    (volatile unsigned long *)0xc11089dc
#define P_NDMA_CRC_OUT                             (volatile unsigned long *)0xc11089e0
#define P_NDMA_THREAD_REG                          (volatile unsigned long *)0xc11089e4
#define P_NDMA_THREAD_TABLE_START0                 (volatile unsigned long *)0xc1108a00
#define P_NDMA_THREAD_TABLE_CURR0                  (volatile unsigned long *)0xc1108a04
#define P_NDMA_THREAD_TABLE_END0                   (volatile unsigned long *)0xc1108a08
#define P_NDMA_THREAD_TABLE_START1                 (volatile unsigned long *)0xc1108a0c
#define P_NDMA_THREAD_TABLE_CURR1                  (volatile unsigned long *)0xc1108a10
#define P_NDMA_THREAD_TABLE_END1                   (volatile unsigned long *)0xc1108a14
#define P_NDMA_THREAD_TABLE_START2                 (volatile unsigned long *)0xc1108a18
#define P_NDMA_THREAD_TABLE_CURR2                  (volatile unsigned long *)0xc1108a1c
#define P_NDMA_THREAD_TABLE_END2                   (volatile unsigned long *)0xc1108a20
#define P_NDMA_THREAD_TABLE_START3                 (volatile unsigned long *)0xc1108a24
#define P_NDMA_THREAD_TABLE_CURR3                  (volatile unsigned long *)0xc1108a28
#define P_NDMA_THREAD_TABLE_END3                   (volatile unsigned long *)0xc1108a2c
#define P_NDMA_CNTL_REG1                           (volatile unsigned long *)0xc1108a30
#define P_NDMA_AES_KEY_0                           (volatile unsigned long *)0xc1108a40
#define P_NDMA_AES_KEY_1                           (volatile unsigned long *)0xc1108a44
#define P_NDMA_AES_KEY_2                           (volatile unsigned long *)0xc1108a48
#define P_NDMA_AES_KEY_3                           (volatile unsigned long *)0xc1108a4c
#define P_NDMA_AES_KEY_4                           (volatile unsigned long *)0xc1108a50
#define P_NDMA_AES_KEY_5                           (volatile unsigned long *)0xc1108a54
#define P_NDMA_AES_KEY_6                           (volatile unsigned long *)0xc1108a58
#define P_NDMA_AES_KEY_7                           (volatile unsigned long *)0xc1108a5c
#define P_NDMA_AES_IV_0                            (volatile unsigned long *)0xc1108a60
#define P_NDMA_AES_IV_1                            (volatile unsigned long *)0xc1108a64
#define P_NDMA_AES_IV_2                            (volatile unsigned long *)0xc1108a68
#define P_NDMA_AES_IV_3                            (volatile unsigned long *)0xc1108a6c
#define P_NDMA_AES_REG0                            (volatile unsigned long *)0xc1108a70
// -------------------------------------------------------------------
// PSEL Group #3:  0xc00 ~ 0xFFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS3_CBUS_BASE = 0x23
// -----------------------------------------------
// ---------------------------
// STREAM (8)
// ---------------------------
// bit 31:24 -- event_length
// bit 23:22 -- bus_1st_sel_1  //00-gpio, 01-reserved, 10-addr, 11-data 
// bit 21:20 -- bus_2nd_sel_1
// bit 19:18 -- bus_1st_sel_0
// bit 17:16 -- bus_2nd_sel_0
// bit 15:0 -- set output value (output 1 will read according to external input) 
#define P_STREAM_EVENT_INFO                        (volatile unsigned long *)0xc1108c00
// bit 31    -- force_parity_1
// bit 30    -- LSB_first
// bit 31:20 -- reserved
// bit 19:16 -- toggle point index
// bit 15:8  -- output togle point1
// bit 7:0   -- output togle point0 (0xff means input) 
#define P_STREAM_OUTPUT_CONFIG                     (volatile unsigned long *)0xc1108c04
// bit 31:24 -- clock_divide_ext
// bit 23:20 -- s_bus_start ( sclk, sdataout, sdatain)  // 0 means no s_bus used
// bit 19    -- no_sclk_on_pin // will use internal write clock and read clock (like RS232) 
// bit 18    -- invert_sclk_in
// bit 17    -- sdata_send_busy  // indicate one data is sending -- read only
// bit 16    -- one_sdata_received // set when one sdata is received, can write 0 to clear 
// bit 15    -- sdata_parity  // (write -- 0-even, 1-odd) (read -- received parity check)
// bit 14    -- sdata_send_type  // 0 -- 8 bits  1 -- 32 bits ( for fujitsu only )
// bit 13    -- sdata_receive_type // 0 -- 8 bits only  1 -- 8/32 bits 
// bit 12    -- invert_request_out
// bit 11:8  -- request_out_sel  // 0 means disable output
// bit 7:0   --  stop_request_count 
#define P_C_D_BUS_CONTROL                          (volatile unsigned long *)0xc1108c08
// bit 31:0  -- serial data (write: output one data, read: input data)
#define P_C_DATA                                   (volatile unsigned long *)0xc1108c0c
// bit 31:28 bus_width_1
// bit 27:24 bus_start_pin_1
// bit 23:16 bus_sel_chang_point_1 
// bit 15:12 bus_width_0
// bit 11:08 bus_start_pin_0
// bit 07:00 bus_sel_chang_point_0 
#define P_STREAM_BUS_CONFIG                        (volatile unsigned long *)0xc1108c10
// bit 31:24 clock_divide
// bit 23:20 clock_output_sel  -- 0 means disable clock output
// bit 19 -- inc_event_addr
// bit 18 -- async_fifo_endian
// bit 17 -- send_to_async_fifo
// bit 16 -- data_in_serial_lsb
// bit 15 -- invert_no_wait_condition_0
// bit 14 -- invert_no_wait_condition_1
// bit 13 -- invert_no_wait_condition_2
// bit 12 -- invert_data_bus
// bit 11 -- invert_clock_in
// bit 10 -- event_wait_clk_en
// bit 9 -- data_in_serial
// bit 8 -- invert_data_in_clk 
// bit 7:4  -- data_in_begin
// bit 3:0  -- data_in_clk_sel
#define P_STREAM_DATA_IN_CONFIG                    (volatile unsigned long *)0xc1108c14
// wait condition and irq should not be connected to 0, 0 means disable)
// bit 31:28 -- no_wait_condition_0   (0 means disable this condition)
// bit 27:24 -- no_wait_condition_1   (0 means disable this condition)
// bit 23:20 -- no_wait_condition_2   (0 means disable this condition)
// bit 19:16 -- irq_input_sel         (0 means disable this interrupt)
// bit 15:13 -- interrupt_status (read) clear status (write) (ext 0, ext 1, transfer end)
// bit 12 -- enable_sdata_irq
// bit 11 -- invert_irq_0
// bit 10 -- invert_irq_1
// bit  9 -- enable_transfer_end_irq
// bit  8 -- enable_second_ext_irq
// bit 7:0 -- no_wait_condition_check_point (0xff means no check)
#define P_STREAM_WAIT_IRQ_CONFIG                   (volatile unsigned long *)0xc1108c18
// bit 31:24 -- event address
// bit 23:16 -- event data
// bit 15:1 -- event repeat times  (0 means one time event)
// bit 0  -- Start Event (write) event_busy (read)
#define P_STREAM_EVENT_CTL                         (volatile unsigned long *)0xc1108c1c
// ---------------------------
// SDIO (8)
// ---------------------------
// `define C_SDIO_HIGH16                   8'h00 
// bit 31:0 -- cmd_argument/MS_SHORT_DATA_WRITE
#define P_CMD_ARGUMENT                             (volatile unsigned long *)0xc1108c20
// bit 31:24 -- repeat_package_times/MS_SHORT_DATA_WRITE_NUMBER
// bit 21   -- use_int_window
// bit 20   -- cmd_send_data/MS_HAVE_LONG_DATA_WRITE
// bit 19   -- check_busy_on_dat0 (used for R1b response)
// bit 18   -- response_crc7_from_8
// bit 17   -- response_have_data/MS_HAVE_LONG_DATA_READ
// bit 16   -- response_do_not_have_crc7/MS_SHORT_DATA_DO_NOT_HAVE_CRC16
// bit 15:8 -- cmd_response_bits (00 means no response) /MS_SHORT_DATA_READ_NUMBER
// bit 7:0 -- cmd_command/MS_TPC
#define P_CMD_SEND                                 (volatile unsigned long *)0xc1108c24
// bit 31:29 -- sdio_write_CRC_ok_status
// bit 28:23 -- sdio_write_Nwr
// bit 22:21 -- m_endian
// bit 20    -- bus_width
// bit 19    -- data_latch_at_negedge (normally at posedge)
// bit 18    -- do_not_delay_data (normally delay one clock)
// bit 17:12 -- cmd_argument_bits (before CRC, normally : 39) 
// bit 11 -- cmd_out_at_posedge (normally at negedge)
// bit 10 -- cmd_disable_CRC
// bit 9:0 -- cmd_clk_divide
#define P_SDIO_CONFIG                              (volatile unsigned long *)0xc1108c28
// bit 31:19 -- sdio_timing_out_count
// bit 18 -- arc_timing_out_int_en
// bit 17 -- amrisc_timing_out_int_en
// bit 16 -- sdio_timig_out_int   -- write 1 clear this int bit
// bit 15:12 -- sdio_status_info  -- used for change infor between ARC and Amrisc
// bit 11 -- sdio_set_soft_int -- write 1 to this bit will set sdio_soft_int , read out is m_req_sdio
// bit 10 -- sdio_soft_int   -- write 1 clear this int bit
// bit 9 -- sdio_cmd_int   -- write 1 clear this int bit
// bit 8 -- sdio_if_int   -- write 1 clear this int bit
// bit 7 -- sdio_data_write_crc16_ok -- Read-Only
// bit 6 -- sdio_data_read_crc16_ok  -- Read-Only
// bit 5 -- sdio_response_crc7_ok    -- Read-Only
// bit 4 -- sdio_cmd_busy            -- Read-Only
// bit 3:0 -- sdio_status            -- Read-Only
#define P_SDIO_STATUS_IRQ                          (volatile unsigned long *)0xc1108c2c
// bit 31 -- halt_hole 0 -- 8 bits 1 -- 16 bits
// bit 30 -- force_halt
// bit 29:24 -- sdio_force_data_read (read_only)
// bit 23:22 -- disable_mem_halt (write and read)
// bit 21:16 -- sdio_force_output_en 
// bit 15 -- soft_reset
// bit 14 -- sdio_force_enable
// bit 13:8 -- sdio_force_data/sdio_read_data
// bit 7:6 -- sdio_if_int_config 
// bit 5 -- arc_soft_int_en
// bit 4 -- arc_cmd_int_en
// bit 3 -- arc_if_int_en
// bit 2 -- amrisc_soft_int_en
// bit 1 -- amrisc_cmd_int_en
// bit 0 -- amrisc_if_int_en
#define P_SDIO_IRQ_CONFIG                          (volatile unsigned long *)0xc1108c30
// bit 27:16 -- data_catch_finish_point
// (
// bit 15:12 -- response_read_index  
// bit 9 -- data_catch_readout_en
// bit 8 -- write_read_out_index
// ) this bits only write when write_read_out_index = 1
// bit 11 -- sdio_1_data_swap01 
// bit 10 -- sdio_0_data_on_1 
// bit 7:6 -- data_catch_level 
// bit 5 -- stream_8_bits_mode
// bit 4 -- stream_enable
// bit 3 -- ms_sclk_always
// bit 2 -- ms_enable
// bit 1:0 -- SDIO_port_sel //00-sdio1, 01-sdio2, 02-sdio3
#define P_SDIO_MULT_CONFIG                         (volatile unsigned long *)0xc1108c34
// bit 31:0 -- m_addr_sdio
#define P_SDIO_M_ADDR                              (volatile unsigned long *)0xc1108c38
// bit 31    -- CRC_status_4line
// bit 30    -- data_rw_do_not_have_crc16/MS_LONG_DATA_DO_NOT_HAVE_CRC16
// bit 29:16 -- data_rw_number/MS_LONG_DATA_NUMBER 
// bit 15:0 -- cmd_argument_ext/MS_SHORT_DATA_EXTENSION
#define P_SDIO_EXTENSION                           (volatile unsigned long *)0xc1108c3c
// ----------------------------
// ASYNC FIFO (4)
// ----------------------------
#define P_ASYNC_FIFO_REG0                          (volatile unsigned long *)0xc1108c40
#define P_ASYNC_FIFO_REG1                          (volatile unsigned long *)0xc1108c44
    #define ASYNC_FIFO_FLUSH_STATUS     31
    #define ASYNC_FIFO_ERR              30
    #define ASYNC_FIFO_FIFO_EMPTY       29
    #define ASYNC_FIFO_TO_HIU           24
    #define ASYNC_FIFO_FLUSH            23
    #define ASYNC_FIFO_RESET            22
    #define ASYNC_FIFO_WRAP_EN          21
    #define ASYNC_FIFO_FLUSH_EN         20
    #define ASYNC_FIFO_RESIDUAL_MSB     19
    #define ASYNC_FIFO_RESIDUAL_LSB     15
    #define ASYNC_FIFO_FLUSH_CNT_MSB    14
    #define ASYNC_FIFO_FLUSH_CNT_LSB    0
#define P_ASYNC_FIFO_REG2                          (volatile unsigned long *)0xc1108c48
    #define ASYNC_FIFO_FIFO_FULL        26
    #define ASYNC_FIFO_FILL_STATUS      25
    #define ASYNC_FIFO_SOURCE_MSB       24
    #define ASYNC_FIFO_SOURCE_LSB       23
    #define ASYNC_FIFO_ENDIAN_MSB       22
    #define ASYNC_FIFO_ENDIAN_LSB       21
    #define ASYNC_FIFO_FILL_EN          20
    #define ASYNC_FIFO_FILL_CNT_MSB     19
    #define ASYNC_FIFO_FILL_CNT_LSB     0
#define P_ASYNC_FIFO_REG3                          (volatile unsigned long *)0xc1108c4c
    #define ASYNC_FLUSH_SIZE_IRQ_MSB    15
    #define ASYNC_FLUSH_SIZE_IRQ_LSB    0
// ----------------------------
// ASYNC FIFO (4)
// ----------------------------
#define P_ASYNC_FIFO2_REG0                         (volatile unsigned long *)0xc1108c50
#define P_ASYNC_FIFO2_REG1                         (volatile unsigned long *)0xc1108c54
#define P_ASYNC_FIFO2_REG2                         (volatile unsigned long *)0xc1108c58
#define P_ASYNC_FIFO2_REG3                         (volatile unsigned long *)0xc1108c5c
// ----------------------------
// SDIO_AHB_CBUS (2)
// ----------------------------
// bit   17    -- arc_ahb_cbus_int_en
// bit   16    -- amrisc_ahb_cbus_int_en
// bit 15:8    -- SDIO_FIFO_count
// bit  7:4    -- m_req_count
// bit    3    -- reserved
// bit    2    -- m_write_cbus
// bit    1    -- m_req_cbus
// bit    0    -- sdio_ahb_cbus_enable
#define P_SDIO_AHB_CBUS_CTRL                       (volatile unsigned long *)0xc1108c60
// m_rd_data[31:0] when (m_write_cbus == 0)  CBUS write
// m_wr_data[31:0] when (m_write_cbus == 1)  CBUS read
#define P_SDIO_AHB_CBUS_M_DATA                     (volatile unsigned long *)0xc1108c64
// ----------------------------
// SPI 
// ----------------------------
#define P_SPI_FLASH_CMD                            (volatile unsigned long *)0xc1108c80
    #define SPI_FLASH_READ    31
    #define SPI_FLASH_WREN    30
    #define SPI_FLASH_WRDI    29
    #define SPI_FLASH_RDID    28
    #define SPI_FLASH_RDSR    27
    #define SPI_FLASH_WRSR    26
    #define SPI_FLASH_PP      25
    #define SPI_FLASH_SE      24
    #define SPI_FLASH_BE      23
    #define SPI_FLASH_CE      22
    #define SPI_FLASH_DP      21
    #define SPI_FLASH_RES     20
    #define SPI_HPM           19
    #define SPI_FLASH_USR     18
    #define SPI_FLASH_USR_ADDR 15
    #define SPI_FLASH_USR_DUMMY 14
    #define SPI_FLASH_USR_DIN   13
    #define SPI_FLASH_USR_DOUT   12
    #define SPI_FLASH_USR_DUMMY_BLEN   10
    #define SPI_FLASH_USR_CMD     0
#define P_SPI_FLASH_ADDR                           (volatile unsigned long *)0xc1108c84
    #define SPI_FLASH_BYTES_LEN 24
    #define SPI_FLASH_ADDR_START 0
#define P_SPI_FLASH_CTRL                           (volatile unsigned long *)0xc1108c88
    #define SPI_ENABLE_AHB    17
    #define SPI_SST_AAI       16
    #define SPI_RES_RID       15
    #define SPI_FREAD_DUAL    14
    #define SPI_READ_READ_EN  13
    #define SPI_CLK_DIV0      12
    #define SPI_CLKCNT_N      8
    #define SPI_CLKCNT_H      4
    #define SPI_CLKCNT_L      0
#define P_SPI_FLASH_CTRL1                          (volatile unsigned long *)0xc1108c8c
#define P_SPI_FLASH_STATUS                         (volatile unsigned long *)0xc1108c90
#define P_SPI_FLASH_CTRL2                          (volatile unsigned long *)0xc1108c94
#define P_SPI_FLASH_CLOCK                          (volatile unsigned long *)0xc1108c98
#define P_SPI_FLASH_USER                           (volatile unsigned long *)0xc1108c9c
#define P_SPI_FLASH_USER1                          (volatile unsigned long *)0xc1108ca0
#define P_SPI_FLASH_USER2                          (volatile unsigned long *)0xc1108ca4
#define P_SPI_FLASH_USER3                          (volatile unsigned long *)0xc1108ca8
#define P_SPI_FLASH_USER4                          (volatile unsigned long *)0xc1108cac
#define P_SPI_FLASH_SLAVE                          (volatile unsigned long *)0xc1108cb0
#define P_SPI_FLASH_SLAVE1                         (volatile unsigned long *)0xc1108cb4
#define P_SPI_FLASH_SLAVE2                         (volatile unsigned long *)0xc1108cb8
#define P_SPI_FLASH_SLAVE3                         (volatile unsigned long *)0xc1108cbc
#define P_SPI_FLASH_C0                             (volatile unsigned long *)0xc1108cc0
#define P_SPI_FLASH_C1                             (volatile unsigned long *)0xc1108cc4
#define P_SPI_FLASH_C2                             (volatile unsigned long *)0xc1108cc8
#define P_SPI_FLASH_C3                             (volatile unsigned long *)0xc1108ccc
#define P_SPI_FLASH_C4                             (volatile unsigned long *)0xc1108cd0
#define P_SPI_FLASH_C5                             (volatile unsigned long *)0xc1108cd4
#define P_SPI_FLASH_C6                             (volatile unsigned long *)0xc1108cd8
#define P_SPI_FLASH_C7                             (volatile unsigned long *)0xc1108cdc
#define P_SPI_FLASH_B8                             (volatile unsigned long *)0xc1108ce0
#define P_SPI_FLASH_B9                             (volatile unsigned long *)0xc1108ce4
#define P_SPI_FLASH_B10                            (volatile unsigned long *)0xc1108ce8
#define P_SPI_FLASH_B11                            (volatile unsigned long *)0xc1108cec
#define P_SPI_FLASH_B12                            (volatile unsigned long *)0xc1108cf0
#define P_SPI_FLASH_B13                            (volatile unsigned long *)0xc1108cf4
#define P_SPI_FLASH_B14                            (volatile unsigned long *)0xc1108cf8
#define P_SPI_FLASH_B15                            (volatile unsigned long *)0xc1108cfc
// ----------------------------
// I2C Master
// ----------------------------
#define P_I2C_M_3_CONTROL_REG                      (volatile unsigned long *)0xc1108d20
#define P_I2C_M_3_SLAVE_ADDR                       (volatile unsigned long *)0xc1108d24
#define P_I2C_M_3_TOKEN_LIST0                      (volatile unsigned long *)0xc1108d28
#define P_I2C_M_3_TOKEN_LIST1                      (volatile unsigned long *)0xc1108d2c
#define P_I2C_M_3_WDATA_REG0                       (volatile unsigned long *)0xc1108d30
#define P_I2C_M_3_WDATA_REG1                       (volatile unsigned long *)0xc1108d34
#define P_I2C_M_3_RDATA_REG0                       (volatile unsigned long *)0xc1108d38
#define P_I2C_M_3_RDATA_REG1                       (volatile unsigned long *)0xc1108d3c
// ----------------------------
// SPICC
// ----------------------------
#define P_SPICC_RXDATA                             (volatile unsigned long *)0xc1108d80
#define P_SPICC_TXDATA                             (volatile unsigned long *)0xc1108d84
#define P_SPICC_CONREG                             (volatile unsigned long *)0xc1108d88
#define P_SPICC_INTREG                             (volatile unsigned long *)0xc1108d8c
#define P_SPICC_DMAREG                             (volatile unsigned long *)0xc1108d90
#define P_SPICC_STATREG                            (volatile unsigned long *)0xc1108d94
#define P_SPICC_PERIODREG                          (volatile unsigned long *)0xc1108d98
#define P_SPICC_TESTREG                            (volatile unsigned long *)0xc1108d9c
#define P_SPICC_DRADDR                             (volatile unsigned long *)0xc1108da0
#define P_SPICC_DWADDR                             (volatile unsigned long *)0xc1108da4
// ----------------------------
// SDHC (SDIO #2)
// ----------------------------
#define P_SD_REG0_ARGU                             (volatile unsigned long *)0xc1108e00
#define P_SD_REG1_SEND                             (volatile unsigned long *)0xc1108e04
#define P_SD_REG2_CNTL                             (volatile unsigned long *)0xc1108e08
#define P_SD_REG3_STAT                             (volatile unsigned long *)0xc1108e0c
#define P_SD_REG4_CLKC                             (volatile unsigned long *)0xc1108e10
#define P_SD_REG5_ADDR                             (volatile unsigned long *)0xc1108e14
#define P_SD_REG6_PDMA                             (volatile unsigned long *)0xc1108e18
#define P_SD_REG7_MISC                             (volatile unsigned long *)0xc1108e1c
#define P_SD_REG8_DATA                             (volatile unsigned long *)0xc1108e20
#define P_SD_REG9_ICTL                             (volatile unsigned long *)0xc1108e24
#define P_SD_REGA_ISTA                             (volatile unsigned long *)0xc1108e28
#define P_SD_REGB_SRST                             (volatile unsigned long *)0xc1108e2c
#define P_SD_REGC_ESTA                             (volatile unsigned long *)0xc1108e30
#define P_SD_REGD_ENHC                             (volatile unsigned long *)0xc1108e34
#define P_SD_REGE_CLK2                             (volatile unsigned long *)0xc1108e38
//
// Closing file:  periphs_reg.h
//
//
// Reading file:  isa_reg.h
//
// $isa/rtl/isa_core register defines for the APB bus
// CBUS base slave address
// -----------------------------------------------
// CBUS_BASE:  ISA_CBUS_BASE = 0x26
// -----------------------------------------------
// Up to 256 registers for this base
#define P_ISA_DEBUG_REG0                           (volatile unsigned long *)0xc1109800
#define P_ISA_DEBUG_REG1                           (volatile unsigned long *)0xc1109804
#define P_ISA_DEBUG_REG2                           (volatile unsigned long *)0xc1109808
#define P_ISA_DEBUG_REG3                           (volatile unsigned long *)0xc110980c
#define P_ISA_PLL_CLK_SIM0                         (volatile unsigned long *)0xc1109820
#define P_ISA_CNTL_REG0                            (volatile unsigned long *)0xc1109824
// -----------------------------------------------------------
#define P_AO_CPU_IRQ_IN0_INTR_STAT                 (volatile unsigned long *)0xc1109840
#define P_AO_CPU_IRQ_IN0_INTR_STAT_CLR             (volatile unsigned long *)0xc1109844
#define P_AO_CPU_IRQ_IN0_INTR_MASK                 (volatile unsigned long *)0xc1109848
#define P_AO_CPU_IRQ_IN0_INTR_FIRQ_SEL             (volatile unsigned long *)0xc110984c
// define MEDIA_CPU_IRQ_IN1_INTR_STAT           8'h14
// define MEDIA_CPU_IRQ_IN1_INTR_STAT_CLR       8'h15
// define MEDIA_CPU_IRQ_IN1_INTR_MASK           8'h16
// define MEDIA_CPU_IRQ_IN1_INTR_FIRQ_SEL       8'h17
// 
// define MEDIA_CPU_IRQ_IN2_INTR_STAT              8'h18
// define MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR          8'h19
// define MEDIA_CPU_IRQ_IN2_INTR_MASK              8'h1a
// define MEDIA_CPU_IRQ_IN2_INTR_FIRQ_SEL          8'h1b
// 
// define MEDIA_CPU_IRQ_IN3_INTR_STAT            8'h1c
// define MEDIA_CPU_IRQ_IN3_INTR_STAT_CLR        8'h1d
// define MEDIA_CPU_IRQ_IN3_INTR_MASK            8'h1e
// define MEDIA_CPU_IRQ_IN3_INTR_FIRQ_SEL        8'h1f
#define P_GPIO_INTR_EDGE_POL                       (volatile unsigned long *)0xc1109880
#define P_GPIO_INTR_GPIO_SEL0                      (volatile unsigned long *)0xc1109884
#define P_GPIO_INTR_GPIO_SEL1                      (volatile unsigned long *)0xc1109888
#define P_GPIO_INTR_FILTER_SEL0                    (volatile unsigned long *)0xc110988c
// `define GLOBAL_INTR_DISABLE                 8'h24    never used
#define P_MEDIA_CPU_INTR_STAT                      (volatile unsigned long *)0xc11098a0
#define P_MEDIA_CPU_INTR_STAT_CLR                  (volatile unsigned long *)0xc11098a4
#define P_MEDIA_CPU_INTR_MASK                      (volatile unsigned long *)0xc11098a8
#define P_MEDIA_CPU_INTR_FIRQ_SEL                  (volatile unsigned long *)0xc11098ac
// -----------------------------------------------------------
#define P_ISA_BIST_REG0                            (volatile unsigned long *)0xc11098c0
#define P_ISA_BIST_REG1                            (volatile unsigned long *)0xc11098c4
// -----------------------------------------------------------
#define P_WATCHDOG_TC                              (volatile unsigned long *)0xc1109900
#define P_WATCHDOG_RESET                           (volatile unsigned long *)0xc1109904
// -----------------------------------------------------------
#define P_AHB_ARBITER_REG                          (volatile unsigned long *)0xc1109908
#define P_AHB_ARBDEC_REG                           (volatile unsigned long *)0xc110990c
#define P_AHB_ARBITER2_REG                         (volatile unsigned long *)0xc1109928
#define P_DEVICE_MMCP_CNTL                         (volatile unsigned long *)0xc110992c
#define P_AUDIO_MMCP_CNTL                          (volatile unsigned long *)0xc1109930
// -----------------------------------------------------------
#define P_ISA_TIMER_MUX                            (volatile unsigned long *)0xc1109940
#define P_ISA_TIMERA                               (volatile unsigned long *)0xc1109944
#define P_ISA_TIMERB                               (volatile unsigned long *)0xc1109948
#define P_ISA_TIMERC                               (volatile unsigned long *)0xc110994c
#define P_ISA_TIMERD                               (volatile unsigned long *)0xc1109950
#define P_ISA_TIMERE                               (volatile unsigned long *)0xc1109954
#define P_FBUF_ADDR                                (volatile unsigned long *)0xc1109958
    #define VIDEO_FRM_BUF_MSB_BIT      23 
    #define VIDEO_FRM_BUF_LSB_BIT       2 
#define P_SDRAM_CTL0                               (volatile unsigned long *)0xc110995c
#define P_SDRAM_CTL2                               (volatile unsigned long *)0xc1109960
//`define AO_CPU_CTL                          8'h59
#define P_SDRAM_CTL4                               (volatile unsigned long *)0xc1109968
#define P_SDRAM_CTL5                               (volatile unsigned long *)0xc110996c
#define P_SDRAM_CTL6                               (volatile unsigned long *)0xc1109970
#define P_SDRAM_CTL7                               (volatile unsigned long *)0xc1109974
#define P_SDRAM_CTL8                               (volatile unsigned long *)0xc1109978
#define P_AHB_MP4_MC_CTL                           (volatile unsigned long *)0xc110997c
#define P_MEDIA_CPU_PCR                            (volatile unsigned long *)0xc1109980
#define P_MEDIA_CPU_CTL                            (volatile unsigned long *)0xc1109984
#define P_ISA_TIMER_MUX1                           (volatile unsigned long *)0xc1109990
#define P_ISA_TIMERF                               (volatile unsigned long *)0xc1109994
#define P_ISA_TIMERG                               (volatile unsigned long *)0xc1109998
#define P_ISA_TIMERH                               (volatile unsigned long *)0xc110999c
#define P_ISA_TIMERI                               (volatile unsigned long *)0xc11099a0
// ---------------------------------------------
#define P_ABUF_WR_CTL0                             (volatile unsigned long *)0xc11099c0
    #define ABUF_WR_INT_EN	    31
    #define ABUF_WR_INT_POS_MSB      30 
    #define ABUF_WR_INT_POS_LSB      16 
    #define ABUF_WR_BLK_SIZE_MSB     14 
    #define ABUF_WR_BLK_SIZE_LSB      0
#define P_ABUF_WR_CTL1                             (volatile unsigned long *)0xc11099c4
    #define ABUF_WR_INT_EN	    31
    #define ABUF_WR_INT_POS_MSB      30 
    #define ABUF_WR_INT_POS_LSB      16 
    #define ABUF_WR_BLK_SIZE_MSB     14 
    #define ABUF_WR_BLK_SIZE_LSB      0
#define P_ABUF_WR_CTL2                             (volatile unsigned long *)0xc11099c8
    #define ABUF_WR_CUR_FF_CNT_MSB   21
    #define ABUF_WR_CUR_FF_CNT_LSB   16
    #define ABUF_WR_CUR_BLK_MSB      14
    #define ABUF_WR_CUR_BLK_LSB       0   
#define P_ABUF_WR_CTL3                             (volatile unsigned long *)0xc11099cc
    #define ABUF_WR_AHB_RST_PLS       3
    #define ABUF_WR_FF_CLR_PLS        2
    #define ABUF_WR_PLY_RPT_LVL	     1
    #define ABUF_WR_FF_PAUSE_LVL      0
#define P_ABUF_RD_CTL0                             (volatile unsigned long *)0xc11099d0
#define P_ABUF_RD_CTL1                             (volatile unsigned long *)0xc11099d4
    #define ABUF_RD_INT_EN	    31
    #define ABUF_RD_INT_POS_MSB      30 
    #define ABUF_RD_INT_POS_LSB      16 
    #define ABUF_RD_BLK_SIZE_MSB     14 
    #define ABUF_RD_BLK_SIZE_LSB      0   
#define P_ABUF_RD_CTL2                             (volatile unsigned long *)0xc11099d8
    #define ABUF_RD_CUR_FF_CNT_MSB   21
    #define ABUF_RD_CUR_FF_CNT_LSB   16
    #define ABUF_RD_CUR_BLK_MSB      14
    #define ABUF_RD_CUR_BLK_LSB       0   
#define P_ABUF_RD_CTL3                             (volatile unsigned long *)0xc11099dc
    #define ABUF_RD_PLY_ONCE_PLS      4
    #define ABUF_RD_AHB_RST_PLS       3
    #define ABUF_RD_FF_CLR_PLS        2
    #define ABUF_RD_PLY_RPT_LVL	     1
    #define ABUF_RD_FF_PAUSE_LVL      0
#define P_ABUF_ARB_CTL0                            (volatile unsigned long *)0xc11099e0
#define P_ABUF_FIFO_CTL0                           (volatile unsigned long *)0xc11099e4
    #define AIUout_FIFO_THRESHOLD_MSB 11
    #define AIUout_FIFO_THRESHOLD_LSB 6 
    #define AIUin_FIFO_THRESHOLD_MSB  5
    #define AIUin_FIFO_THRESHOLD_LSB  0
// ---------------------------------------------
#define P_AHB_BRIDGE_CNTL_WR                       (volatile unsigned long *)0xc1109a00
#define P_AHB_BRIDGE_REMAP0                        (volatile unsigned long *)0xc1109a04
#define P_AHB_BRIDGE_REMAP1                        (volatile unsigned long *)0xc1109a08
#define P_AHB_BRIDGE_REMAP2                        (volatile unsigned long *)0xc1109a0c
#define P_AHB_BRIDGE_REMAP3                        (volatile unsigned long *)0xc1109a10
#define P_AHB_BRIDGE_CNTL_REG1                     (volatile unsigned long *)0xc1109a14
#define P_AHB_BRIDGE_CNTL_REG2                     (volatile unsigned long *)0xc1109a18
// ---------------------------------------------
// ----------------------------------------------
// `define SYS_CPU_0_IRQ_IN0_INTR_STAT         8'h90
// `define SYS_CPU_0_IRQ_IN0_INTR_STAT_CLR     8'h91
// `define SYS_CPU_0_IRQ_IN0_INTR_MASK         8'h92
// `define SYS_CPU_0_IRQ_IN0_INTR_FIRQ_SEL     8'h93
// `define SYS_CPU_0_IRQ_IN1_INTR_STAT         8'h94
// `define SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR     8'h95
// `define SYS_CPU_0_IRQ_IN1_INTR_MASK         8'h96
// `define SYS_CPU_0_IRQ_IN1_INTR_FIRQ_SEL     8'h97
// `define SYS_CPU_0_IRQ_IN2_INTR_STAT         8'h98
// `define SYS_CPU_0_IRQ_IN2_INTR_STAT_CLR     8'h99
// `define SYS_CPU_0_IRQ_IN2_INTR_MASK         8'h9a
// `define SYS_CPU_0_IRQ_IN2_INTR_FIRQ_SEL     8'h9b
// `define SYS_CPU_0_IRQ_IN3_INTR_STAT         8'h9c
// `define SYS_CPU_0_IRQ_IN3_INTR_STAT_CLR     8'h9d
// `define SYS_CPU_0_IRQ_IN3_INTR_MASK         8'h9e
// `define SYS_CPU_0_IRQ_IN3_INTR_FIRQ_SEL     8'h9f
// ----------------------------------------------
// `define SYS_CPU_1_IRQ_IN0_INTR_STAT         8'ha0
// `define SYS_CPU_1_IRQ_IN0_INTR_STAT_CLR     8'ha1
// `define SYS_CPU_1_IRQ_IN0_INTR_MASK         8'ha2
// `define SYS_CPU_1_IRQ_IN0_INTR_FIRQ_SEL     8'ha3
//  
// `define SYS_CPU_1_IRQ_IN1_INTR_STAT         8'ha4
// `define SYS_CPU_1_IRQ_IN1_INTR_STAT_CLR     8'ha5
// `define SYS_CPU_1_IRQ_IN1_INTR_MASK         8'ha6
// `define SYS_CPU_1_IRQ_IN1_INTR_FIRQ_SEL     8'ha7
//  
// `define SYS_CPU_1_IRQ_IN2_INTR_STAT         8'ha8
// `define SYS_CPU_1_IRQ_IN2_INTR_STAT_CLR     8'ha9
// `define SYS_CPU_1_IRQ_IN2_INTR_MASK         8'haa
// `define SYS_CPU_1_IRQ_IN2_INTR_FIRQ_SEL     8'hab
//  
// `define SYS_CPU_1_IRQ_IN3_INTR_STAT         8'hac
// `define SYS_CPU_1_IRQ_IN3_INTR_STAT_CLR     8'had
// `define SYS_CPU_1_IRQ_IN3_INTR_MASK         8'hae
// `define SYS_CPU_1_IRQ_IN3_INTR_FIRQ_SEL     8'haf
// ----------------------------------------------
// `define MEDIA_CPU_IRQ_IN4_INTR_STAT         8'hb0
// `define MEDIA_CPU_IRQ_IN4_INTR_STAT_CLR     8'hb1
// `define MEDIA_CPU_IRQ_IN4_INTR_MASK         8'hb2
// `define MEDIA_CPU_IRQ_IN4_INTR_FIRQ_SEL     8'hb3
// `define SYS_CPU_0_IRQ_IN4_INTR_STAT         8'hb4
// `define SYS_CPU_0_IRQ_IN4_INTR_STAT_CLR     8'hb5
// `define SYS_CPU_0_IRQ_IN4_INTR_MASK         8'hb6
// `define SYS_CPU_0_IRQ_IN4_INTR_FIRQ_SEL     8'hb7
// `define SYS_CPU_1_IRQ_IN4_INTR_STAT         8'hb8
// `define SYS_CPU_1_IRQ_IN4_INTR_STAT_CLR     8'hb9
// `define SYS_CPU_1_IRQ_IN4_INTR_MASK         8'hba
// `define SYS_CPU_1_IRQ_IN4_INTR_FIRQ_SEL     8'hbb
// `define SYS_CPU_2_IRQ_IN4_INTR_STAT         8'hbc
// `define SYS_CPU_2_IRQ_IN4_INTR_STAT_CLR     8'hbd
// `define SYS_CPU_2_IRQ_IN4_INTR_MASK         8'hbe
// `define SYS_CPU_2_IRQ_IN4_INTR_FIRQ_SEL     8'hbf
// ----------------------------------------------
// `define SYS_CPU_2_IRQ_IN0_INTR_STAT         8'hc0
// `define SYS_CPU_2_IRQ_IN0_INTR_STAT_CLR     8'hc1
// `define SYS_CPU_2_IRQ_IN0_INTR_MASK         8'hc2
// `define SYS_CPU_2_IRQ_IN0_INTR_FIRQ_SEL     8'hc3
// `define SYS_CPU_2_IRQ_IN1_INTR_STAT         8'hc4
// `define SYS_CPU_2_IRQ_IN1_INTR_STAT_CLR     8'hc5
// `define SYS_CPU_2_IRQ_IN1_INTR_MASK         8'hc6
// `define SYS_CPU_2_IRQ_IN1_INTR_FIRQ_SEL     8'hc7
// `define SYS_CPU_2_IRQ_IN2_INTR_STAT         8'hc8
// `define SYS_CPU_2_IRQ_IN2_INTR_STAT_CLR     8'hc9
// `define SYS_CPU_2_IRQ_IN2_INTR_MASK         8'hca
// `define SYS_CPU_2_IRQ_IN2_INTR_FIRQ_SEL     8'hcb
// `define SYS_CPU_2_IRQ_IN3_INTR_STAT         8'hcc
// `define SYS_CPU_2_IRQ_IN3_INTR_STAT_CLR     8'hcd
// `define SYS_CPU_2_IRQ_IN3_INTR_MASK         8'hce
// `define SYS_CPU_2_IRQ_IN3_INTR_FIRQ_SEL     8'hcf
// ----------------------------------------------
// `define SYS_CPU_3_IRQ_IN0_INTR_STAT         8'hd0
// `define SYS_CPU_3_IRQ_IN0_INTR_STAT_CLR     8'hd1
// `define SYS_CPU_3_IRQ_IN0_INTR_MASK         8'hd2
// `define SYS_CPU_3_IRQ_IN0_INTR_FIRQ_SEL     8'hd3
// `define SYS_CPU_3_IRQ_IN1_INTR_STAT         8'hd4
// `define SYS_CPU_3_IRQ_IN1_INTR_STAT_CLR     8'hd5
// `define SYS_CPU_3_IRQ_IN1_INTR_MASK         8'hd6
// `define SYS_CPU_3_IRQ_IN1_INTR_FIRQ_SEL     8'hd7
// `define SYS_CPU_3_IRQ_IN2_INTR_STAT         8'hd8
// `define SYS_CPU_3_IRQ_IN2_INTR_STAT_CLR     8'hd9
// `define SYS_CPU_3_IRQ_IN2_INTR_MASK         8'hda
// `define SYS_CPU_3_IRQ_IN2_INTR_FIRQ_SEL     8'hdb
// `define SYS_CPU_3_IRQ_IN3_INTR_STAT         8'hdc
// `define SYS_CPU_3_IRQ_IN3_INTR_STAT_CLR     8'hdd
// `define SYS_CPU_3_IRQ_IN3_INTR_MASK         8'hde
// `define SYS_CPU_3_IRQ_IN3_INTR_FIRQ_SEL     8'hdf
// ----------------------------------------------
// `define SYS_CPU_3_IRQ_IN4_INTR_STAT         8'he0
// `define SYS_CPU_3_IRQ_IN4_INTR_STAT_CLR     8'he1
// `define SYS_CPU_3_IRQ_IN4_INTR_MASK         8'he2
// `define SYS_CPU_3_IRQ_IN4_INTR_FIRQ_SEL     8'he3
// `define MEDIA_CPU_IRQ_IN5_INTR_STAT         8'he4
// `define MEDIA_CPU_IRQ_IN5_INTR_STAT_CLR     8'he5
// `define MEDIA_CPU_IRQ_IN5_INTR_MASK         8'he6
// `define MEDIA_CPU_IRQ_IN5_INTR_FIRQ_SEL     8'he7
// `define SYS_CPU_0_IRQ_IN5_INTR_STAT         8'he8
// `define SYS_CPU_0_IRQ_IN5_INTR_STAT_CLR     8'he9
// `define SYS_CPU_0_IRQ_IN5_INTR_MASK         8'hea
// `define SYS_CPU_0_IRQ_IN5_INTR_FIRQ_SEL     8'heb
//
// Closing file:  isa_reg.h
//
// -----------------------------------------------
// CBUS_BASE:  DDR_CBUS_BASE = 0x13
// -----------------------------------------------
// TEMP DEFINES
// -----------------------------------------------
// CBUS_BASE:  PERIPHS4_CBUS_BASE = 0x24
// -----------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS5_CBUS_BASE = 0x25
// -----------------------------------------------
// For iq_om_width change for RealVideo
#define P_IQ_OM_WIDTH                              (volatile unsigned long *)0xc1109440
//`define IQ_OM_WIDTH_12
#define P_DBG_ADDR_START                           (volatile unsigned long *)0xc110bfc0
#define P_DBG_ADDR_END                             (volatile unsigned long *)0xc110bffc
#define P_DBG_CTRL                                 (volatile unsigned long *)0xc110bfc4
#define P_DBG_LED                                  (volatile unsigned long *)0xc110bfc8
#define P_DBG_SWITCH                               (volatile unsigned long *)0xc110bfcc
#define P_DBG_VERSION                              (volatile unsigned long *)0xc110bfd0
//========================================================================
//  Global Control Registers			    (12'h000 - 12'h0ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  RESET_CBUS_BASE = 0x11
// -----------------------------------------------
#define P_VERSION_CTRL                             (volatile unsigned long *)0xc1104400
#define P_RESET0_REGISTER                          (volatile unsigned long *)0xc1104404
#define P_RESET1_REGISTER                          (volatile unsigned long *)0xc1104408
#define P_RESET2_REGISTER                          (volatile unsigned long *)0xc110440c
#define P_RESET3_REGISTER                          (volatile unsigned long *)0xc1104410
#define P_RESET4_REGISTER                          (volatile unsigned long *)0xc1104414
#define P_RESET5_REGISTER                          (volatile unsigned long *)0xc1104418
#define P_RESET6_REGISTER                          (volatile unsigned long *)0xc110441c
#define P_RESET7_REGISTER                          (volatile unsigned long *)0xc1104420
#define P_RESET0_MASK                              (volatile unsigned long *)0xc1104440
#define P_RESET1_MASK                              (volatile unsigned long *)0xc1104444
#define P_RESET2_MASK                              (volatile unsigned long *)0xc1104448
#define P_RESET3_MASK                              (volatile unsigned long *)0xc110444c
#define P_RESET4_MASK                              (volatile unsigned long *)0xc1104450
#define P_RESET5_MASK                              (volatile unsigned long *)0xc1104454
#define P_RESET6_MASK                              (volatile unsigned long *)0xc1104458
#define P_CRT_MASK                                 (volatile unsigned long *)0xc110445c
#define P_RESET7_MASK                              (volatile unsigned long *)0xc1104460
//======================================
//  Reset Register Bits	
//
//======================================
    #define HIU_RESET	    0x0001
    #define VLD_RESET	    0x0002
    #define IQIDCT_RESET	0x0004
    #define MC_RESET	    0x0008
    #define DCU_RESET	    0x0010
    #define VIU_RESET	    0x0020
    #define AIU_RESET	    0x0040
    #define CPU_RESET	    0x0080
    #define AC3_RESET	    0x0100
    #define MPEG_RESET	    0x0200
//========================================================================
//  Host uP Interface				    (12'h100 - 12'h2ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  HIU_CBUS_BASE = 0x10
// -----------------------------------------------
#define P_SCR_HIU                                  (volatile unsigned long *)0xc110402c
#define P_HPG_TIMER                                (volatile unsigned long *)0xc110403c
#define P_HARM_ASB_MB0                             (volatile unsigned long *)0xc11040c0
#define P_HARM_ASB_MB1                             (volatile unsigned long *)0xc11040c4
#define P_HARM_ASB_MB2                             (volatile unsigned long *)0xc11040c8
#define P_HARM_ASB_MB3                             (volatile unsigned long *)0xc11040cc
#define P_HASB_ARM_MB0                             (volatile unsigned long *)0xc11040d0
#define P_HASB_ARM_MB1                             (volatile unsigned long *)0xc11040d4
#define P_HASB_ARM_MB2                             (volatile unsigned long *)0xc11040d8
#define P_HASB_ARM_MB3                             (volatile unsigned long *)0xc11040dc
#define P_HHI_TIMER90K                             (volatile unsigned long *)0xc11040ec
#define P_HHI_MEM_PD_REG0                          (volatile unsigned long *)0xc1104100
#define P_HHI_VPU_MEM_PD_REG0                      (volatile unsigned long *)0xc1104104
#define P_HHI_VPU_MEM_PD_REG1                      (volatile unsigned long *)0xc1104108
#define P_HHI_AUD_DAC_CTRL                         (volatile unsigned long *)0xc1104110
// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
#define P_HHI_VIID_CLK_DIV                         (volatile unsigned long *)0xc1104128
#define P_HHI_VIID_CLK_CNTL                        (volatile unsigned long *)0xc110412c
#define P_HHI_VIID_DIVIDER_CNTL                    (volatile unsigned long *)0xc1104130
// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
#define P_HHI_GCLK_MPEG0                           (volatile unsigned long *)0xc1104140
#define P_HHI_GCLK_MPEG1                           (volatile unsigned long *)0xc1104144
#define P_HHI_GCLK_MPEG2                           (volatile unsigned long *)0xc1104148
#define P_HHI_GCLK_OTHER                           (volatile unsigned long *)0xc1104150
#define P_HHI_GCLK_AO                              (volatile unsigned long *)0xc1104154
#define P_HHI_SYS_CPU_CLK_CNTL1                    (volatile unsigned long *)0xc110415c
// PLL Controls
#define P_HHI_VID_CLK_DIV                          (volatile unsigned long *)0xc1104164
#define P_HHI_MPEG_CLK_CNTL                        (volatile unsigned long *)0xc1104174
#define P_HHI_AUD_CLK_CNTL                         (volatile unsigned long *)0xc1104178
#define P_HHI_VID_CLK_CNTL                         (volatile unsigned long *)0xc110417c
#define P_HHI_WIFI_CLK_CNTL                        (volatile unsigned long *)0xc1104180
#define P_HHI_WIFI_PLL_CNTL                        (volatile unsigned long *)0xc1104184
#define P_HHI_WIFI_PLL_CNTL2                       (volatile unsigned long *)0xc1104188
#define P_HHI_WIFI_PLL_CNTL3                       (volatile unsigned long *)0xc110418c
#define P_HHI_AUD_CLK_CNTL2                        (volatile unsigned long *)0xc1104190
#define P_HHI_VID_DIVIDER_CNTL                     (volatile unsigned long *)0xc1104198
#define P_HHI_SYS_CPU_CLK_CNTL                     (volatile unsigned long *)0xc110419c
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
#define P_HHI_MALI_CLK_CNTL                        (volatile unsigned long *)0xc11041b0
#define P_HHI_MIPI_PHY_CLK_CNTL                    (volatile unsigned long *)0xc11041b8
#define P_HHI_VPU_CLK_CNTL                         (volatile unsigned long *)0xc11041bc
#define P_HHI_OTHER_PLL_CNTL                       (volatile unsigned long *)0xc11041c0
#define P_HHI_OTHER_PLL_CNTL2                      (volatile unsigned long *)0xc11041c4
#define P_HHI_OTHER_PLL_CNTL3                      (volatile unsigned long *)0xc11041c8
#define P_HHI_HDMI_CLK_CNTL                        (volatile unsigned long *)0xc11041cc
#define P_HHI_DEMOD_CLK_CNTL                       (volatile unsigned long *)0xc11041d0
#define P_HHI_SATA_CLK_CNTL                        (volatile unsigned long *)0xc11041d4
#define P_HHI_ETH_CLK_CNTL                         (volatile unsigned long *)0xc11041d8
#define P_HHI_CLK_DOUBLE_CNTL                      (volatile unsigned long *)0xc11041dc
#define P_HHI_VDEC_CLK_CNTL                        (volatile unsigned long *)0xc11041e0
#define P_HHI_VDEC2_CLK_CNTL                       (volatile unsigned long *)0xc11041e4
#define P_HHI_EDP_APB_CLK_CNTL                     (volatile unsigned long *)0xc11041ec
// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
#define P_HHI_HDMI_PLL_CNTL                        (volatile unsigned long *)0xc11041f0
#define P_HHI_HDMI_PLL_CNTL1                       (volatile unsigned long *)0xc11041f4
#define P_HHI_HDMI_PLL_CNTL2                       (volatile unsigned long *)0xc11041f8
#define P_HHI_HDMI_AFC_CNTL                        (volatile unsigned long *)0xc11041fc
#define P_HHI_HDMIRX_CLK_CNTL                      (volatile unsigned long *)0xc1104200
#define P_HHI_HDMIRX_AUD_CLK_CNTL                  (volatile unsigned long *)0xc1104204
#define P_HHI_VID_PLL_MOD_CNTL0                    (volatile unsigned long *)0xc1104210
#define P_HHI_VID_PLL_MOD_LOW_TCNT                 (volatile unsigned long *)0xc1104214
#define P_HHI_VID_PLL_MOD_HIGH_TCNT                (volatile unsigned long *)0xc1104218
#define P_HHI_VID_PLL_MOD_NOM_TCNT                 (volatile unsigned long *)0xc110421c
// Removed `define HHI_DDR_CLK_CNTL            8'h88 
#define P_HHI_USB_CLK_CNTL                         (volatile unsigned long *)0xc1104224
#define P_HHI_GEN_CLK_CNTL                         (volatile unsigned long *)0xc1104228
#define P_HHI_GEN_CLK_CNTL2                        (volatile unsigned long *)0xc110422c
#define P_HHI_JTAG_CONFIG                          (volatile unsigned long *)0xc1104238
#define P_HHI_VAFE_CLKXTALIN_CNTL                  (volatile unsigned long *)0xc110423c
#define P_HHI_VAFE_CLKOSCIN_CNTL                   (volatile unsigned long *)0xc1104240
#define P_HHI_VAFE_CLKIN_CNTL                      (volatile unsigned long *)0xc1104244
#define P_HHI_TVFE_AUTOMODE_CLK_CNTL               (volatile unsigned long *)0xc1104248
#define P_HHI_VAFE_CLKPI_CNTL                      (volatile unsigned long *)0xc110424c
#define P_HHI_VDIN_MEAS_CLK_CNTL                   (volatile unsigned long *)0xc1104250
#define P_HHI_PCM2_CLK_CNTL                        (volatile unsigned long *)0xc1104254
#define P_HHI_PCM_CLK_CNTL                         (volatile unsigned long *)0xc1104258
#define P_HHI_NAND_CLK_CNTL                        (volatile unsigned long *)0xc110425c
#define P_HHI_ISP_LED_CLK_CNTL                     (volatile unsigned long *)0xc1104260
#define P_HHI_EDP_TX_PHY_CNTL0                     (volatile unsigned long *)0xc1104270
#define P_HHI_EDP_TX_PHY_CNTL1                     (volatile unsigned long *)0xc1104274
#define P_HHI_MPLL_CNTL                            (volatile unsigned long *)0xc1104280
#define P_HHI_MPLL_CNTL2                           (volatile unsigned long *)0xc1104284
#define P_HHI_MPLL_CNTL3                           (volatile unsigned long *)0xc1104288
#define P_HHI_MPLL_CNTL4                           (volatile unsigned long *)0xc110428c
#define P_HHI_MPLL_CNTL5                           (volatile unsigned long *)0xc1104290
#define P_HHI_MPLL_CNTL6                           (volatile unsigned long *)0xc1104294
#define P_HHI_MPLL_CNTL7                           (volatile unsigned long *)0xc1104298
#define P_HHI_MPLL_CNTL8                           (volatile unsigned long *)0xc110429c
#define P_HHI_MPLL_CNTL9                           (volatile unsigned long *)0xc11042a0
#define P_HHI_MPLL_CNTL10                          (volatile unsigned long *)0xc11042a4
#define P_HHI_ADC_PLL_CNTL                         (volatile unsigned long *)0xc11042a8
#define P_HHI_ADC_PLL_CNTL2                        (volatile unsigned long *)0xc11042ac
#define P_HHI_ADC_PLL_CNTL3                        (volatile unsigned long *)0xc11042b0
#define P_HHI_ADC_PLL_CNTL4                        (volatile unsigned long *)0xc11042b4
#define P_HHI_AUDCLK_PLL_CNTL                      (volatile unsigned long *)0xc11042c0
#define P_HHI_AUDCLK_PLL_CNTL2                     (volatile unsigned long *)0xc11042c4
#define P_HHI_AUDCLK_PLL_CNTL3                     (volatile unsigned long *)0xc11042c8
#define P_HHI_AUDCLK_PLL_CNTL4                     (volatile unsigned long *)0xc11042cc
#define P_HHI_AUDCLK_PLL_CNTL5                     (volatile unsigned long *)0xc11042d0
#define P_HHI_AUDCLK_PLL_CNTL6                     (volatile unsigned long *)0xc11042d4
#define P_HHI_L2_DDR_CLK_CNTL                      (volatile unsigned long *)0xc11042d8
#define P_HHI_VDAC_CNTL0                           (volatile unsigned long *)0xc11042f4
#define P_HHI_VDAC_CNTL1                           (volatile unsigned long *)0xc11042f8
#define P_HHI_SYS_PLL_CNTL                         (volatile unsigned long *)0xc1104300
#define P_HHI_SYS_PLL_CNTL2                        (volatile unsigned long *)0xc1104304
#define P_HHI_SYS_PLL_CNTL3                        (volatile unsigned long *)0xc1104308
#define P_HHI_SYS_PLL_CNTL4                        (volatile unsigned long *)0xc110430c
#define P_HHI_SYS_PLL_CNTL5                        (volatile unsigned long *)0xc1104310
#define P_HHI_DPLL_TOP_0                           (volatile unsigned long *)0xc1104318
#define P_HHI_DPLL_TOP_1                           (volatile unsigned long *)0xc110431c
#define P_HHI_VID_PLL_CNTL                         (volatile unsigned long *)0xc1104320
#define P_HHI_VID_PLL_CNTL2                        (volatile unsigned long *)0xc1104324
#define P_HHI_VID_PLL_CNTL3                        (volatile unsigned long *)0xc1104328
#define P_HHI_VID_PLL_CNTL4                        (volatile unsigned long *)0xc110432c
#define P_HHI_VID_PLL_CNTL5                        (volatile unsigned long *)0xc1104330
#define P_HHI_VID_PLL_CNTL6                        (volatile unsigned long *)0xc1104334
#define P_HHI_DSI_LVDS_EDP_CNTL0                   (volatile unsigned long *)0xc1104344
#define P_HHI_DSI_LVDS_EDP_CNTL1                   (volatile unsigned long *)0xc1104348
#define P_HHI_CSI_PHY_CNTL0                        (volatile unsigned long *)0xc110434c
#define P_HHI_CSI_PHY_CNTL1                        (volatile unsigned long *)0xc1104350
#define P_HHI_CSI_PHY_CNTL2                        (volatile unsigned long *)0xc1104354
#define P_HHI_CSI_PHY_CNTL3                        (volatile unsigned long *)0xc1104358
#define P_HHI_CSI_PHY_CNTL4                        (volatile unsigned long *)0xc110435c
#define P_HHI_DIF_CSI_PHY_CNTL0                    (volatile unsigned long *)0xc1104360
#define P_HHI_DIF_CSI_PHY_CNTL1                    (volatile unsigned long *)0xc1104364
#define P_HHI_DIF_CSI_PHY_CNTL2                    (volatile unsigned long *)0xc1104368
#define P_HHI_DIF_CSI_PHY_CNTL3                    (volatile unsigned long *)0xc110436c
#define P_HHI_DIF_CSI_PHY_CNTL4                    (volatile unsigned long *)0xc1104370
#define P_HHI_DIF_CSI_PHY_CNTL5                    (volatile unsigned long *)0xc1104374
#define P_HHI_LVDS_TX_PHY_CNTL0                    (volatile unsigned long *)0xc1104378
#define P_HHI_LVDS_TX_PHY_CNTL1                    (volatile unsigned long *)0xc110437c
#define P_HHI_VID2_PLL_CNTL                        (volatile unsigned long *)0xc1104380
#define P_HHI_VID2_PLL_CNTL2                       (volatile unsigned long *)0xc1104384
#define P_HHI_VID2_PLL_CNTL3                       (volatile unsigned long *)0xc1104388
#define P_HHI_VID2_PLL_CNTL4                       (volatile unsigned long *)0xc110438c
#define P_HHI_VID2_PLL_CNTL5                       (volatile unsigned long *)0xc1104390
#define P_HHI_VID2_PLL_CNTL6                       (volatile unsigned long *)0xc1104394
#define P_HHI_HDMI_PHY_CNTL0                       (volatile unsigned long *)0xc11043a0
#define P_HHI_HDMI_PHY_CNTL1                       (volatile unsigned long *)0xc11043a4
#define P_HHI_HDMI_PHY_CNTL2                       (volatile unsigned long *)0xc11043a8
//-----------------------------------------------------------
// PARSER 
//-----------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PARSER_CBUS_BASE = 0x29
// -----------------------------------------------
// bit 31:8 -- es_pack_size
// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
// bit 5 -- es_write
// bit 4 -- es_passthrough
// bit 3 -- insert_before_es_write
// bit 2 -- discard_cmd
// bit 1 -- search_cmd
// bit 0 -- Parser Busy
#define P_PARSER_CONTROL                           (volatile unsigned long *)0xc110a580
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define P_PARSER_FETCH_ADDR                        (volatile unsigned long *)0xc110a584
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian 
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr 
//   4:3 cmd_wr_ptr 
//   2:0 cmd_number 
#define P_PARSER_FETCH_CMD                         (volatile unsigned long *)0xc110a588
// 31:0 stop_fetch_addr
#define P_PARSER_FETCH_STOP_ADDR                   (volatile unsigned long *)0xc110a58c
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define P_PARSER_FETCH_LEVEL                       (volatile unsigned long *)0xc110a590
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits) 
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define P_PARSER_CONFIG                            (volatile unsigned long *)0xc110a594
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define P_PFIFO_WR_PTR                             (volatile unsigned long *)0xc110a598
// bit 9:0 -- point to byte address
#define P_PFIFO_RD_PTR                             (volatile unsigned long *)0xc110a59c
// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
#define P_PFIFO_DATA                               (volatile unsigned long *)0xc110a5a0
// bit 31:0 -- parser search pattern 
#define P_PARSER_SEARCH_PATTERN                    (volatile unsigned long *)0xc110a5a4
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define P_PARSER_SEARCH_MASK                       (volatile unsigned long *)0xc110a5a8
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu 
// bit 7:0 -- Parser interrupt enable for Amrisc 
#define P_PARSER_INT_ENABLE                        (volatile unsigned long *)0xc110a5ac
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based) 
#define P_PARSER_INT_STATUS                        (volatile unsigned long *)0xc110a5b0
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define P_PARSER_SCR_CTL                           (volatile unsigned long *)0xc110a5b4
// bit 31:0 SCR value
#define P_PARSER_SCR                               (volatile unsigned long *)0xc110a5b8
// bit 31:24 -- insert_loop_number
// bit 23:21 -- 
// bit 20:16 -- insert_byte_number 
// bit 15:0 -- discard number
#define P_PARSER_PARAMETER                         (volatile unsigned long *)0xc110a5bc
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continous write to this address can write upto 16 bytes 
#define P_PARSER_INSERT_DATA                       (volatile unsigned long *)0xc110a5c0
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define P_VAS_STREAM_ID                            (volatile unsigned long *)0xc110a5c4
// Bit 31:0 -- VIDEO_DTS
#define P_VIDEO_DTS                                (volatile unsigned long *)0xc110a5c8
// Bit 31:0 -- VIDEO_PTS
#define P_VIDEO_PTS                                (volatile unsigned long *)0xc110a5cc
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define P_VIDEO_PTS_DTS_WR_PTR                     (volatile unsigned long *)0xc110a5d0
// Bit 31:0 -- AUDIO_PTS
#define P_AUDIO_PTS                                (volatile unsigned long *)0xc110a5d4
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define P_AUDIO_PTS_WR_PTR                         (volatile unsigned long *)0xc110a5d8
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:13 -- VIDEO2 Ees_write Endian
// bit 12 -- VIDEO2 using manual read point
// bit 11:9 -- SUB Ees_write Endian 
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian 
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian 
// bit 0 -- VIDEO using manual read point
#define P_PARSER_ES_CONTROL                        (volatile unsigned long *)0xc110a5dc
// Bit 31:0 PFIFO_MONITOR
#define P_PFIFO_MONITOR                            (volatile unsigned long *)0xc110a5e0
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_VIDEO_START_PTR                   (volatile unsigned long *)0xc110a600
#define P_PARSER_VIDEO_END_PTR                     (volatile unsigned long *)0xc110a604
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_VIDEO_WP                          (volatile unsigned long *)0xc110a608
#define P_PARSER_VIDEO_RP                          (volatile unsigned long *)0xc110a60c
#define P_PARSER_VIDEO_HOLE                        (volatile unsigned long *)0xc110a610
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_AUDIO_START_PTR                   (volatile unsigned long *)0xc110a614
#define P_PARSER_AUDIO_END_PTR                     (volatile unsigned long *)0xc110a618
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_AUDIO_WP                          (volatile unsigned long *)0xc110a61c
#define P_PARSER_AUDIO_RP                          (volatile unsigned long *)0xc110a620
#define P_PARSER_AUDIO_HOLE                        (volatile unsigned long *)0xc110a624
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_SUB_START_PTR                     (volatile unsigned long *)0xc110a628
#define P_PARSER_SUB_END_PTR                       (volatile unsigned long *)0xc110a62c
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define P_PARSER_SUB_WP                            (volatile unsigned long *)0xc110a630
#define P_PARSER_SUB_RP                            (volatile unsigned long *)0xc110a634
#define P_PARSER_SUB_HOLE                          (volatile unsigned long *)0xc110a638
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define P_PARSER_FETCH_INFO                        (volatile unsigned long *)0xc110a63c
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define P_PARSER_STATUS                            (volatile unsigned long *)0xc110a640
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define P_PARSER_AV_WRAP_COUNT                     (volatile unsigned long *)0xc110a644
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define P_WRRSP_PARSER                             (volatile unsigned long *)0xc110a648
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug 
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug 
// --------------------------------------------
// PARSER_VIDEO2 DDR Interface
// --------------------------------------------
// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_VIDEO2_START_PTR                  (volatile unsigned long *)0xc110a64c
#define P_PARSER_VIDEO2_END_PTR                    (volatile unsigned long *)0xc110a650
// --------------------------------------------
// PARSER_VIDEO2 Buffer Level Manager
// --------------------------------------------
#define P_PARSER_VIDEO2_WP                         (volatile unsigned long *)0xc110a654
#define P_PARSER_VIDEO2_RP                         (volatile unsigned long *)0xc110a658
#define P_PARSER_VIDEO2_HOLE                       (volatile unsigned long *)0xc110a65c
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO2_wrap_count
#define P_PARSER_AV2_WRAP_COUNT                    (volatile unsigned long *)0xc110a660
// DDR registers
//`define USE_DDR2
//========================================================================
//  DVIN Registers				    (12'h2e0 - 12'h2ef)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  DVIN_CBUS_BASE = 0x12
// -----------------------------------------------
// Bit 31:12 Rsrv
// Bit 11:10 RW, vs_hs_tim_ctrl: Controls which edge of HS/VS the active pixel/line is related:
//                               bit[0]=0: start of active pixel is counted from the rising edge of HS;
//                               bit[0]=1: start of active pixel is counted from the falling edge of HS;
//                               bit[1]=0: start of active line is counted from the rising edge of VS;
//                               bit[1]=1: start of active line is counted from the falling edge of VS.
// Bit     9 RW, sample_clk_neg: 1=invert input dvin_clk
// Bit  8: 7 RW, mode_422to444: 0=No convertion; 1=Rsrv; 2=Convert 422 to 444, use previous C value; 3=Convert 422 to 444, use average C value.
// Bit  6: 5 RW, de_mode: 0x=ignore input DE signal, use internal detection to to determine active pixel;
//                        10=during active pixel, if DE is low, replace input data with the last good data before DE goes low;
//                        11=Active pixel is determined by DE, no internal detection.
// Bit     4 RW, ext_field_sel: 1=Select external input Field, 0=Use internal detected Field.
// Bit     3 RW, field_pol_inv: set to 1 if input Field is low active and ext_field_sel=1
// Bit     2 RW, de_pol_inv: set to 1 if input DE is low active
// Bit     1 RW, vs_pol_inv: set to 1 if input VS is low active
// Bit     0 RW, hs_pol_inv: set to 1 if input HS is low active
#define P_DVIN_FRONT_END_CTRL                      (volatile unsigned long *)0xc1104b80
// Bit 31:28 Reserved
// Bit 27:16 RW, hs_lead_vs_odd_max: Criteria for HW detecting odd/even Field internally: max clock cycles allowed for HS
//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
// Bit 15:12 Reserved
// Bit 11: 0 RW, hs_lead_vs_odd_min: Criteria for HW detecting odd/even Field internally -- min clock cycles allowed for HS
//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
#define P_DVIN_HS_LEAD_VS_ODD                      (volatile unsigned long *)0xc1104b84
// Bit 31:28 Reserved
// Bit 27:16 RW, active_start_pix_fo
// Bit 15:12 Reserved
// Bit 11: 0 RW, active_start_pix_fe
#define P_DVIN_ACTIVE_START_PIX                    (volatile unsigned long *)0xc1104b88
// Bit 31:28 Reserved
// Bit 27:16 RW, active_start_line_fo
// Bit 15:12 Reserved
// Bit 11: 0 RW, active_start_line_fe
#define P_DVIN_ACTIVE_START_LINE                   (volatile unsigned long *)0xc1104b8c
// Bit 31:28 Reserved
// Bit 27:16 RW, field_height_m1
// Bit 15:12 Reserved
// Bit 11: 0 RW, line_width_m1
#define P_DVIN_DISPLAY_SIZE                        (volatile unsigned long *)0xc1104b90
// Bit    31 Rsrv
// Bit    30 R,  vs_in_polarity: 0=active high; 1=active low.
// Bit    29 R,  hs_in_polarity: 0=active high; 1=active low.
// Bit    28 R,  field_odd
// Bit 27:16 R,  hs_lead_vs_cnt
// Bit 15: 4 Rsrv
// Bit  3: 1 RW, data_comp_map: Re-map input data to form YCbCr.
//                              0=YCbCr is {[29:20], [19:10], [ 9: 0]};
//                              1=YCbCr is {[29:20], [ 9: 0], [19:10]};
//                              2=YCbCr is {[ 9: 0], [29:20], [19:10]};
//                              3=YCbCr is {[19:10], [29:20], [ 9: 0]};
//                              4=YCbCr is {[19:10], [ 9: 0], [29:20]};
//                              5=YCbCr is {[ 9: 0], [19:10], [29:20]};
//                              6,7=Rsrv
// Bit     0 RW, dvin_enable
#define P_DVIN_CTRL_STAT                           (volatile unsigned long *)0xc1104b94
//========================================================================
//  DOS registers				    APB allocation from 32'hd0050000
//
//========================================================================
//=======================================================================
// XIF module
// `include "xregs.h"
    #define X_INT_ADR           0x400
    #define GPIO_ADR            0x401
    #define GPIO_ADR_H8         0x402 
    #define WFIFO_DEPTH         8          
    #define WFIFO_PointerWidth  3
    #define WFIFO_WORDSIZE      32
// MAC module
// move them to cpu domain.
//`define CLR_ACC_MAC         12'h410   
//`define CLR_ACC_MAC2        12'h411   
//`define ACC_0               12'h412
//`define ACC_1               12'h413
//`define ACC_2               12'h414
//`define ACC_3               12'h415
//========================================================================
//  Audio Interface				    (12'h500 - 12'h5ff)
//
//========================================================================
//
// Reading file:  aregs.h
//
//========================================================================
//  Audio Interface                                 (8'h00 - 8'hff)
//  Modified : Xuyun Chen Jan 2001
//========================================================================
// Number of bytes expected per NON-PCM frame, including the header.
// 16 bits.  
// -----------------------------------------------
// CBUS_BASE:  AIU_CBUS_BASE = 0x15
// -----------------------------------------------
#define P_AIU_958_BPF                              (volatile unsigned long *)0xc1105400
// Value of burst_info used in IEC958 preamble for a NON-PCM frame. See
// ATSC AC-3 spec Annex B. 16 bits.
#define P_AIU_958_BRST                             (volatile unsigned long *)0xc1105404
// Value of length_code used in IEC958 preamble for an NON-PCM frame. See
// ATSC AC-3 spec Annex B. 16 bits.
#define P_AIU_958_LENGTH                           (volatile unsigned long *)0xc1105408
// How many subframes to padd around the NON-PCM frame. This will 
// be set to 'd3072 if it is a AC-3 audio stream.
// 16 bits
#define P_AIU_958_PADDSIZE                         (volatile unsigned long *)0xc110540c
// 16'd3072
// Misc. control settings for IEC958 interface
// Bit 15:14 pcm_sample_ctl, 00-pcm_no_sample, 01-pcm_sample_up, 10-pcm_sample_down, 11-pcm_sample_down_drop
// Bit 13: if true, force each audio data to left or right according to the bit attached with the audio data
//         This bit should be used with Register AIU_958_force_left(0x505) together
// Bit 12: if true, the U(user data) is from the stream otherwise it is filled by 
//                   zero while encoding iec958 frame
// Bit 11   : if true big endian(highword,lowword) otherwise little endian(lowword,highword)
//            for 32bit mode 
// Bit 10:8 : shift number for 32 bit mode
// Bit 7  : 32 bit mode turn on while This bit is true and Bit 1 is true 
// Bit 6:5 : Specifies output alignment for 16 bit pcm data.
//          00 : dout = {8'b0, din};
//          01 : dout = {4'b0, din, 4'b0};
//          10 : dout = {      din, 8'b0};
// Bit 4  : True if data should be sent out MSB first. LSB first is the
//          default in the spec.
// Bit 3  : True if msb should be extended (only used with 16 bit pcm data.)
// Bit 2  : True if msb of PCM data should be inverted.
// Bit 1  : True if PCM data is 16 bits wide. False if 24 bit or 32bit mode.
// Bit 0  : True if source data is non-PCM data. False if it is PCM data.
#define P_AIU_958_MISC                             (volatile unsigned long *)0xc1105410
// 14'b0_0_0_000_0_0000001
// A write to this register specifies that the next pcm sample sent out
// of the iec958 interface should go into the _left_ channel.
#define P_AIU_958_FORCE_LEFT                       (volatile unsigned long *)0xc1105414
//Read Only
//bit 6:0  how many data discarded in the last dma after one frame data finish transfering to AIU 
// should used together with register AIU_958_dcu_ff_ctrl
#define P_AIU_958_DISCARD_NUM                      (volatile unsigned long *)0xc1105418
//bit 15:8  : A read from this register indicates the IEC958 FIFO count value 
//bit 7 :  ai_958_req_size if ture, set to 8 bits interface, used to handle odd frame continous read  
//bit 6 :  continue seeking and dont discard the rest data in one dma after frame end
//bit 5 :  if true, byte by byte seeking, otherwise word by word seeking
//bit 4 :  if true, the function for sync head seeking is enabled
//bit 3:2 :	IEC958 interrupt mode
// There are two conditions to generate interrupt. The First condition is that one frame data
// have been finished writing into FIFO. The second condition is at least some data of the current 
// frame have been read out(refer to Register AIU_958_ffrdout_thd)
//			00: interrupt is not generated
//			10:	interrupt is generated if the first condition is true 
//			01:	interrupt is generated if the second condition is true 
//			11:	interrupt is generated if both of the conditions are true 
//bit 1: fifo auto disable, High means after one frame data put into the FIFO, the FIFO
//					will automatically disabled
//bit 0: fifo enable
#define P_AIU_958_DCU_FF_CTRL                      (volatile unsigned long *)0xc110541c
// 'b0_0_1_11_1_0
// channel status registers for Left channel
// chstat_l0[15:0] contains bits 15:0 of the channel status word. Note
// that bit zero of the channel status word is sent out first.
// chstat_l1[15:0] contains bits 31:16 of the channel status word.
#define P_AIU_958_CHSTAT_L0                        (volatile unsigned long *)0xc1105420
#define P_AIU_958_CHSTAT_L1                        (volatile unsigned long *)0xc1105424
// Control register for IEC958 interface
// Bit 9:8 what to do if there is a fifo underrun
//         00 => insert 24'h000000
//         01 => insert mute constant as defined below
//         10 => repeat last l/r samples
// Bit 7:5 mute constant
//         000 => 24'h000000
//         001 => 24'h800000
//         010 => 24'h080000
//         011 => 24'h008000
//         100 => 24'h000001
//         101 => 24'h000010
//         110 => 24'h000100
// Bit 4   mute left speaker
// Bit 3   mute right speaker
// Bit 2:1 swap channels
//         00 : L R => L R
//         01 : L R => L L
//         10 : L R => R R
//         11 : L R => R L
// Bit 0   Set this bit to hold iec958 interface after the current
//         subframe has been completely transmitted.
#define P_AIU_958_CTRL                             (volatile unsigned long *)0xc1105428
// 10'b00_000_00_00_0
// A write operation to this register will cause one of the output samples
// to be repeated. This can be used to switch the left and the right
// channels.
#define P_AIU_958_RPT                              (volatile unsigned long *)0xc110542c
// Channel swap and mute control register.
// Bit 15: Mute extra left channel
// Bit 14: Mute extra right channel
// Bit 13: Mute center
// Bit 12: Mute subwoofer
// Bit 11: Mute surround left
// Bit 10: Mute surround right
// Bit  9: Mute left
// Bit  8: Mute right
// Bit 7:6 Channel swap for xtra dac
// Bit 5:4 Channel swap for sub/center dac
// Bit 3:2 Channel swap for surround dac
// Bit 1:0 Channel swap for main l/r dac
// Channel swap possibilities:
// 00 : L R => L R
// 01 : L R => L L
// 10 : L R => R R
// 11 : L R => R L
#define P_AIU_I2S_MUTE_SWAP                        (volatile unsigned long *)0xc1105430
// 16'b0
// Bit 0 : 0=> single two channel stream
//         1=> four two channel streams
#define P_AIU_I2S_SOURCE_DESC                      (volatile unsigned long *)0xc1105434
// Median filter control register
// Bit 1:  0=> data is offset binary
//         1=> data is signed
// Bit 0:  enable median filter
#define P_AIU_I2S_MED_CTRL                         (volatile unsigned long *)0xc1105438
// 2'b10
// Median filter threshold constant
// 16 bits
#define P_AIU_I2S_MED_THRESH                       (volatile unsigned long *)0xc110543c
// 16'h8000
// Describes dac's connected to I2S interface
// Bit 7:  sign extend sample before downshift.
// Bit 6:4 payload downshift constant
// Bit 3:  mute constant
//         0 => 'h0000000
//         1 => 'h800000
// Bit 2:  send msb first
// Bit 1:0 Size of payload
//         Note that this parameter used to be called "size of dacs"
//         It is now called the payload size since a 24 bit payload can
//         actually be connected to any size of dac. The dac will simply
//         disregard the extra bits.
//         00 => 16 bit, alrclk = aoclk/32 
//         01 => 20 bit, alrclk = aoclk/40 
//         10 => 24 bit, alrclk = aoclk/48 
//		   11 => 24 bit, but alrclk = aoclk/64 
#define P_AIU_I2S_DAC_CFG                          (volatile unsigned long *)0xc1105440
// 8'b0_000_1_1_10
// A write to this register will cause the interface to repeat the current
// sample. Can be used to regain synchronization.
// A read from this register indicates that the next sample to be sent
// out of the interface should go into the _left_ channel of the dac.
#define P_AIU_I2S_SYNC                             (volatile unsigned long *)0xc1105444
// Misc regs
// Bit 4 if true, force each audio data to left or right according to the bit attached with the audio data
//         This bit should be used with Register AIU_i2s_sync(0x511) together
// Bit 3:  Same Audio source for IEC958 and I2s stream 0, both from i2s buffer 
// Bit 2:  Set this bit to put i2s interface in hold mode
// Bit 1:0 How to handle underruns
//         00 => send zeros
//         01 => send 'h800000
//         10 => repeat last samples
#define P_AIU_I2S_MISC                             (volatile unsigned long *)0xc1105448
// 5'b0
// Bit 7:0 Audio output config.
//			2 bits for each dac, 7:6 for dac3, 5:4 for dac2,
//								 3:2 for dac1, 1:0 for dac0
//			For each 2bits: 00: connect channel0-1 to the dac
//							01: connect channel2-3 to the dac
//							10: connect channel4-5 to the dac
//							11: connect channel6-7 to the dac
#define P_AIU_I2S_OUT_CFG                          (volatile unsigned long *)0xc110544c
// 8'b0_000000_0
#define P_AIU_I2S_FF_CTRL                          (volatile unsigned long *)0xc1105450
// A write to this register resets the AIU
//Bit 3 reset slow domain iec958
//Bit 2 soft reset iec958 fast domain
//Bit 1 reset slow domain i2s
//Bit 0 soft reset i2s fast domain
#define P_AIU_RST_SOFT                             (volatile unsigned long *)0xc1105454
// Clock generation control register
// Bit 15: enable_ddr_arb, set low to reset
// Bit 14:13 parser_A_addr_sel  00-A_addr_aififo2, 01-A_addr_iec958, 10-A_addr_aififo, 11-A_addr_i2s
// Bit 12: 958 divisor more, if true, divided by 2, 4, 6, 8
// Bit 11: amclk output divisor
//			0 => dont divide
//			1 => divide by 2		
// Bit 10: clock source selection
//        0 => aiclk from pin
//        1 => ai_pll_clk from pll
// Bit 9:8 alrclk skew
//         00 => alrclk transitions at the same time msb is sent
//         01 => alrclk transitions on the cycle before msb is sent
//         10 => alrclk transitions on the cycle after msb is sent
// Bit 7: invert alrclk
// Bit 6: invert aoclk
// Bit 5:4 958 divisor
//        00 => divide by 1
//        01 => divide by 2
//		  10 => divide by 3
//		  11 => divide by 4
// Bit 3:2 i2s divisor. NOTE: this value is ignored if AIU_clk_ctrl_more[5:0] != 0 
//         00 => divide by 1
//         01 => divide by 2
//         10 => divide by 4
//         11 => divide by 8
// Bit 1: enable 958 divider
// Bit 0: enable i2s divider
#define P_AIU_CLK_CTRL                             (volatile unsigned long *)0xc1105458
// 13'b0_0_1_01_1_1_10_11_0_0
// Misc settings that determine the type of adc that is
// connected to the AIU. Reverb mode is deleted.
// Bit 12:  selects adc input
// Bit 11:10 adc size
//           00 => 16 bits
//           01 => 18 bits
//           10 => 20 bits
//           11 => 24 bits
// Bit 9:8   adc l/r swap mode
//           00 => stereo
//           01 => send the right adc input to both l and r speakers
//           01 => send the left adc input to both l and r speakers
//           11 => sum the left and right inputs and forward to
//                both speakers
// Bit 7:5 adata/lrclk skew mode
// Bit 4   1=>invert the adc's lrclk (This is the lrclk going _out_
//         of the chip.
// Bit 3   1=>Latch the data on the positive edge of the _internal_
//         aoclk.
// Bit 2   1=>adc data is in signed 2's complement mode
#define P_AIU_MIX_ADCCFG                           (volatile unsigned long *)0xc110545c
// 12'b01_00_001_1_0_1_00
// Control register that can be changed dynamically. These control
// signals are synchronized internally.
// Bit 12:  if true, toggle each mixed audio data to left or right channel
// Bit 11:  abuf din left selection, if true, select bit 24 of the data from abuf
//		    otherwise select bit 25 of the data from abuf
// Bit 10:9  mix sync select, when music, mic and abuf are mixed togather, the main
//			 sync source can be selected
//     00: not sync source
//	   01: music data is the main sync source
//	   10: abuf input data is the main sync source
//	   11: music and abuf togather as the sync source
// Bit 8:  0=> data from abuf is offset binary
//         1=> data from abuf is signed
// Bit 7:6 the source for data from aiu to abuf 
//           00 => mic
//           01 => mic saled + abuf scaled 
//           10 => mic scaled + abuf scaled + music scaled
//			 11 => music
// Bit 5   channel from aiu to abuf is on
// Bit 4   channel from abuf to aiu is on
// Bit 3   mic is on
// Bit 2   music is on
// Bit 1   if true the mixed data are outputed to i2s dac channel,
//			otherwise the mixed data are outputed to IEC958 output 
// Bit 0   if true music source for mixing is from i2s buffer, 
//			otherwise music source is from iec958 buffer
#define P_AIU_MIX_CTRL                             (volatile unsigned long *)0xc1105460
// 11'b01_1_01_0_0_0_1_1_1
// Bit    15 invert_audin_sclk.
// Bit    14 enable_adc_sclk.
// Bit 13: 8 divisor_adc_sclk.
// Bit     7 invert_acodec_adc_sclk.
// Bit     6 hdmitx_sel_aoclkx2: 0=Select cts_clk_i958 as AIU clk to hdmi_tx_audio_master_clk; 1=Select cts_aoclkx2_int as AIU clk to hdmi_tx_audio_master_clk;
// Bit  5: 0 More control on i2s divisor. For backward compatiblity, this value is ignored if is 0,
//           if non-zero, it takes effect over AIU_clk_ctrl[3:2].
//           0=i2s divisor will use the old value in AIU_clk_ctrl[3:2] (divide by 1/2/4/8)
//           1=divide by 2;
//           2=divide by 3;
//           3=divide by 4;
//           ... and so on ...
//           63=divide by 64.
#define P_AIU_CLK_CTRL_MORE                        (volatile unsigned long *)0xc1105464
// A read from this register pops 16 bits of data off the 958
// fifo. A write has no effect.
#define P_AIU_958_POP                              (volatile unsigned long *)0xc1105468
//gain register for mixing
// for each gain, 
//			 00000: x 0
//			 00001: x 1
//			 00010: x 2
//           00011: x 3
//			 00100: x 4
//			 00101: x 5
//			 00110: x 6
//			......
//           01110: x14
//           01111: x15
//           10000: x 0
//           10001: x 1/16
//           10010: x 2/16
//           10011: x 3/16
//           10100: x 4/16
//			......
//           11110: x 14/16
//           11111: x 15/16
//Bit 14:10 mic gain
//Bit 9:5 	abuf gain
//Bit 4:0 music gain
#define P_AIU_MIX_GAIN                             (volatile unsigned long *)0xc110546c
// 15'b00001_00001_00001
//sync head seeking is supported. The  maxinium length of sync head is
//48-bit-wide.(in byte by byte seeking mode, the maximium is 44-bit-wide).
//It is consisted of 3 words (synword1_synword2_syncword3).
//You can configure the sync head pattern by using sync mask(mask1_mask2_mask3).  
//For example. AC-3 sync head is a 16-bit word(0b77), so syncword1 is set as 0b77, 
//mask1 is 0000(not set), mask2 and mask3 is all masked.
#define P_AIU_958_SYNWORD1                         (volatile unsigned long *)0xc1105470
//16'h0b77  //ac-3 sync head
#define P_AIU_958_SYNWORD2                         (volatile unsigned long *)0xc1105474
//16'h0000  
#define P_AIU_958_SYNWORD3                         (volatile unsigned long *)0xc1105478
//16'h0000
#define P_AIU_958_SYNWORD1_MASK                    (volatile unsigned long *)0xc110547c
//16'h0000 //16-bit ac-3 sync_head
#define P_AIU_958_SYNWORD2_MASK                    (volatile unsigned long *)0xc1105480
//16'hffff
#define P_AIU_958_SYNWORD3_MASK                    (volatile unsigned long *)0xc1105484
//16'hffff
//fifo read-out threshold, one condition to generate interrupt is met after fifo readout counter
//reach this value in a frame, please refer to register AIU_958_dcu_ff_ctrl
#define P_AIU_958_FFRDOUT_THD                      (volatile unsigned long *)0xc1105488
//'h0004
//For pause burst sequence adding, one pause burst sequence is consist of a serious
// pause burst.
//This register defines the length of each pause burst in a pause burst sequence. The size of the
//preamble(Pa, Pb, Pc, Pd) is not counted, but the size of stuff data is counted.
#define P_AIU_958_LENGTH_PER_PAUSE                 (volatile unsigned long *)0xc110548c
//'h0000
//This reigster defines the number of pause burst in a pause burst sequence.
//Bit 15  if true, one pause burst sequence will be added 
//Bit 14:0 the number of pause burst in a pause burst sequence
#define P_AIU_958_PAUSE_NUM                        (volatile unsigned long *)0xc1105490
//'h0000
//The first 16-bit in the payload of pause burst sequence (gap_length)
#define P_AIU_958_PAUSE_PAYLOAD                    (volatile unsigned long *)0xc1105494
//'h0000
//For auto pause function, when enabled, pause burst sequence will be automatically added if the data in
// 958 fifo is less than auto_pause threshold and if fifo is disabled.
//Bit 15   if true, auto pause function enable
//Bit 14   pause pack option, just for debugging and adding one option
//Bit 7:0  auto_pause threshold
#define P_AIU_958_AUTO_PAUSE                       (volatile unsigned long *)0xc1105498
//'h0000
//pause burst sequence payload length( = AIU_958_pause_num * AIU_958_length_per_pause)
#define P_AIU_958_PAUSE_PD_LENGTH                  (volatile unsigned long *)0xc110549c
//'h0000
// Bit 15:12 Rsrv.
// Bit 11: 0 dac_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
#define P_AIU_CODEC_DAC_LRCLK_CTRL                 (volatile unsigned long *)0xc11054a0
//'h002f
// Bit 15:14 Rsrv.
// Bit    13 inv_audin_lrclk: whether to invert lrclk before output to Audin
// Bit    12 inv_acodec_adc_lrclk: whether to invert lrclk before output to Audio Codec
// Bit 11: 0 adc_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
#define P_AIU_CODEC_ADC_LRCLK_CTRL                 (volatile unsigned long *)0xc11054a4
//'h002f
// Bit 15:6 Rsrv.
// Bit  5: 4 hdmi_data_sel: 00=output 0, disable hdmi data; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
// Bit  3: 2 Rsrv.
// Bit  1: 0 hdmi_clk_sel: 00=Disable output hdmi clock; 01=Select pcm clock; 10=Select AIU clk; 11=Not allowed.
#define P_AIU_HDMI_CLK_DATA_CTRL                   (volatile unsigned long *)0xc11054a8
//'h0000
// Bit 15:6 Rsrv.
// Bit  5: 4 acodec_data_sel: 00=output 0, disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
// Bit  3: 2 Rsrv.
// Bit  1: 0 acodec_clk_sel: 00=Disable output acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
#define P_AIU_CODEC_CLK_DATA_CTRL                  (volatile unsigned long *)0xc11054ac
//'h0000
// channel status registers for right channel
// chstat_r0[15:0] contains bits 15:0 of the channel status word. Note
// that bit zero of the channel status word is sent out first.
// chstat_r1[15:0] contains bits 31:16 of the channel status word.
#define P_AIU_958_CHSTAT_R0                        (volatile unsigned long *)0xc11054c0
#define P_AIU_958_CHSTAT_R1                        (volatile unsigned long *)0xc11054c4
//Bit 1 	if true, turn on Digital output Valid control
//Bit 0		0: output 0, 1: output 1 to the valid bit in audio digital output when Bit 1 is true
#define P_AIU_958_VALID_CTRL                       (volatile unsigned long *)0xc11054c8
//-----------------------------------------------------------------------------
// Audio Amplifier controls
//-----------------------------------------------------------------------------
#define P_AIU_AUDIO_AMP_REG0                       (volatile unsigned long *)0xc11054f0
#define P_AIU_AUDIO_AMP_REG1                       (volatile unsigned long *)0xc11054f4
#define P_AIU_AUDIO_AMP_REG2                       (volatile unsigned long *)0xc11054f8
#define P_AIU_AUDIO_AMP_REG3                       (volatile unsigned long *)0xc11054fc
//-----------------------------------------------------------------------------
//add for AIFIFO2 channel
//-----------------------------------------------------------------------------
//Bit 3 	CRC pop aififo2 enable
//Bit 2		writing to this bit to 1 causes CRC module reset
//Bit 1		unused
//Bit 0		writing to this bit to 1 causes AIFIFO2 soft reset
#define P_AIU_AIFIFO2_CTRL                         (volatile unsigned long *)0xc1105500
//'h0000
//AIFIFO2 status register
//Bit 4:0		//how many bits left in the first pop register
#define P_AIU_AIFIFO2_STATUS                       (volatile unsigned long *)0xc1105504
//Same fucntion as the AIGBIT of AIFIFO in CDROM module
//write to this register how many bits wanna pop, 
//and reading this register gets the corresponding bits data
#define P_AIU_AIFIFO2_GBIT                         (volatile unsigned long *)0xc1105508
//Same function as the AICLB of AIFIFO in CDROM module
//return the leading zeros by reading this registers
#define P_AIU_AIFIFO2_CLB                          (volatile unsigned long *)0xc110550c
//CRC control register, read/write
//Bit 0		CRC caculation start
//Bit 1		CRC core soft reset
//Bit 2		CRC input register clear
//Bit 3		CRC pop data from FIFO enable
//Bit 13:8	CRC polynomial equation order, between 1 to 32
#define P_AIU_CRC_CTRL                             (volatile unsigned long *)0xc1105510
//16'h1000
//CRC status register, read only
//Bit 7:4	CRC internal shift register bit select, just for debug purpose
//Bit 3		CRC internal shift register data valid, just for debug purpose
//Bit 2		CRC input register data valid
//Bit 1		CRC result, 1: CRC not correct, 0: CRC correct
//Bit 0		CRC state,  1: CRC busy, 0: CRC idle
#define P_AIU_CRC_STATUS                           (volatile unsigned long *)0xc1105514
//CRC internal shift register, read only, for debug purpose
#define P_AIU_CRC_SHIFT_REG                        (volatile unsigned long *)0xc1105518
//CRC data input register, read/write
#define P_AIU_CRC_IREG                             (volatile unsigned long *)0xc110551c
//16'h0000
//CRC calculation register high-bit part [31:16], read/write
#define P_AIU_CRC_CAL_REG1                         (volatile unsigned long *)0xc1105520
//CRC calculation register low-bit part [15:0], read/write
#define P_AIU_CRC_CAL_REG0                         (volatile unsigned long *)0xc1105524
//32'h00000000
//CRC polynomial coefficient high-bit part [31:16], read/write
#define P_AIU_CRC_POLY_COEF1                       (volatile unsigned long *)0xc1105528
//CRC polynomial coefficient low-bit part [15:0], read/write
#define P_AIU_CRC_POLY_COEF0                       (volatile unsigned long *)0xc110552c
//32'h80050000			default CRC-16
//CRC frame size, high-bit part [19:16], read/write
#define P_AIU_CRC_BIT_SIZE1                        (volatile unsigned long *)0xc1105530
//CRC frame size, low-bit part [15:0],	 read/write
#define P_AIU_CRC_BIT_SIZE0                        (volatile unsigned long *)0xc1105534
//20'hfffff
//how many bits have been processed right now in the current frame, read only
//high-bit part [19:16]
#define P_AIU_CRC_BIT_CNT1                         (volatile unsigned long *)0xc1105538
//low-bit part [15:0]
#define P_AIU_CRC_BIT_CNT0                         (volatile unsigned long *)0xc110553c
// -------------------------------------
// AMCLK Measurement
// -------------------------------------
// Used to measure the amclk frequency
#define P_AIU_AMCLK_GATE_HI                        (volatile unsigned long *)0xc1105540
#define P_AIU_AMCLK_GATE_LO                        (volatile unsigned long *)0xc1105544
#define P_AIU_AMCLK_MSR                            (volatile unsigned long *)0xc1105548
#define P_AIU_AUDAC_CTRL0                          (volatile unsigned long *)0xc110554c
// -------------------------------------
// Super Simple Delta Sigma DAC
// -------------------------------------
// bit 15   1 = invert the clock to the analog filter
// bit 14   1 = digital mute
// bit 13   1 = enable analog mute (in the analog block)
// bit 12   1 = enable Right channel 3 in the analog block
// bit 11   1 = enable Left  channel 3 in the analog block
// bit 10   1 = enable Right channel 2 in the analog block
// bit  9   1 = enable Left  channel 2 in the analog block
// bit  8   1 = enable Right channel 1 in the analog block
// bit  7   1 = enable Left  channel 1 in the analog block
// bit  6   1 = enable Right channel 0 in the analog block
// bit  5   1 = enable Left  channel 0 in the analog block
// bit  4:  bit select for serial input data
// bit  3:  invert alrclk used by the delta-sigma DAC
// bit  2:  1 = use serial I2S data.  0 = use parallel audio data
// bits 1:0 Which data to send to the delta-sigma DAC
//              11 = use channel 3 data
//              10 = use channel 2 data
//              01 = use channel 1 data
//              00 = use channel 0 data
#define P_AIU_DELTA_SIGMA0                         (volatile unsigned long *)0xc1105554
// Delta Sigma MUTE Value
#define P_AIU_DELTA_SIGMA1                         (volatile unsigned long *)0xc1105558
// Additional Audio filter controls
#define P_AIU_DELTA_SIGMA2                         (volatile unsigned long *)0xc110555c
//Bit 14, left channel Delta Sigma modulator soft reset
//Bit 13, right channel Delta Sigma modulator soft reset
//Bit 12, left channel Delta Sigma modulator internal state clear enable when it is unstable
//Bit 11, right channel Delta Sigma modulator internal state clear enable when it is unstable
//Bit 10, left channel Delta Sigma detect unstable state enable
//Bit  9, right channel Delta Sigma detect unstable state enable
//Bit  8, dither high pass filter enable in the Delta Sigma loop
//Bit 7:6, reserved
//Bit 5:0, Delta Sigma input data gain  0/32 ~ 63/32
//default: 16'h3
#define P_AIU_DELTA_SIGMA3                         (volatile unsigned long *)0xc1105560
//15:8, Added Delta Sigma DC level, range:+-1/2, minimium: +-1/128 (assume max is -1 ~ +1)
//7:0, max same sequence number, used for unstable detection
//default: 16'h0
#define P_AIU_DELTA_SIGMA4                         (volatile unsigned long *)0xc1105564
//Bit 15:8, square wave divide num
//Bit 7:0, square wave amplitude, -1/4 ~ 1/4, minimium: +-1/1024
//default: 16'h0
#define P_AIU_DELTA_SIGMA5                         (volatile unsigned long *)0xc1105568
//Bit 11:8, loop dither amplitude2, 0/32 ~ 15/32
//Bit 7:4,  loop dither amplitude1, 0/32 ~ 15/32
//Bit 3:0,  loop dither amplitude0, 0/32 ~ 15/32
//default: 16'h0
#define P_AIU_DELTA_SIGMA6                         (volatile unsigned long *)0xc110556c
//Bit 15:8, loop dithering threshold1   0, 1/512, 2/512 ... 1/2
//Bit 7:0,  loop dithering threshold0   0, 1/512, 2/512 ... 1/2
//default: 16'h0
#define P_AIU_DELTA_SIGMA7                         (volatile unsigned long *)0xc1105570
//read only
//Bit 15:8  left channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
//          It will saturate to 255, if more than 255 time
//Bit 7:0   left channel max same sequence number
#define P_AIU_DELTA_SIGMA_LCNTS                    (volatile unsigned long *)0xc1105574
//read only
//Bit 15:8  right channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
//          It will saturate to 255, if more than 255 time
//Bit 7:0   right channel max same sequence number
#define P_AIU_DELTA_SIGMA_RCNTS                    (volatile unsigned long *)0xc1105578
// --------------------------------------------
// I2S DDR Interface
// --------------------------------------------
// The I2S start pointer into DDR memory is a 32-bit number
#define P_AIU_MEM_I2S_START_PTR                    (volatile unsigned long *)0xc1105580
#define P_AIU_MEM_I2S_RD_PTR                       (volatile unsigned long *)0xc1105584
#define P_AIU_MEM_I2S_END_PTR                      (volatile unsigned long *)0xc1105588
// There are two masks that control how data is read:
// [31:16] IRQ block.
// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
#define P_AIU_MEM_I2S_MASKS                        (volatile unsigned long *)0xc110558c
// I2S FIFO Control
// bits [11:10] Select which hardware pointer to use to control the buffer
//              level:
//                  00 = parser 
//                  01 = audin_fifo0_wrpt 
//                  1x = audin_fifo1_wrpt 
// bit  [9]     Use level control: 1 = use buffer level control
// bit  [8]     Read Only.  This bit is 1 when there is data available for reading
// bit  [7]     Read only.  This bit will be high when we're fetching data from the DDR memory
//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//              After that you can pulse cntl_init to start over
// bit  [6]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR
// bits [5:3]   endian:  see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading data from the FIFO
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
#define P_AIU_MEM_I2S_CONTROL                      (volatile unsigned long *)0xc1105590
// --------------------------------------------
// IEC958 DDR Interface
// --------------------------------------------
// The IEC958 start pointer into DDR memory is a 32-bit number
#define P_AIU_MEM_IEC958_START_PTR                 (volatile unsigned long *)0xc1105594
#define P_AIU_MEM_IEC958_RD_PTR                    (volatile unsigned long *)0xc1105598
#define P_AIU_MEM_IEC958_END_PTR                   (volatile unsigned long *)0xc110559c
// There are two masks that control how data is read:
// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
#define P_AIU_MEM_IEC958_MASKS                     (volatile unsigned long *)0xc11055a0
// IEC958 FIFO Control
// bit  [31]    A_urgent
// bit  [30]    ch_always_8
// bit  [29:24] rdata_rd_base_begin ( used for select from different channel ) 
// bit  [23:14] reserved
// bit  [13]    cntl_sim_en
// bit  [12]    cntl_use_level
// bit  [11]    Read only.      This bit will be set to 1 when there is data in the FIFO to process
// bit  [10]    Read only.  This bit will be high when we're fetching data from the DDR memory
//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//              After that you can pulse cntl_init to start over
// bit  [9]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to the rest of the IEC958 logic
// bit  [8]     mode_raw:       Set this bit to 1 to tell the IEC958 FIFO to read
//                              and process data linearly for raw data.  
// bit  [7]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR.  Only valid when mode_raw = 0
// bit  [6]     cntl_rd_ddr     Set this bit to read if you want AIU_MEM_IEC958_RD_PTR and
//                              AIU_MEM_IEC958_RD_PTR_HIGH to refer to the pointer into DDR memory.
//                              Otherwise, the curr_ptr registers refer to the byte address of the data
//                              at the output of the FIFO to the rest of the IEC958 logic
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
#define P_AIU_MEM_IEC958_CONTROL                   (volatile unsigned long *)0xc11055a4
// --------------------------------------------
// AIFIFO2 DDR Interface
// --------------------------------------------
// The AIFIFO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_AIU_MEM_AIFIFO2_START_PTR                (volatile unsigned long *)0xc11055a8
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define P_AIU_MEM_AIFIFO2_CURR_PTR                 (volatile unsigned long *)0xc11055ac
#define P_AIU_MEM_AIFIFO2_END_PTR                  (volatile unsigned long *)0xc11055b0
#define P_AIU_MEM_AIFIFO2_BYTES_AVAIL              (volatile unsigned long *)0xc11055b4
// AIFIFO2 FIFO Control
// bit  [15:11] unused
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to getbit
// bit  [6]     unused  
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define P_AIU_MEM_AIFIFO2_CONTROL                  (volatile unsigned long *)0xc11055b8
// --------------------------------------------
// AIFIFO2 Buffer Level Manager
// --------------------------------------------
#define P_AIU_MEM_AIFIFO2_MAN_WP                   (volatile unsigned long *)0xc11055bc
#define P_AIU_MEM_AIFIFO2_MAN_RP                   (volatile unsigned long *)0xc11055c0
#define P_AIU_MEM_AIFIFO2_LEVEL                    (volatile unsigned long *)0xc11055c4
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_AIU_MEM_AIFIFO2_BUF_CNTL                 (volatile unsigned long *)0xc11055c8
// --------------------------------------------
// I2S Buffer Level Manager
// --------------------------------------------
#define P_AIU_MEM_I2S_MAN_WP                       (volatile unsigned long *)0xc11055cc
#define P_AIU_MEM_I2S_MAN_RP                       (volatile unsigned long *)0xc11055d0
#define P_AIU_MEM_I2S_LEVEL                        (volatile unsigned long *)0xc11055d4
//
// bit  [1]     mode            0 = parser (or audin_fifo0 or audin_fifo1), 
//                              1 for manual write pointer 
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_AIU_MEM_I2S_BUF_CNTL                     (volatile unsigned long *)0xc11055d8
#define P_AIU_MEM_I2S_BUF_WRAP_COUNT               (volatile unsigned long *)0xc11055dc
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_I2S_MEM_CTL                      (volatile unsigned long *)0xc11055e0
//-----------------------------------------------------------------------------
// Additional IEC958 registers (new feature)
//-----------------------------------------------------------------------------
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_IEC958_MEM_CTL                   (volatile unsigned long *)0xc11055e4
#define P_AIU_MEM_IEC958_WRAP_COUNT                (volatile unsigned long *)0xc11055e8
#define P_AIU_MEM_IEC958_IRQ_LEVEL                 (volatile unsigned long *)0xc11055ec
#define P_AIU_MEM_IEC958_MAN_WP                    (volatile unsigned long *)0xc11055f0
#define P_AIU_MEM_IEC958_MAN_RP                    (volatile unsigned long *)0xc11055f4
#define P_AIU_MEM_IEC958_LEVEL                     (volatile unsigned long *)0xc11055f8
#define P_AIU_MEM_IEC958_BUF_CNTL                  (volatile unsigned long *)0xc11055fc
//-----------------------------------------------------------------------------
// add for AIFIFO channel (old $cdrom/rtl/cdr_top/getbit)
//-----------------------------------------------------------------------------
// Bit 3 	CRC pop aififo enable
// Bit 2		writing to this bit to 1 causes CRC module reset
// Bit 1		enable aififo
// Bit 0		writing to this bit to 1 causes aififo soft reset
#define P_AIU_AIFIFO_CTRL                          (volatile unsigned long *)0xc1105600
//'h0000
// AIFIFO status register
// Bit 13		//aififo request to dcu status
// Bit 12		//dcu select status
// Bit 11:5		//aififo word counter number 
// Bit 4:0		//how many bits left in the first pop register
#define P_AIU_AIFIFO_STATUS                        (volatile unsigned long *)0xc1105604
// Same fucntion as the AIGBIT of AIFIFO in CDROM module
// write to this register how many bits wanna pop, 
// and reading this register gets the corresponding bits data
#define P_AIU_AIFIFO_GBIT                          (volatile unsigned long *)0xc1105608
// Same function as the AICLB of AIFIFO in CDROM module
// return the leading zeros by reading this registers
#define P_AIU_AIFIFO_CLB                           (volatile unsigned long *)0xc110560c
// --------------------------------------------
// AIFIFO DDR Interface
// --------------------------------------------
// The AIFIFO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_AIU_MEM_AIFIFO_START_PTR                 (volatile unsigned long *)0xc1105610
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define P_AIU_MEM_AIFIFO_CURR_PTR                  (volatile unsigned long *)0xc1105614
#define P_AIU_MEM_AIFIFO_END_PTR                   (volatile unsigned long *)0xc1105618
#define P_AIU_MEM_AIFIFO_BYTES_AVAIL               (volatile unsigned long *)0xc110561c
// AIFIFO FIFO Control
// bit  [15:11] unused
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to getbit
// bit  [6]     unused  
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define P_AIU_MEM_AIFIFO_CONTROL                   (volatile unsigned long *)0xc1105620
// --------------------------------------------
// AIFIFO Buffer Level Manager
// --------------------------------------------
#define P_AIU_MEM_AIFIFO_MAN_WP                    (volatile unsigned long *)0xc1105624
#define P_AIU_MEM_AIFIFO_MAN_RP                    (volatile unsigned long *)0xc1105628
#define P_AIU_MEM_AIFIFO_LEVEL                     (volatile unsigned long *)0xc110562c
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_AIU_MEM_AIFIFO_BUF_CNTL                  (volatile unsigned long *)0xc1105630
#define P_AIU_MEM_AIFIFO_BUF_WRAP_COUNT            (volatile unsigned long *)0xc1105634
#define P_AIU_MEM_AIFIFO2_BUF_WRAP_COUNT           (volatile unsigned long *)0xc1105638
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_AIFIFO_MEM_CTL                   (volatile unsigned long *)0xc110563c
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_AIFIFO_TIME_STAMP_CNTL                   (volatile unsigned long *)0xc1105640
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_AIFIFO_TIME_STAMP_SYNC_0                 (volatile unsigned long *)0xc1105644
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_AIFIFO_TIME_STAMP_SYNC_1                 (volatile unsigned long *)0xc1105648
// bit 31:0 TIME_STAMP_0
#define P_AIFIFO_TIME_STAMP_0                      (volatile unsigned long *)0xc110564c
// bit 31:0 TIME_STAMP_1
#define P_AIFIFO_TIME_STAMP_1                      (volatile unsigned long *)0xc1105650
// bit 31:0 TIME_STAMP_2
#define P_AIFIFO_TIME_STAMP_2                      (volatile unsigned long *)0xc1105654
// bit 31:0 TIME_STAMP_3
#define P_AIFIFO_TIME_STAMP_3                      (volatile unsigned long *)0xc1105658
// bit 31:0 TIME_STAMP_LENGTH
#define P_AIFIFO_TIME_STAMP_LENGTH                 (volatile unsigned long *)0xc110565c
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_AIFIFO2_TIME_STAMP_CNTL                  (volatile unsigned long *)0xc1105660
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_AIFIFO2_TIME_STAMP_SYNC_0                (volatile unsigned long *)0xc1105664
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_AIFIFO2_TIME_STAMP_SYNC_1                (volatile unsigned long *)0xc1105668
// bit 31:0 TIME_STAMP_0
#define P_AIFIFO2_TIME_STAMP_0                     (volatile unsigned long *)0xc110566c
// bit 31:0 TIME_STAMP_1
#define P_AIFIFO2_TIME_STAMP_1                     (volatile unsigned long *)0xc1105670
// bit 31:0 TIME_STAMP_2
#define P_AIFIFO2_TIME_STAMP_2                     (volatile unsigned long *)0xc1105674
// bit 31:0 TIME_STAMP_3
#define P_AIFIFO2_TIME_STAMP_3                     (volatile unsigned long *)0xc1105678
// bit 31:0 TIME_STAMP_LENGTH
#define P_AIFIFO2_TIME_STAMP_LENGTH                (volatile unsigned long *)0xc110567c
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_IEC958_TIME_STAMP_CNTL                   (volatile unsigned long *)0xc1105680
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_IEC958_TIME_STAMP_SYNC_0                 (volatile unsigned long *)0xc1105684
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_IEC958_TIME_STAMP_SYNC_1                 (volatile unsigned long *)0xc1105688
// bit 31:0 TIME_STAMP_0
#define P_IEC958_TIME_STAMP_0                      (volatile unsigned long *)0xc110568c
// bit 31:0 TIME_STAMP_1
#define P_IEC958_TIME_STAMP_1                      (volatile unsigned long *)0xc1105690
// bit 31:0 TIME_STAMP_2
#define P_IEC958_TIME_STAMP_2                      (volatile unsigned long *)0xc1105694
// bit 31:0 TIME_STAMP_3
#define P_IEC958_TIME_STAMP_3                      (volatile unsigned long *)0xc1105698
// bit 31:0 TIME_STAMP_LENGTH
#define P_IEC958_TIME_STAMP_LENGTH                 (volatile unsigned long *)0xc110569c
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_AIFIFO2_MEM_CTL                  (volatile unsigned long *)0xc11056a0
// --------------------------------------------
// CBUS_DDR interface for I2S_FAST
// --------------------------------------------
// bit[31:26] unused
// bit[25]      A_req       level
// bit[24]      data_req    If this bit is 1, then (a_req_cnt != 'h0)
// bit[23:16]   a_req_cnt   This value corresponds to the number of 32-bit words 
//                          requested by the i2s_fast() module
// bit[15:7]    unused
// bit[6]                   Set this bit to mux in the cbus_ddr_interface
// bit[5]                   Set this bit to allow back to back A_req's to be serviced
// bit[4]                   Set this bit to generate an IRQ on the first A_req
//                          If this bit is 0, then an IRQ is generated after all requests 
//                          are completed and how many 32-bit words to send is calculated.
// bit[3:1]                 Endian
// bit[0]                   Set this bit enable the cbus_ddr_interface
#define P_AIU_I2S_CBUS_DDR_CNTL                    (volatile unsigned long *)0xc11056a4
// 32-bit data to write to the cbus_ddr interface
#define P_AIU_I2S_CBUS_DDR_WDATA                   (volatile unsigned long *)0xc11056a8
// First address associated with the first request by the i2s_fast() to read DDR data
#define P_AIU_I2S_CBUS_DDR_ADDR                    (volatile unsigned long *)0xc11056ac
//
// Closing file:  aregs.h
//
//========================================================================
//  CDROM Interface                                 (12'h600 - 12'h6ff)
//
//========================================================================
//========================================================================
//	registers for ge2d (12'h8a0 - 12'h8ff)
//========================================================================
//
// Reading file:  ge2d_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// GE2D Registers    0x8a0 - 0x8ff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  GE2D_CBUS_BASE = 0x18
// -----------------------------------------------
//Bit 31, destination bytemask only if destination bitmask is enable
//Bit 30, destination bitmask enable
//Bit 29, source2 key  enable
//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 27, source1 key  enable
//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 25:24, dst1 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
//Bit 22:17,  reserved
//Bit 16:15, src2 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
//Bit 9:7    reserved
//Bit 6:5,   src1  8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
//Bit 3      src1 lookup table enable
//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
//Bit 0      src1 separate buffer enable
#define P_GE2D_GEN_CTRL0                           (volatile unsigned long *)0xc1106280
//Bit 31, soft rst
//Bit 30, dst write response counter reset  
//Bit 29, disable adding dst write response count to busy bit 
//Bit 28:26, reserved
//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
//Bit 23:22 src2 burst size control
//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords  
//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
//Bit 11, dst2 request urgent enable
//Bit 10, src1 request urgent enable
//Bit 9,  src2 request urgent enable
//Bit 8,  dst1 request urgent enable
//Bit 7:0 src1 global alpha
#define P_GE2D_GEN_CTRL1                           (volatile unsigned long *)0xc1106284
//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0; 
//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
//                 otherwise, color_out = (color < 128) ? color: color + 1;
//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs 
//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs 
//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs 
//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs 
//Bit 23     if true, dst little endian, otherwise big endian
//Bit 22:19 dst1 color_map
//        dst1_format=0                  : output 8-bit;
//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15    if true, src2 little endian, otherwise big endian
//Bit 14:11  src2 color_map
//        src2_format=0                 : output 8-bit;
//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
//Bit 7     if true, src1 little endian, otherwise big endian
//Bit 6:3   src1 color_map
//        src1_format=0                 : output 8-bit;
//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.     
//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit 
#define P_GE2D_GEN_CTRL2                           (volatile unsigned long *)0xc1106288
//Bit 9     if true, all src2 data use default color
//Bit 8     if true, all src1 data use default color
//Bit 7     if true, dst x/y swap 
//Bit 6     if true, dst x direction reversely read
//Bit 5     if true, dst y direction reversely read
//Bit 4     if true, src2 x direction reversely read
//Bit 3     if true, src2 y direction reversely read
//Bit 2     if true, src1 x direction reversely read
//Bit 1     if true, src1 y direction reversely read
//Bit 0     cmd write
#define P_GE2D_CMD_CTRL                            (volatile unsigned long *)0xc110628c
//Read only
//Bit 28:17 dst write response counter, for debug only
//Bit 16:7  ge2d_dp status, for debug only
//Bit 6     read src1 cmd ready
//Bit 5     read src2 cmd ready
//Bit 4     pre dpcmd ready
//Bit 3     ge2d dpcmd ready
//Bit 2     ge2d buffer command valid
//Bit 1     ge2d current command valid
//Bit 0     ge2d busy
#define P_GE2D_STATUS0                             (volatile unsigned long *)0xc1106290
//
//Read only
// Bit 29:16 ge2d_dst1_status, for debug only
// Bit    15 ge2d_rd_src2 core.fifo_empty
// Bit    14 ge2d_rd_src2 core.fifo_overflow
// Bit 13:12 ge2d_rd_src2 core.req_st
// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
#define P_GE2D_STATUS1                             (volatile unsigned long *)0xc1106294
//SRC1 default clolor
//{Y,Cb,Cr,A}/{R,G,B,A}
#define P_GE2D_SRC1_DEF_COLOR                      (volatile unsigned long *)0xc1106298
//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip x start
//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip x end
#define P_GE2D_SRC1_CLIPX_START_END                (volatile unsigned long *)0xc110629c
//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip y start
//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip y end
#define P_GE2D_SRC1_CLIPY_START_END                (volatile unsigned long *)0xc11062a0
//Bit 31:24, SRC1 canvas address0
//Bit 23:16, SRC1 canvas address1
//Bit 15:8, SRC1 canvas address2
#define P_GE2D_SRC1_CANVAS                         (volatile unsigned long *)0xc11062a4
//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
//             or x even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 29:16, SRC1 x start, signed data
//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
//             or x even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
//Bit 13:0, SRC1 x end, signed data
#define P_GE2D_SRC1_X_START_END                    (volatile unsigned long *)0xc11062a8
//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
//             or y even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 28:16, SRC1 y start
//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
//             or y even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
//Bit 12:0, SRC1 y end
#define P_GE2D_SRC1_Y_START_END                    (volatile unsigned long *)0xc11062ac
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_GE2D_SRC1_LUT_ADDR                       (volatile unsigned long *)0xc11062b0
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_GE2D_SRC1_LUT_DAT                        (volatile unsigned long *)0xc11062b4
//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
//Bit 18, horizontal formatter en
//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
//Bit 16, vertical formatter en
//Bit 15:8 X direction chroma phase,  
//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
//                or start/end even/odd chroma phase  when y/c ratio = 1 
//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
//Bit 7:0  Y direction chroma phase, 
//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
//          or start/end even/odd chroma phase  when y/c ratio = 1 
//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2 
#define P_GE2D_SRC1_FMT_CTRL                       (volatile unsigned long *)0xc11062b8
//SRC2 default clolor
//{Y,Cb,Cr,A}/{R,G,B,A}
#define P_GE2D_SRC2_DEF_COLOR                      (volatile unsigned long *)0xc11062bc
//Bit 28:16, SRC2 clip x start
//Bit 12:0, SRC2 clip x end
#define P_GE2D_SRC2_CLIPX_START_END                (volatile unsigned long *)0xc11062c0
//Bit 28:16, SRC2 clip y start
//Bit 12:0, SRC2 clip y end
#define P_GE2D_SRC2_CLIPY_START_END                (volatile unsigned long *)0xc11062c4
//Bit 28:16, SRC2 x start
//Bit 12:0, SRC2 x end
#define P_GE2D_SRC2_X_START_END                    (volatile unsigned long *)0xc11062c8
//Bit 28:16, SRC2 y start
//Bit 12:0, SRC2 y end
#define P_GE2D_SRC2_Y_START_END                    (volatile unsigned long *)0xc11062cc
//Bit 28:16, DST clip x start
//Bit 12:0, DST clip x end
#define P_GE2D_DST_CLIPX_START_END                 (volatile unsigned long *)0xc11062d0
//
//Bit 28:16, DST clip y start
//Bit 12:0, DST clip y end
#define P_GE2D_DST_CLIPY_START_END                 (volatile unsigned long *)0xc11062d4
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define P_GE2D_DST_X_START_END                     (volatile unsigned long *)0xc11062d8
//
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define P_GE2D_DST_Y_START_END                     (volatile unsigned long *)0xc11062dc
//Bit 23:16 DST2 canvas address
//Bit 15:8 SRC2 canvas address
//Bit 7:0 DST1 canvas address
#define P_GE2D_SRC2_DST_CANVAS                     (volatile unsigned long *)0xc11062e0
//vertical scaler phase step
//Bit 28:0,  5.24 format
#define P_GE2D_VSC_START_PHASE_STEP                (volatile unsigned long *)0xc11062e4
//phase slope 
//Bit 24:0, bit 24 signed bit
#define P_GE2D_VSC_PHASE_SLOPE                     (volatile unsigned long *)0xc11062e8
//Bit 30:29, vertical repeat line0 number 
//Bit 23:0, vertical scaler initial phase
#define P_GE2D_VSC_INI_CTRL                        (volatile unsigned long *)0xc11062ec
//horizontal scaler phase step
//Bit 28:0,  5.24 format
#define P_GE2D_HSC_START_PHASE_STEP                (volatile unsigned long *)0xc11062f0
//phase slope 
//Bit 24:0, bit 24 signed bit
#define P_GE2D_HSC_PHASE_SLOPE                     (volatile unsigned long *)0xc11062f4
//Bit 30:29, horizontal repeat line0 number 
//Bit 23:0, horizontal scaler initial phase
#define P_GE2D_HSC_INI_CTRL                        (volatile unsigned long *)0xc11062f8
//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode 
#define P_GE2D_HSC_ADV_CTRL                        (volatile unsigned long *)0xc11062fc
//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4 
//Bit 28, horizontal scaler dividing mode enable
//Bit 27:15, horizontal dividing length, if bit 28 is enable
//Bit 14, pre horizontal scaler enable 
//Bit 13, pre vertical scale enable
//Bit 12, vertical scale enable
//Bit 11, horizontal scaler enable
//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line, 
//        otherwise using treat horizontal repeat line number as minus line number. 
//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line, 
//        otherwise using treat vertical repeat line number as minus line number. 
//Bit 7, if true, always use phase0 in vertical scaler
//Bit 6:4, vertical scaler bank length
//Bit 3, if true, always use phase0 in horizontal scaler
//Bit 2:0, horizontal scaler bank length
#define P_GE2D_SC_MISC_CTRL                        (volatile unsigned long *)0xc1106300
//Read only
//vertical scaler next round integer pixel pointer, signed data
//Bit 13:0
#define P_GE2D_VSC_NRND_POINT                      (volatile unsigned long *)0xc1106304
//Read only
//vertical scaler next round phase
//bit 23:0
#define P_GE2D_VSC_NRND_PHASE                      (volatile unsigned long *)0xc1106308
//Read only
//horizontal scaler next round integer pixel pointer, signed data
//Bit 13:0
#define P_GE2D_HSC_NRND_POINT                      (volatile unsigned long *)0xc110630c
//Read only
//horizontal scaler next round phase
//bit 23:0
#define P_GE2D_HSC_NRND_PHASE                      (volatile unsigned long *)0xc1106310
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1 
//Bit 8:0,   pre_offset2
#define P_GE2D_MATRIX_PRE_OFFSET                   (volatile unsigned long *)0xc1106314
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_GE2D_MATRIX_COEF00_01                    (volatile unsigned long *)0xc1106318
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_GE2D_MATRIX_COEF02_10                    (volatile unsigned long *)0xc110631c
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_GE2D_MATRIX_COEF11_12                    (volatile unsigned long *)0xc1106320
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_GE2D_MATRIX_COEF20_21                    (volatile unsigned long *)0xc1106324
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define P_GE2D_MATRIX_COEF22_CTRL                  (volatile unsigned long *)0xc1106328
//Bit 28:20, offset0
//Bit 18:10, offset1 
//Bit 8:0,   offset2
#define P_GE2D_MATRIX_OFFSET                       (volatile unsigned long *)0xc110632c
//Bit 26:25, SRC1 color multiplier alpha selection
//           if 00, Cs = Csr
//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
//           if 10, Cs = Csr * Ag (if source is premultipied)
//Bit 24    SRC2 color multiplier alpha selection 
//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.   
//Bit 22:12 ALU color operation
//          bit10:8 Blending Mode Parameter
//            3'b000: ADD               Cs*Fs + Cd*Fd
//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
//            3'b101: LOGIC OP          Cs op Cd
//          bit7:4 Source Color Blending Factor CFs
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 logic operations, when bit10:8 == LOGIC OP
//            4'b0000: CLEAR                       0
//            4'b0001: COPY                        s
//            4'b0010: NOOP                        d
//            4'b0011: SET                         1
//            4'b0100: COPY_INVERT                 ~s
//            4'b0101: INVERT                      ~d
//            4'b0110: AND_REVERSE                 s & ~d
//            4'b0111: OR_REVERSE                  s | ~d
//            4'b1000: AND                         s & d
//            4'b1001: OR                          s | d
//            4'b1010: NAND                        ~(s & d)
//            4'b1011: NOR                         ~(s | d)
//            4'b1100: XOR                         s ^ d
//            4'b1101: EQUIV                       ~(s ^ d)
//            4'b1110: AND_INVERTED                ~s & d
//            4'b1111: OR_INVERTED                 ~s | d
//Bit 10:0  ALU alpha operation
//            bit10:8 Blending Equation Math Operation
//              3'b000: ADD               As*Fs + Ad*Fd
//              3'b001: SUBTRACT          As*Fs - Ad*Fd
//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
//              3'b011: MIN               min(As*Fs, Ad*Fd)
//              3'b100: MAX               max(As*Fs, Ad*Fd)
//              3'b101: LOGIC OP          As op Ad
//            bit7:4 Source alpha Blending Factor AFs
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 logic operations, when bit10:8 == LOGIC OP
//              4'b0000: CLEAR                       0
//              4'b0001: COPY                        s
//              4'b0010: NOOP                        d
//              4'b0011: SET                         1
//              4'b0100: COPY_INVERT                 ~s
//              4'b0101: INVERT                      ~d
//              4'b0110: AND_REVERSE                 s & ~d
//              4'b0111: OR_REVERSE                  s | ~d
//              4'b1000: AND                         s & d
//              4'b1001: OR                          s | d
//              4'b1010: NAND                        ~(s & d)
//              4'b1011: NOR                         ~(s | d)
//              4'b1100: XOR                         s ^ d
//              4'b1101: EQUIV                       ~(s ^ d)
//              4'b1110: AND_INVERTED                ~s & d
//              4'b1111: OR_INVERTED                 ~s | d
#define P_GE2D_ALU_OP_CTRL                         (volatile unsigned long *)0xc1106330
//bit 31:0 (RGBA,YCBCRA)
#define P_GE2D_ALU_CONST_COLOR                     (volatile unsigned long *)0xc1106334
//SRC1 Key
//31:0 
#define P_GE2D_SRC1_KEY                            (volatile unsigned long *)0xc1106338
//SRC1 Key Mask
//31:0 
#define P_GE2D_SRC1_KEY_MASK                       (volatile unsigned long *)0xc110633c
//SRC2 Key
//31:0 
#define P_GE2D_SRC2_KEY                            (volatile unsigned long *)0xc1106340
//SRC2 Key Mask
//31:0 
#define P_GE2D_SRC2_KEY_MASK                       (volatile unsigned long *)0xc1106344
//Destination Bit Mask
//31:0 
#define P_GE2D_DST_BITMASK                         (volatile unsigned long *)0xc1106348
//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
//Bit 30:16     DP on counter
//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
//Bit 14:0      DP off counter
#define P_GE2D_DP_ONOFF_CTRL                       (volatile unsigned long *)0xc110634c
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define P_GE2D_SCALE_COEF_IDX                      (volatile unsigned long *)0xc1106350
//coefficients for vertical filter and horizontal filter
#define P_GE2D_SCALE_COEF                          (volatile unsigned long *)0xc1106354
//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
//                                for the area outside the clipping window. As below:
//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
//Bit 23:16 src2 outside alpha
//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above. 
//Bit 7:0   src1 outside alpha
#define P_GE2D_SRC_OUTSIDE_ALPHA                   (volatile unsigned long *)0xc1106358
//Bit 31       antiflick enable
//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha 
//Bit 23:16     register value for the first line alpha when bit 24 is 1 
//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha 
//Bit 7:0      register value for the last line alpha when bit 8 is 1 
#define P_GE2D_ANTIFLICK_CTRL0                     (volatile unsigned long *)0xc1106360
//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA 
//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
//Bit 23:16, R mult coef for converting RGB to Y
//Bit 15:8,  G mult coef for converting RGB to Y
//Bit 7:0,   B mult coef for converting RGB to Y
//Y = (R * y_r + G * y_g + B * y_b) / 256
#define P_GE2D_ANTIFLICK_CTRL1                     (volatile unsigned long *)0xc1106364
//Bit 31:24, Y threhold1, when   0<Y<=th1, use filter0;
//Bit 23:16, color antiflick filter0 n3
//Bit 15:8,  color antiflick filter0 n2
//Bit 7:0,   color antiflick filter0 n1
//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define P_GE2D_ANTIFLICK_COLOR_FILT0               (volatile unsigned long *)0xc1106368
//Bit 31:24, Y threhold2, when th1<Y<=th2, use filter1;
//Bit 23:16, color antiflick filter1 n3
//Bit 15:8,  color antiflick filter1 n2
//Bit 7:0,   color antiflick filter1 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT1               (volatile unsigned long *)0xc110636c
//Bit 31:24, Y threhold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
//Bit 23:16, color antiflick filter2 n3
//Bit 15:8,  color antiflick filter2 n2
//Bit 7:0,   color antiflick filter2 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT2               (volatile unsigned long *)0xc1106370
//Bit 23:16, color antiflick filter3 n3
//Bit 15:8,  color antiflick filter3 n2
//Bit 7:0,   color antiflick filter3 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT3               (volatile unsigned long *)0xc1106374
//Bit 31:24, Alpha threhold1, when   0<Alpha<=th1, use filter0;
//Bit 23:16, Alpha antiflick filter0 n3
//Bit 15:8,  Alpha antiflick filter0 n2
//Bit 7:0,   Alpha antiflick filter0 n1
//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define P_GE2D_ANTIFLICK_ALPHA_FILT0               (volatile unsigned long *)0xc1106378
//Bit 31:24, Alpha threhold2, when th1<Alpha<=th2, use filter1;
//Bit 23:16, Alpha antiflick filter1 n3
//Bit 15:8,  Alpha antiflick filter1 n2
//Bit 7:0,   Alpha antiflick filter1 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT1               (volatile unsigned long *)0xc110637c
//Bit 31:24, Alpha threhold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
//Bit 23:16, Alpha antiflick filter2 n3
//Bit 15:8,  Alpha antiflick filter2 n2
//Bit 7:0,   Alpha antiflick filter2 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT2               (volatile unsigned long *)0xc1106380
//Bit 23:16, Alpha antiflick filter3 n3
//Bit 15:8,  Alpha antiflick filter3 n2
//Bit 7:0,   Alpha antiflick filter3 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT3               (volatile unsigned long *)0xc1106384
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_Y_CTRL               (volatile unsigned long *)0xc110638c
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_CB_CTRL              (volatile unsigned long *)0xc1106390
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_CR_CTRL              (volatile unsigned long *)0xc1106394
//Bit 21:16     src1 prearbitor burst number
//Bit 13:8      src2 prearbitor burst number
//Bit 5:0       dst prearbitor burst number
#define P_GE2D_ARB_BURST_NUM                       (volatile unsigned long *)0xc1106398
//each 6bit ID, high 4bit are thread ID, low 2bits are the token
//Bit 21:16 src1 ID
//Bit 13:8 src2 ID
//Bit 5:0  dst ID
#define P_GE2D_TID_TOKEN                           (volatile unsigned long *)0xc110639c
//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
//Bit 25:24, dst2 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 22:19 dst2 color_map
//        dst2_format=0                  : output 8-bit;
//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15     reserved
//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     9 reserved
//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
//Bit  7: 6 reserved
//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     1 reserved
//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
#define P_GE2D_GEN_CTRL3                           (volatile unsigned long *)0xc11063a0
//Read only
// Bit 13:0 ge2d_dst2_status, for debug only
#define P_GE2D_STATUS2                             (volatile unsigned long *)0xc11063a4
//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
#define P_GE2D_GEN_CTRL4                           (volatile unsigned long *)0xc11063a8
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ge2d_regs.h
//
//========================================================================
//  DSP Co-Processor Registers			    ( 8'he00 - 12'hfff)
//
//========================================================================
// Duplicate Address:  When actually used
// please move to a different address
// `define AUDIO_COP_CTL1      12'hf00  // r & w; r-> 6'h00,bsmod[2:0],acmod[2:0],lfeon,nfchans[2:0]
#define P_AUDIO_COP_CTL2                           (volatile unsigned long *)0xc1107c04
//  f02 -f0d are special regs , not in ac3_reg.h, but used by CPU for AC3 operations
#define P_OPERAND_M_CTL                            (volatile unsigned long *)0xc1107c08
#define P_OPERAND1_ADDR                            (volatile unsigned long *)0xc1107c0c
#define P_OPERAND2_ADDR                            (volatile unsigned long *)0xc1107c10
#define P_RESULT_M_CTL                             (volatile unsigned long *)0xc1107c14
#define P_RESULT1_ADDR                             (volatile unsigned long *)0xc1107c18
#define P_RESULT2_ADDR                             (volatile unsigned long *)0xc1107c1c
#define P_ADD_SHFT_CTL                             (volatile unsigned long *)0xc1107c20
#define P_OPERAND_ONE_H                            (volatile unsigned long *)0xc1107c24
#define P_OPERAND_ONE_L                            (volatile unsigned long *)0xc1107c28
#define P_OPERAND_TWO_H                            (volatile unsigned long *)0xc1107c2c
#define P_OPERAND_TWO_L                            (volatile unsigned long *)0xc1107c30
#define P_RESULT_H                                 (volatile unsigned long *)0xc1107c34
#define P_RESULT_M                                 (volatile unsigned long *)0xc1107c38
// special reg 
#define P_RESULT_L                                 (volatile unsigned long *)0xc1107c3c
// 
#define P_WMEM_R_PTR                               (volatile unsigned long *)0xc1107c40
#define P_WMEM_W_PTR                               (volatile unsigned long *)0xc1107c44
#define P_AUDIO_LAYER                              (volatile unsigned long *)0xc1107c80
#define P_AC3_DECODING                             (volatile unsigned long *)0xc1107c84
#define P_AC3_DYNAMIC                              (volatile unsigned long *)0xc1107c88
#define P_AC3_MELODY                               (volatile unsigned long *)0xc1107c8c
#define P_AC3_VOCAL                                (volatile unsigned long *)0xc1107c90
//======================================
//  CPU Assist module
//
//======================================
// -----------------------------------------------
// CBUS_BASE:  ASSIST_CBUS_BASE = 0x1f
// -----------------------------------------------
//`define ASSIST_AMR_MBOX1_INT          8'h4d
//`define ASSIST_AMR_MBOX2_INT          8'h4e
#define P_ASSIST_AMR_SCRATCH0                      (volatile unsigned long *)0xc1107d3c
#define P_ASSIST_AMR_SCRATCH1                      (volatile unsigned long *)0xc1107d40
#define P_ASSIST_AMR_SCRATCH2                      (volatile unsigned long *)0xc1107d44
#define P_ASSIST_AMR_SCRATCH3                      (volatile unsigned long *)0xc1107d48
#define P_ASSIST_HW_REV                            (volatile unsigned long *)0xc1107d4c
//`define ASSIST_CBUS_ARB               8'h54
#define P_ASSIST_POR_CONFIG                        (volatile unsigned long *)0xc1107d54
#define P_ASSIST_SPARE16_REG1                      (volatile unsigned long *)0xc1107d58
#define P_ASSIST_SPARE16_REG2                      (volatile unsigned long *)0xc1107d5c
#define P_ASSIST_SPARE8_REG1                       (volatile unsigned long *)0xc1107d60
#define P_ASSIST_SPARE8_REG2                       (volatile unsigned long *)0xc1107d64
// Duplicate Address...when used please move to a new address
// `define TO_AMRISC_REG                 8'h59 // for amrisc
#define P_ASSIST_SPARE8_REG3                       (volatile unsigned long *)0xc1107d68
// Duplicate Address...when used please move to a new address
// `define FROM_AMRISC_REG               8'h5a // for amrisc
// Duplicate Address...when used please move to a new address
// `define MPEG2_DECODER_CONTROL         8'h5b // for amrisc
#define P_AC3_CTRL_REG1                            (volatile unsigned long *)0xc1107d6c
#define P_AC3_CTRL_REG2                            (volatile unsigned long *)0xc1107d70
#define P_AC3_CTRL_REG3                            (volatile unsigned long *)0xc1107d74
#define P_AC3_CTRL_REG4                            (volatile unsigned long *)0xc1107d78
//`define ASSIST_PMEM_SPLIT             8'h5f
#define P_ASSIST_GEN_CNTL                          (volatile unsigned long *)0xc1107da0
#define P_EE_ASSIST_MBOX0_IRQ_REG                  (volatile unsigned long *)0xc1107dc0
#define P_EE_ASSIST_MBOX0_CLR_REG                  (volatile unsigned long *)0xc1107dc4
#define P_EE_ASSIST_MBOX0_MASK                     (volatile unsigned long *)0xc1107dc8
#define P_EE_ASSIST_MBOX0_FIQ_SEL                  (volatile unsigned long *)0xc1107dcc
#define P_EE_ASSIST_MBOX1_IRQ_REG                  (volatile unsigned long *)0xc1107dd0
#define P_EE_ASSIST_MBOX1_CLR_REG                  (volatile unsigned long *)0xc1107dd4
#define P_EE_ASSIST_MBOX1_MASK                     (volatile unsigned long *)0xc1107dd8
#define P_EE_ASSIST_MBOX1_FIQ_SEL                  (volatile unsigned long *)0xc1107ddc
#define P_EE_ASSIST_MBOX2_IRQ_REG                  (volatile unsigned long *)0xc1107de0
#define P_EE_ASSIST_MBOX2_CLR_REG                  (volatile unsigned long *)0xc1107de4
#define P_EE_ASSIST_MBOX2_MASK                     (volatile unsigned long *)0xc1107de8
#define P_EE_ASSIST_MBOX2_FIQ_SEL                  (volatile unsigned long *)0xc1107dec
#define P_EE_ASSIST_MBOX3_IRQ_REG                  (volatile unsigned long *)0xc1107df0
#define P_EE_ASSIST_MBOX3_CLR_REG                  (volatile unsigned long *)0xc1107df4
#define P_EE_ASSIST_MBOX3_MASK                     (volatile unsigned long *)0xc1107df8
#define P_EE_ASSIST_MBOX3_FIQ_SEL                  (volatile unsigned long *)0xc1107dfc
// -----------------------------------------------
// CBUS_BASE:  AUD_CBUS_BASE = 0x28
// -----------------------------------------------
// ----------------------------
// AUDIN (64)
// ----------------------------
#define P_AUDIN_SPDIF_MODE                         (volatile unsigned long *)0xc110a000
    #define SPDIF_EN                31
    #define SPDIF_INT_EN            30
    #define SPDIF_BURST_PRE_INT_EN  29
    #define SPDIF_TIE_0             24
    #define SPDIF_SAMPLE_SEL        23
    #define SPDIF_REVERSE_EN        22
    #define SPDIF_BIT_ORDER         20
    #define SPDIF_CHNL_ORDER        19
    #define SPDIF_DATA_TYPE_SEL     18
    #define SPDIF_XTDCLK_UPD_ITVL   14   //16:14
    #define SPDIF_CLKNUM_54U        0     //13:0 
#define P_AUDIN_SPDIF_FS_CLK_RLTN                  (volatile unsigned long *)0xc110a004
    #define SPDIF_CLKNUM_192K  24     //29:24 
    #define SPDIF_CLKNUM_96K   18     //23:18 
    #define SPDIF_CLKNUM_48K   12     //17:12 
    #define SPDIF_CLKNUM_44K   6     // 11:6
    #define SPDIF_CLKNUM_32K   0     // 5:0
#define P_AUDIN_SPDIF_CHNL_STS_A                   (volatile unsigned long *)0xc110a008
#define P_AUDIN_SPDIF_CHNL_STS_B                   (volatile unsigned long *)0xc110a00c
#define P_AUDIN_SPDIF_MISC                         (volatile unsigned long *)0xc110a010
#define P_AUDIN_SPDIF_NPCM_PCPD                    (volatile unsigned long *)0xc110a014
#define P_AUDIN_SPDIF_END                          (volatile unsigned long *)0xc110a03c
#define P_AUDIN_I2SIN_CTRL                         (volatile unsigned long *)0xc110a040
    #define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
    #define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
    #define I2SIN_LRCLK_SEL 2
    #define I2SIN_POS_SYNC  3
    #define I2SIN_LRCLK_SKEW 4    // 6:4
    #define I2SIN_LRCLK_INVT 7
    #define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
    #define I2SIN_CHAN_EN   10    //13:10. 
    #define I2SIN_EN        15
// Bit 31:15    Rsrv.
// Bit 14:12 RW HDMI-RX SPDIF channel status select to report on AUDIN_DECODE_CHANNEL_STATUS_A_*: 0=select channel 1; 1=channel 2; ...; 7=channel 8.
// Bit 11: 8 RW HDMI-RX SPDIF channel status extraction enable, 1-bit per channel pair. To enable, SPDIF input source also must select 1.
// Bit  7: 6    Rsrv.
// Bit  5: 4 RW SPDIF input source select. 0=Default, select chip external; 1=select HDMI RX output; 2/3=Rsrv.
// Bit  3: 2    Rsrv.
// Bit  1: 0 RW I2S input source select. 0=Default, select chip external; 1=select audio codec output; 2=select HDMI RX output; 3=Rsrv.
#define P_AUDIN_SOURCE_SEL                         (volatile unsigned long *)0xc110a044
// The following registers control the new alternative decoder -- hdmi_tx_audio_decoder, in audin module
// Bit 31:25    Rsrv.
// Bit    24 RW SPDIF enable.
// Bit 23:22    Rsrv.
// Bit 21:20 RW i2s_block_start_src: 0=left channel 0 is approved as block start generator, ..., 3=left channel 3 is the block start generator.
// Bit 19:17    Rsrv.
// Bit    16 RW I2S enable.
// Bit 15: 8 RW audio_channel_alloc: Usage indication of up to 8 channels. If the correspoinding bit is 1, then this channel is used.
//                                   E.g.: In 2-channel audio, it is 00000011
// Bit     7 RW hdmi_tx_audio_decoder input sel: 0=SPDIF; 1=I2S.
// Bit     6 RW i2s_channel_config: 0=2-channel; 1=8-channel.
// Bit  5: 4 RW i2s_format_select: 0=left-justify; 1=right-justify; 2=I2S format; 3=DSP format.
// Bit  3: 2 RW i2s_bit_width: 0=16-bit; 1=18-bit; 2=20-bit; 3=24-bit.
// Bit     1 RW ws polarity: 0=0 is left, 1 is right; 1=1 is left, 0 is right.
// Bit     0 RW For SPDIF mode, 0=use channel status from input data; 1=use channel status from registers;
//              For I2S mode, 0=one-bit audio; 1=I2S.
#define P_AUDIN_DECODE_FORMAT                      (volatile unsigned long *)0xc110a048
// Bit 31:25    Rsrv.
// Bit    24 R  channel_status stablility indicator.
// Bit 23:16 RW Valid bits for audio sample packet. [7] for valid_sp3_right, [6] for valid_sp3_left, ..., [1] for valid_sp0_right, [0] for valid_sp0_left.
// Bit 15: 8 RW User bits for audio sample packet. [7] for user_sp3_right, [6] for user_sp3_left, ..., [1] for user_sp0_right, [0] for user_sp0_left.
// Bit  7: 4 RW cntl_init_discard: Number of initial hdmi_tx_audio_decoder samples to discard from reset.
// Bit     3 RW cntl_invert_i2s_lrclk: Invert WS before input to hdmi_tx_audio_decoder.
// Bit     2 RW audio_valid_overwrite: Valid bit selection in audio packet. 0=use input data; 1=use
// Bit     1 RW audio_user_overwrite: User bit selection in audio packet. 0=use input data; 1=use
// Bit     0 RW audio_sample_valid: sample non-flat indication. 0=flat, non-valid; 1=non-flat, valid.
#define P_AUDIN_DECODE_CONTROL_STATUS              (volatile unsigned long *)0xc110a04c
// IEC958 192-bit channel status: muxed between 8 channels, channel selection by AUDIN_SOURCE_SEL[14:12]
#define P_AUDIN_DECODE_CHANNEL_STATUS_A_0          (volatile unsigned long *)0xc110a050
#define P_AUDIN_DECODE_CHANNEL_STATUS_A_1          (volatile unsigned long *)0xc110a054
#define P_AUDIN_DECODE_CHANNEL_STATUS_A_2          (volatile unsigned long *)0xc110a058
#define P_AUDIN_DECODE_CHANNEL_STATUS_A_3          (volatile unsigned long *)0xc110a05c
#define P_AUDIN_DECODE_CHANNEL_STATUS_A_4          (volatile unsigned long *)0xc110a060
#define P_AUDIN_DECODE_CHANNEL_STATUS_A_5          (volatile unsigned long *)0xc110a064
#define P_AUDIN_FIFO0_START                        (volatile unsigned long *)0xc110a080
#define P_AUDIN_FIFO0_END                          (volatile unsigned long *)0xc110a084
#define P_AUDIN_FIFO0_PTR                          (volatile unsigned long *)0xc110a088
#define P_AUDIN_FIFO0_INTR                         (volatile unsigned long *)0xc110a08c
#define P_AUDIN_FIFO0_RDPTR                        (volatile unsigned long *)0xc110a090
#define P_AUDIN_FIFO0_CTRL                         (volatile unsigned long *)0xc110a094
    #define AUDIN_FIFO0_EN       0
    #define AUDIN_FIFO0_RST      1
    #define AUDIN_FIFO0_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
         
    #define AUDIN_FIFO0_DIN_SEL  3
            // 0     spdifIN
            // 1     i2Sin
            // 2     PCMIN
            // 3     HDMI in
            // 4     DEMODULATOR IN
    #define AUDIN_FIFO0_ENDIAN   8    //10:8   data endian control.
    #define AUDIN_FIFO0_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
    #define AUDIN_FIFO0_UG       15    // urgent request enable.
    #define AUDIN_FIFO0_HOLD0_EN  19  
    #define AUDIN_FIFO0_HOLD1_EN  20
    #define AUDIN_FIFO0_HOLD2_EN  21
    #define AUDIN_FIFO0_HOLD0_SEL 22   // 23:22
    #define AUDIN_FIFO0_HOLD1_SEL 24   // 25:24
    #define AUDIN_FIFO0_HOLD2_SEL 26   // 27:26
    #define AUDIN_FIFO0_HOLD_LVL  28   // 27:26


#define P_AUDIN_FIFO0_CTRL1                        (volatile unsigned long *)0xc110a098
  //5:4    fifo0_dest_sel.  00: MMC DDR SDRAM. 01: parser. 10: PIO mode. use cbus to read data.
  //3:2    fifo0 din byte num.  00 : 1 byte. 01: 2 bytes.  10: 3 bytes. 11: 4 bytes.
  //1:0    fifo0 din_pos.  
       // for din byte num = 2 bytes 
         // 00:    the coming data is at 32bits input [15:0].
         // 01:    the coming data is at [23:8];
         // 10:    the coming data is at [31:16]; 
       // for din byte num = 3 bytes.
           //00:   the coming data is at [23:0]  and it will be saved as {8'h0, din[23:0]} format in audin fifo.
           //01:   the coming data is at [23:0],  it will be saved as {din[23:0], 8'h0} format in audin fifo.
           //10:   the coming data is at [31:8], it will be saved as {8'h0, din[31:8]}. 
           //11:   the coming data is at [31:8], it will be saved as {din[31:8], 8'h0}.
#define P_AUDIN_FIFO0_LVL0                         (volatile unsigned long *)0xc110a09c
#define P_AUDIN_FIFO0_LVL1                         (volatile unsigned long *)0xc110a0a0
#define P_AUDIN_FIFO0_LVL2                         (volatile unsigned long *)0xc110a0a4
#define P_AUDIN_FIFO0_REQID                        (volatile unsigned long *)0xc110a0c0
#define P_AUDIN_FIFO0_WRAP                         (volatile unsigned long *)0xc110a0c4
#define P_AUDIN_FIFO1_START                        (volatile unsigned long *)0xc110a0cc
#define P_AUDIN_FIFO1_END                          (volatile unsigned long *)0xc110a0d0
#define P_AUDIN_FIFO1_PTR                          (volatile unsigned long *)0xc110a0d4
#define P_AUDIN_FIFO1_INTR                         (volatile unsigned long *)0xc110a0d8
#define P_AUDIN_FIFO1_RDPTR                        (volatile unsigned long *)0xc110a0dc
#define P_AUDIN_FIFO1_CTRL                         (volatile unsigned long *)0xc110a0e0
    #define AUDIN_FIFO1_EN       0
    #define AUDIN_FIFO1_RST      1
    #define AUDIN_FIFO1_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
         
    #define AUDIN_FIFO1_DIN_SEL  3
            // 0     spdifIN
            // 1     i2Sin
            // 2     PCMIN
            // 3     HDMI in
            // 4     DEMODULATOR IN
    #define AUDIN_FIFO1_ENDIAN   8    //10:8   data endian control.
    #define AUDIN_FIFO1_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
    #define AUDIN_FIFO1_UG       15    // urgent request enable.
    #define AUDIN_FIFO1_HOLD0_EN  19  
    #define AUDIN_FIFO1_HOLD1_EN  20
    #define AUDIN_FIFO1_HOLD2_EN  21
    #define AUDIN_FIFO1_HOLD0_SEL 22   // 23:22
    #define AUDIN_FIFO1_HOLD1_SEL 24   // 25:24
    #define AUDIN_FIFO1_HOLD2_SEL 26   // 27:26
    #define AUDIN_FIFO1_HOLD_LVL  28   // 27:26
#define P_AUDIN_FIFO1_CTRL1                        (volatile unsigned long *)0xc110a0e4
  //5:4    fifo1_dest_sel.  00: MMC DDR SDRAM. 01: parser. 10: PIO mode. use cbus to read data.
  //3:2    fifo1 din byte num.  00 : 1 byte. 01: 2 bytes.  10: 3 bytes. 11: 4 bytes.
  //1:0    fifo1 din_pos.  
       // for din byte num = 2 bytes 
         // 00:    the coming data is at 32bits input [15:0].
         // 01:    the coming data is at [23:8];
         // 10:    the coming data is at [31:16]; 
       // for din byte num = 3 bytes.
           //00:   the coming data is at [23:0]  and it will be saved as {8'h0, din[23:0]} format in audin fifo.
           //01:   the coming data is at [23:0],  it will be saved as {din[23:0], 8'h0} format in audin fifo.
           //10:   the coming data is at [31:8], it will be saved as {8'h0, din[31:8]}. 
           //11:   the coming data is at [31:8], it will be saved as {din[31:8], 8'h0}.
#define P_AUDIN_FIFO1_LVL0                         (volatile unsigned long *)0xc110a100
#define P_AUDIN_FIFO1_LVL1                         (volatile unsigned long *)0xc110a104
#define P_AUDIN_FIFO1_LVL2                         (volatile unsigned long *)0xc110a108
#define P_AUDIN_FIFO1_REQID                        (volatile unsigned long *)0xc110a10c
#define P_AUDIN_FIFO1_WRAP                         (volatile unsigned long *)0xc110a110
#define P_AUDIN_FIFO2_START                        (volatile unsigned long *)0xc110a114
#define P_AUDIN_FIFO2_END                          (volatile unsigned long *)0xc110a118
#define P_AUDIN_FIFO2_PTR                          (volatile unsigned long *)0xc110a11c
#define P_AUDIN_FIFO2_INTR                         (volatile unsigned long *)0xc110a120
#define P_AUDIN_FIFO2_RDPTR                        (volatile unsigned long *)0xc110a124
#define P_AUDIN_FIFO2_CTRL                         (volatile unsigned long *)0xc110a128
#define P_AUDIN_FIFO2_CTRL1                        (volatile unsigned long *)0xc110a12c
#define P_AUDIN_FIFO2_LVL0                         (volatile unsigned long *)0xc110a130
#define P_AUDIN_FIFO2_LVL1                         (volatile unsigned long *)0xc110a134
#define P_AUDIN_FIFO2_LVL2                         (volatile unsigned long *)0xc110a138
#define P_AUDIN_FIFO2_REQID                        (volatile unsigned long *)0xc110a13c
#define P_AUDIN_FIFO2_WRAP                         (volatile unsigned long *)0xc110a140
#define P_AUDIN_INT_CTRL                           (volatile unsigned long *)0xc110a144
   //22:16.    audout_fifo counter low level.  if audout fifo counter lower than this level, it could generate a interrupt.
   //10.       audout address trigger interrupt mask.
   //9.        PCMOUT error interrupt mask.
   //8.        PCMIN  error interrupt mask.  
   //7.        AUDOUT_FIFO level low pulse interrupt mask.  once the audout fifo counter lower than the 22:16bits. it will generate one interrupt.
   //6.        AUDOUT_FIFO level low level interrupt mask. if the audout fifo coutner is lower than 22:16 bits, it will generate interrupt.
   //5.        fifo1 PIO mode flush request interrupt mask.
   //4.        fifo0 PIO mode flush request interrupt mask.
   //3.        fifo1 address trigger interrupt mask.
   //2.        fifo1 overflow interrupt mask.
   //1.        fifo0 address trigger interrupt mask.
   //0.        fifo0 overflow interrupt mask.
#define P_AUDIN_FIFO_INT                           (volatile unsigned long *)0xc110a148
   //10.       audout address trigger interrupt. Write 1 to clean. 
   //9.        PCMOUT error interrupt. Write 1 to clean. 
   //8.        PCMIN  error interrupt. Write 1 to clean. 
   //7.        AUDOUT_FIFO level low pulse interrupt. Write 1 to clean.
   //6.        AUDOUT_FIFO level low level interrupt. Write 1 to clean.
   //5.        fifo1 PIO mode flush request interrupt. Write 1 to clean.
   //4.        fifo0 PIO mode flush request interrupt. Write 1 to clean.
   //3.        fifo1 address trigger interrupt. Write 1 to clean.
   //2.        fifo1 overflow interrupt. Write 1 to clean.
   //1.        fifo0 address trigger interrupt. Write 1 to clean.
   //0.        fifo0 overflow interrupt. Write 1 to clean.
#define P_PCMIN_CTRL0                              (volatile unsigned long *)0xc110a180
  // bit 31.     PCMIN enable.
  // bit 30.     PMCIN soft reset. write 1 to reset PCMIN module.
  // bit 29.     PCMIN sync on clock posedge.
  // bit 18:16.  PCMIN fs skew.
                //000:   FS and data no skew.
                //001.   delay fs one cycle.
                //010.   delay fs two cycle.
                //011.   delay fs 3 cycle. 
                //111.   delay data one cycle.
                //110.   delay data 2 cycle.
                //101.   delay data 3 cycle.
                //100.   delay data 4 cycle.
   //bit 15:4.  system clock data sample count.
   //bit 3.    system clock data sample selection.  1 = use edge detection. 
               //0 = use the clock data sample counter. 
   //bit 2.    fs invert. invert the FS signal.
   //bit 1.    1 = the coming data is msb first. 0 = lsb first.
   // bit 0.   1 = the coming data is left justified. 0 = the coming data is right justified. 
#define P_PCMIN_CTRL1                              (volatile unsigned long *)0xc110a184
   //bit 29.       pcmin SRC sel.  1=  pcmin is from internal audio CODEC(I2S format).  0 = external PCM interface (from pad). 
   //bit 28.       pcmin clock sel. 1=  internal from cts_pcm_clk.   0 = external PCM interface.
   //bit 27.       1:  use negedge clock to sample the coming data. 0. use pcmin posedge clk to sample the data. 
   //bit 26:21     max slot number in one frame.  
   //bit 20:16     max bit number in one slot. 
   //bit 15:0      valid slot . each bit for one slot.  
#define P_PCMIN1_CTRL0                             (volatile unsigned long *)0xc110a188
  // bit 31.     PCMIN enable.
  // bit 30.     PMCIN soft reset. write 1 to reset PCMIN module.
  // bit 29.     PCMIN sync on clock posedge.
  // bit 18:16.  PCMIN fs skew.
                //000:   FS and data no skew.
                //001.   delay fs one cycle.
                //010.   delay fs two cycle.
                //011.   delay fs 3 cycle. 
                //111.   delay data one cycle.
                //110.   delay data 2 cycle.
                //101.   delay data 3 cycle.
                //100.   delay data 4 cycle.
   //bit 15:4.  system clock data sample count.
   //bit 3.    system clock data sample selection.  1 = use edge detection. 
               //0 = use the clock data sample counter. 
   //bit 2.    fs invert. invert the FS signal.
   //bit 1.    1 = the coming data is msb first. 0 = lsb first.
   // bit 0.   1 = the coming data is left justified. 0 = the coming data is right justified. 
#define P_PCMIN1_CTRL1                             (volatile unsigned long *)0xc110a18c
   //bit 29.       pcmin SRC sel.  1=  pcmin is from internal audio CODEC(I2S format).  0 = external PCM interface (from pad). 
   //bit 28.       pcmin clock sel. 1=  internal from cts_pcm_clk.   0 = external PCM interface.
   //bit 27.       1:  use negedge clock to sample the coming data. 0. use pcmin posedge clk to sample the data. 
   //bit 26:21     max slot number in one frame.  
   //bit 20:16     max bit number in one slot. 
   //bit 15:0      valid slot . each bit for one slot.  
#define P_PCMOUT_CTRL0                             (volatile unsigned long *)0xc110a1c0
  //bit 31      pcmout enable bit.   
  //bit 29      pcmout 1= master mode. 0 = slave mode.
  //bit 28      system clock sync at  pcmout posedge clock.
  //bit 27.     system clock sync at clock edge of pcmout clock.  0 = sync on clock counter.
  //bit 26:15.  system clock sync at counter number if sync on clock counter.
  //bit 14      pcmout is msb first.
  //bit 13.     left justified.
  //bit 12.     output data is at h24b of the input.
  //bit 11:6    in PCM slave mode. when pcmo received a FS, it will sync the slot bit counter to this number.
  //bit 5:0     in PCM slave mode. when pcmo received a FS, it will sync the frame slot counter to this number.
#define P_PCMOUT_CTRL1                             (volatile unsigned long *)0xc110a1c4
   //bit 31:30    pcmo output data byte number.  00 : 8bits. 01: 16bits. 10: 24bits. 11: 32bits.
   //bit 28.      pcmo clock slow invert.  invert the pcm output logic clock. for example, use negedge to output data.
   //bit 27.      pcmo slave parts clock invert.  invert the clock which is used to sample the fs_in when pcmo in slave mode.
   //bit 26.      invert fs phase. 
   //bit 25.      invert the fs_o for master mode.
   //bit 23:18     fs_o start postion frame slot counter number
   //bit 17:12     fs_o start postion slot bit counter number. 
   //bit 11:6      fs_o end postion frame slot counter number.
   //bit 5:0       fs_o end postion slot bit counter number.
#define P_PCMOUT_CTRL2                             (volatile unsigned long *)0xc110a1c8
   //bit 31.     pcmo mute.
   //bit 30:29.   pcmo_underrun mode.  00:  the output data will use mute constant.  01: repeat the previous data.    
   //bit 27:22    pcmo max slot number in one frame.
   //bit 21:16    pcmo max bit number in one slot.
   //bit 15:0     pcmo valid slot. each bit for one slot.
#define P_PCMOUT_CTRL3                             (volatile unsigned long *)0xc110a1cc
   //pcmo mute constant.
#define P_PCMOUT1_CTRL0                            (volatile unsigned long *)0xc110a1d0
  //bit 31      pcmout enable bit.   
  //bit 29      pcmout 1= master mode. 0 = slave mode.
  //bit 28      system clock sync at  pcmout posedge clock.
  //bit 27.     system clock sync at clock edge of pcmout clock.  0 = sync on clock counter.
  //bit 26:15.  system clock sync at counter number if sync on clock counter.
  //bit 14      pcmout is msb first.
  //bit 13.     left justified.
  //bit 12.     output data is at h24b of the input.
  //bit 11:6    in PCM slave mode. when pcmo received a FS, it will sync the slot bit counter to this number.
  //bit 5:0     in PCM slave mode. when pcmo received a FS, it will sync the frame slot counter to this number.
#define P_PCMOUT1_CTRL1                            (volatile unsigned long *)0xc110a1d4
   //bit 31:30    pcmo output data byte number.  00 : 8bits. 01: 16bits. 10: 24bits. 11: 32bits.
   //bit 28.      pcmo clock slow invert.  invert the pcm output logic clock. for example, use negedge to output data.
   //bit 27.      pcmo slave parts clock invert.  invert the clock which is used to sample the fs_in when pcmo in slave mode.
   //bit 26.      invert fs phase. 
   //bit 25.      invert the fs_o for master mode.
   //bit 23:18     fs_o start postion frame slot counter number
   //bit 17:12     fs_o start postion slot bit counter number. 
   //bit 11:6      fs_o end postion frame slot counter number.
   //bit 5:0       fs_o end postion slot bit counter number.
#define P_PCMOUT1_CTRL2                            (volatile unsigned long *)0xc110a1d8
   //bit 31.     pcmo mute.
   //bit 30:29.   pcmo_underrun mode.  00:  the output data will use mute constant.  01: repeat the previous data.    
   //bit 27:22    pcmo max slot number in one frame.
   //bit 21:16    pcmo max bit number in one slot.
   //bit 15:0     pcmo valid slot. each bit for one slot.
#define P_PCMOUT1_CTRL3                            (volatile unsigned long *)0xc110a1dc
   //pcmo mute constant.
#define P_AUDOUT_CTRL                              (volatile unsigned long *)0xc110a200
  //bit 31.  AUDOUT FIFO enable.
  //bit 30.  AUDOUT FIFO reset. write 1 to reset.
  //bit 29.  AUDOUT fifo  load DMA address. write 1 to load.
  //bit 28.  Clr audout wrap counter. write 1 to clear.
  //bit 27   clr audout rdrsp counter. write 1 to clear.
  //bit 24.  audout next bufer enable. if in pingpeng buffer mode. 
  //bit23:22. audout  level control write pointer selection.
  //bit21:15. audout DMA one time request size.
  //bit14:8.  audout buffer level.   buffer level must > one time DMA request size.
  //bit 7.    audout buffer level control enable.
  //bit6.     1 audout DMA mode. 0. audout PIO mode.(CPU use cbus to push data.)
  //bit5.     audout use circur Buffer in DDR2/3 SDRAM. 1 = circur buffer mdoe. 0 = pingpang buffer mode.
  //bit4.     audout buffer selection if in ping pang buffer mode. 
  //bit3.     audout DMA request urgent bit. 
  //bit 2:0.  audout DMA data endian control.
#define P_AUDOUT_CTRL1                             (volatile unsigned long *)0xc110a204
   //bit 11:6.   AUDOUT DMA request burst number control for pre_mmc_arb.
   //bit 5:0.    AUDOUT DMA request  ID.
#define P_AUDOUT_BUF0_STA                          (volatile unsigned long *)0xc110a208
   //buf0 start address. or circur buffer start address.
#define P_AUDOUT_BUF0_EDA                          (volatile unsigned long *)0xc110a20c
   //buf0 end address. or circur buffer end address.
#define P_AUDOUT_BUF0_WPTR                         (volatile unsigned long *)0xc110a210
   //buf0 write pointer used in level control. or circur buffer write pointer used in level control. 
#define P_AUDOUT_BUF1_STA                          (volatile unsigned long *)0xc110a214
   //buf1 start address. when in pingpang buffer mode. 
#define P_AUDOUT_BUF1_EDA                          (volatile unsigned long *)0xc110a218
   //buf1 end address. when in pingpang buffer mode. 
#define P_AUDOUT_BUF1_WPTR                         (volatile unsigned long *)0xc110a21c
   //buf1 write pointer used in level control.
#define P_AUDOUT_FIFO_RPTR                         (volatile unsigned long *)0xc110a220
   // Buffer DMA read address.
#define P_AUDOUT_INTR_PTR                          (volatile unsigned long *)0xc110a224
   // When DMA read to this address, it will generate an interrupt to CPU.
#define P_AUDOUT_FIFO_STS                          (volatile unsigned long *)0xc110a228
   //bit 6:0   AUDOUT FIFO depth counter.
#define P_AUDOUT1_CTRL                             (volatile unsigned long *)0xc110a240
#define P_AUDOUT1_CTRL1                            (volatile unsigned long *)0xc110a244
#define P_AUDOUT1_BUF0_STA                         (volatile unsigned long *)0xc110a248
#define P_AUDOUT1_BUF0_EDA                         (volatile unsigned long *)0xc110a24c
#define P_AUDOUT1_BUF0_WPTR                        (volatile unsigned long *)0xc110a250
#define P_AUDOUT1_BUF1_STA                         (volatile unsigned long *)0xc110a254
#define P_AUDOUT1_BUF1_EDA                         (volatile unsigned long *)0xc110a258
#define P_AUDOUT1_BUF1_WPTR                        (volatile unsigned long *)0xc110a25c
#define P_AUDOUT1_FIFO_RPTR                        (volatile unsigned long *)0xc110a260
#define P_AUDOUT1_INTR_PTR                         (volatile unsigned long *)0xc110a264
#define P_AUDOUT1_FIFO_STS                         (volatile unsigned long *)0xc110a268
//// Bit 31: 0 RW cntl_mute_val: Use this value during mute, if cntl_mute_mode=2.
//`define AUDIN_MUTE_VAL                 8'h35
#define P_AUDIN_HDMI_MEAS_CTRL                     (volatile unsigned long *)0xc110a280
#define P_AUDIN_HDMI_MEAS_CYCLES_M1                (volatile unsigned long *)0xc110a284
#define P_AUDIN_HDMI_MEAS_INTR_MASKN               (volatile unsigned long *)0xc110a288
#define P_AUDIN_HDMI_MEAS_INTR_STAT                (volatile unsigned long *)0xc110a28c
#define P_AUDIN_HDMI_REF_CYCLES_STAT_0             (volatile unsigned long *)0xc110a290
#define P_AUDIN_HDMI_REF_CYCLES_STAT_1             (volatile unsigned long *)0xc110a294
#define P_AUDIN_HDMIRX_AFIFO_STAT                  (volatile unsigned long *)0xc110a298
#define P_AUDIN_FIFO0_PIO_STS                      (volatile unsigned long *)0xc110a2c0
#define P_AUDIN_FIFO0_PIO_RDL                      (volatile unsigned long *)0xc110a2c4
#define P_AUDIN_FIFO0_PIO_RDH                      (volatile unsigned long *)0xc110a2c8
#define P_AUDIN_FIFO1_PIO_STS                      (volatile unsigned long *)0xc110a2cc
#define P_AUDIN_FIFO1_PIO_RDL                      (volatile unsigned long *)0xc110a2d0
#define P_AUDIN_FIFO1_PIO_RDH                      (volatile unsigned long *)0xc110a2d4
#define P_AUDIN_FIFO2_PIO_STS                      (volatile unsigned long *)0xc110a2d8
#define P_AUDIN_FIFO2_PIO_RDL                      (volatile unsigned long *)0xc110a2dc
#define P_AUDIN_FIFO2_PIO_RDH                      (volatile unsigned long *)0xc110a2e0
#define P_AUDOUT_FIFO_PIO_STS                      (volatile unsigned long *)0xc110a2e4
#define P_AUDOUT_FIFO_PIO_WRL                      (volatile unsigned long *)0xc110a2e8
   // the low 32bits of 64bits data need to push to FIFO. In PIO mode. write this address will push the {wr_h, wr_l} data to AUDOUT FIFO.
#define P_AUDOUT_FIFO_PIO_WRH                      (volatile unsigned long *)0xc110a2ec
   // the high 32bits of 64bits data need to push to AUDOUT FIFO.
#define P_AUDOUT1_FIFO_PIO_STS                     (volatile unsigned long *)0xc110a2f0
#define P_AUDOUT1_FIFO_PIO_WRL                     (volatile unsigned long *)0xc110a2f4
   // the low 32bits of 64bits data need to push to FIFO. In PIO mode. write this address will push the {wr_h, wr_l} data to AUDOUT FIFO.
#define P_AUDOUT1_FIFO_PIO_WRH                     (volatile unsigned long *)0xc110a2f8
   // the high 32bits of 64bits data need to push to AUDOUT FIFO.
#define P_AUDIN_ADDR_END                           (volatile unsigned long *)0xc110a2fc
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./register_map.h
//
//
// Reading file:  ./vcbus_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN   
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VDIN_VCBUS_BASE = 0x12
// -----------------------------------------------
//VDIN0        8'h00 - 8'h6f
//VDIN1        8'h70 - 8'hdf
#define VDIN0_OFFSET            0x00
#define VDIN1_OFFSET            0x70

#define P_VDIN_SCALE_COEF_IDX                      (volatile unsigned long *)0xd0104800
#define P_VDIN_SCALE_COEF                          (volatile unsigned long *)0xd0104804
//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
//bit 30,   mpeg_field info which can be written by software
//Bit 29,   force go_field, pulse signal
//Bit 28,   force go_line, pulse signal
//Bit 27,   enable mpeg_go_field input signal
//Bit 26:20, hold lines
//Bit 19,   delay go_field function enable
//Bit 18:12, delay go_field line number 
//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 5,   input window selection function enable
//Bit 4, enable VDIN common data input, otherwise there will be no video data input
//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: bt656 input, 3: component input, 4: tvdecoder input, 5: hdmi rx input, 6: digtial video input, 7: loopback from Viu1, 8: MIPI.
#define P_VDIN_COM_CTRL0                           (volatile unsigned long *)0xd0104808
//Bit 28:16 active_max_pix_cnt, readonly
//Bit 12:0  active_max_pix_cnt_shadow, readonly
#define P_VDIN_ACTIVE_MAX_PIX_CNT_STATUS           (volatile unsigned long *)0xd010480c
//Bit 28:16 go_line_cnt, readonly
//Bit 12:0  active_line_cnt, readonly
#define P_VDIN_LCNT_STATUS                         (volatile unsigned long *)0xd0104810
//Readonly
//Bit [12:3] lfifo_buf_cnt
//Bit 2, vdin_direct_done status
//Bit 1, vdin_nr_done status
//Bit 0, field
#define P_VDIN_COM_STATUS0                         (volatile unsigned long *)0xd0104814
//Readonly
//Bit 31, vdi4 fifo overflow
//Bit 29:24, vdi3_asfifo_cnt
//Bit 23, vdi3 fifo overflow
//Bit 21:16, vdi3_asfifo_cnt
//Bit 15, vdi2 fifo overflow
//Bit 13:8, vdi2_asfifo_cnt
//Bit 7, vdi1 fifo overflow
//Bit 5:0, vdi1_asfifo_cnt
#define P_VDIN_COM_STATUS1                         (volatile unsigned long *)0xd0104818
//Bit 28:16 go_line_cnt_shadow, readonly
//Bit 12:0  active_line_cnt_shadow, readonly
#define P_VDIN_LCNT_SHADOW_STATUS                  (volatile unsigned long *)0xd010481c
//each 8bit asfifo_ctrl is following:
//Bit 7, DE  enable 
//Bit 6, go field enable 
//Bit 5, go line enable 
//Bit 4, if true, negative active input vsync
//Bit 3, if true, negative active input hsync
//Bit 2, vsync soft reset fifo enable
//Bit 1, overflow status clear
//Bit 0 asfifo soft reset, level signal
//Bit 7:0 vdi1 asfifo_ctrl 
//Bit 23:16 vdi2 asfifo_ctrl 
#define P_VDIN_ASFIFO_CTRL0                        (volatile unsigned long *)0xd0104820
//Bit 7:0 vdi3 asfifo_ctrl 
//Bit 23:16 vdi4 asfifo_ctrl 
#define P_VDIN_ASFIFO_CTRL1                        (volatile unsigned long *)0xd0104824
//Bit 28:16 input width minus 1, after the window function
//Bit 12:0  output width minus 1
#define P_VDIN_WIDTHM1I_WIDTHM1O                   (volatile unsigned long *)0xd0104828
//Bit 20:17 prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 16:15 sp422_mode, special mode for the component1 and component2, 00: normal case, 01: 32 64 32, 10: 0 64 64 0, 11: 16 96 16
//Bit 14:8, hsc_ini_pixi_ptr, signed data, only useful when short_lineo_en is true
//Bit 7, prehsc_en
//Bit 6, hsc_en,
//Bit 5, hsc_short_lineo_en, short line output enable
//Bit 4, hsc_nearest_en
//Bit 3, hsc_phase0_always_en
//Bit 2:0, hsc_bank_length
#define P_VDIN_SC_MISC_CTRL                        (volatile unsigned long *)0xd010482c
//Bit 28:24, integer portion
//Bit 23:0, fraction portion
#define P_VDIN_HSC_PHASE_STEP                      (volatile unsigned long *)0xd0104830
//Bit 30:29    hscale rpt_p0_num
//Bit 28:24    hscale ini_rcv_num
//Bit 23:0     hscale ini_phase
#define P_VDIN_HSC_INI_CTRL                        (volatile unsigned long *)0xd0104834
//Read only
//Bit 23, vdi7 fifo overflow
//Bit 21:16, vdi7_asfifo_cnt
//Bit 15, vdi6 fifo overflow
//Bit 13:8, vdi6_asfifo_cnt
//Bit 7, vdi5 fifo overflow
//Bit 5:0, vdi5_asfifo_cnt
#define P_VDIN_COM_STATUS2                         (volatile unsigned long *)0xd0104838
//Bit 25:16 asfifo decimate control
//Bit 25, if true, decimation counter sync with first valid DE in the field, 
//otherwise the decimation counter is not sync with external signal 
//Bit 24, decimation de enable
//Bit 23:20, decimation phase, which counter value use to decimate, 
//Bit 19:16, decimation number, 0: not decimation, 1: decimation 2, 2: decimation 3 .... 
//Bit 7:0 vdi5 asfifo_ctrl 
#define P_VDIN_ASFIFO_CTRL2                        (volatile unsigned long *)0xd010483c
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing 
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing 
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define P_VDIN_MATRIX_CTRL                         (volatile unsigned long *)0xd0104840
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VDIN_MATRIX_COEF00_01                    (volatile unsigned long *)0xd0104844
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define P_VDIN_MATRIX_COEF02_10                    (volatile unsigned long *)0xd0104848
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VDIN_MATRIX_COEF11_12                    (volatile unsigned long *)0xd010484c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VDIN_MATRIX_COEF20_21                    (volatile unsigned long *)0xd0104850
#define P_VDIN_MATRIX_COEF22                       (volatile unsigned long *)0xd0104854
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VDIN_MATRIX_OFFSET0_1                    (volatile unsigned long *)0xd0104858
//Bit 10:0  offset2
#define P_VDIN_MATRIX_OFFSET2                      (volatile unsigned long *)0xd010485c
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VDIN_MATRIX_PRE_OFFSET0_1                (volatile unsigned long *)0xd0104860
//Bit 10:0  pre_offset2
#define P_VDIN_MATRIX_PRE_OFFSET2                  (volatile unsigned long *)0xd0104864
//11:0 lfifo_buf_size
#define P_VDIN_LFIFO_CTRL                          (volatile unsigned long *)0xd0104868
#define P_VDIN_COM_GCLK_CTRL                       (volatile unsigned long *)0xd010486c
//12:0 VDIN input interface width minus 1, before the window function, after the de decimation
#define P_VDIN_INTF_WIDTHM1                        (volatile unsigned long *)0xd0104870
//Bit 8, 1: discard data before line fifo, 0: normal mode
//Bit 7:0 Write chroma canvas address
#define P_VDIN_WR_CTRL2                            (volatile unsigned long *)0xd010487c
//Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2. 0: Output every even pixels' CbCr;
//                                                            1: Output every odd pixels' CbCr;
//                                                            2: Output an average value per even&odd pair of pixels;
//                                                            3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
//Bit 29 no_clk_gate: disable vid_wr_mif clock gating function.
//Bit 28 clear write response counter in the vdin write memory interface 
//Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line end indication in the vdin write memory interface
//Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 23 vdin frame reset enble, if true, it will provide frame reset during go_field(vsync) to the modules after that 
//Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will reset during go_field (vsync)
//Bit 21 vdin direct write done status clear bit 
//Bit 20 vdin NR write done status clear bit 
//Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12); 1: Output CrCb (NV21).
//Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even lines' CbCr;
//                                                       1: Output every odd lines' CbCr;
//                                                       2: Reserved;
//                                                       3: Output all CbCr.
//Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4 to luma canvas,
//                             2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit 31:30, 17:16, and bit 18.
//Bit 11 vdin write canvas double buffer enable, means the canvas address will be latched by vsync before using 
//Bit 9 vdin write request urgent
//Bit 8 vdin write request enable
//Bit 7:0 Write luma canvas address
#define P_VDIN_WR_CTRL                             (volatile unsigned long *)0xd0104880
//Bit 29, if true, horizontal reverse
//Bit 28:16 start
//Bit 12:0  end
#define P_VDIN_WR_H_START_END                      (volatile unsigned long *)0xd0104884
//Bit 29, if true, vertical reverse
//Bit 28:16 start
//Bit 12:0  end
#define P_VDIN_WR_V_START_END                      (volatile unsigned long *)0xd0104888
//Bit 24:20, integer portion
//Bit 19:0, fraction portion
#define P_VDIN_VSC_PHASE_STEP                      (volatile unsigned long *)0xd010488c
//Bit 23, vsc_en, vertical scaler enable
//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
//Bit 20:16 ini skip_line_num
//Bit 15:0 vscaler ini_phase 
#define P_VDIN_VSC_INI_CTRL                        (volatile unsigned long *)0xd0104890
//Bit 12:0, scaler input height minus 1
#define P_VDIN_SCIN_HEIGHTM1                       (volatile unsigned long *)0xd0104894
//Bit 23:16, dummy component 0
//Bit 15:8, dummy component 1
//Bit 7:0, dummy component 2
#define P_VDIN_DUMMY_DATA                          (volatile unsigned long *)0xd0104898
//Read only 
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VDIN_MATRIX_PROBE_COLOR                  (volatile unsigned long *)0xd01048a0
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VDIN_MATRIX_HL_COLOR                     (volatile unsigned long *)0xd01048a4
//28:16 probe x, postion
//12:0  probe y, position  
#define P_VDIN_MATRIX_PROBE_POS                    (volatile unsigned long *)0xd01048a8
#define P_VDIN_CHROMA_ADDR_PORT                    (volatile unsigned long *)0xd01048ac
#define P_VDIN_CHROMA_DATA_PORT                    (volatile unsigned long *)0xd01048b0
//
#define P_VDIN_CM_BRI_CON_CTRL                     (volatile unsigned long *)0xd01048b4
//Bit 17  clk_cyc_cnt_clr, if true, clear this register
//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt 
//Bit 15:0   line width using vpu clk
#define P_VDIN_GO_LINE_CTRL                        (volatile unsigned long *)0xd01048bc
//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din 
//Bit 8     ldim_stts_en
//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define P_VDIN_HIST_CTRL                           (volatile unsigned long *)0xd01048c0
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define P_VDIN_HIST_H_START_END                    (volatile unsigned long *)0xd01048c4
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define P_VDIN_HIST_V_START_END                    (volatile unsigned long *)0xd01048c8
//Bit 15:8  hist_max    maximum value 
//Bit 7:0   hist_min    minimum value 
//read only
#define P_VDIN_HIST_MAX_MIN                        (volatile unsigned long *)0xd01048cc
//Bit 31:0  hist_spl_rd
//counts for the total luma value 
//read only
#define P_VDIN_HIST_SPL_VAL                        (volatile unsigned long *)0xd01048d0
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define P_VDIN_HIST_SPL_PIX_CNT                    (volatile unsigned long *)0xd01048d4
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value 
//read only
#define P_VDIN_HIST_CHROMA_SUM                     (volatile unsigned long *)0xd01048d8
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
//VDIN_DNLP_HIST00[31:16] counts for the second bin
//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define P_VDIN_DNLP_HIST00                         (volatile unsigned long *)0xd01048dc
#define P_VDIN_DNLP_HIST01                         (volatile unsigned long *)0xd01048e0
#define P_VDIN_DNLP_HIST02                         (volatile unsigned long *)0xd01048e4
#define P_VDIN_DNLP_HIST03                         (volatile unsigned long *)0xd01048e8
#define P_VDIN_DNLP_HIST04                         (volatile unsigned long *)0xd01048ec
#define P_VDIN_DNLP_HIST05                         (volatile unsigned long *)0xd01048f0
#define P_VDIN_DNLP_HIST06                         (volatile unsigned long *)0xd01048f4
#define P_VDIN_DNLP_HIST07                         (volatile unsigned long *)0xd01048f8
#define P_VDIN_DNLP_HIST08                         (volatile unsigned long *)0xd01048fc
#define P_VDIN_DNLP_HIST09                         (volatile unsigned long *)0xd0104900
#define P_VDIN_DNLP_HIST10                         (volatile unsigned long *)0xd0104904
#define P_VDIN_DNLP_HIST11                         (volatile unsigned long *)0xd0104908
#define P_VDIN_DNLP_HIST12                         (volatile unsigned long *)0xd010490c
#define P_VDIN_DNLP_HIST13                         (volatile unsigned long *)0xd0104910
#define P_VDIN_DNLP_HIST14                         (volatile unsigned long *)0xd0104914
#define P_VDIN_DNLP_HIST15                         (volatile unsigned long *)0xd0104918
#define P_VDIN_DNLP_HIST16                         (volatile unsigned long *)0xd010491c
#define P_VDIN_DNLP_HIST17                         (volatile unsigned long *)0xd0104920
#define P_VDIN_DNLP_HIST18                         (volatile unsigned long *)0xd0104924
#define P_VDIN_DNLP_HIST19                         (volatile unsigned long *)0xd0104928
#define P_VDIN_DNLP_HIST20                         (volatile unsigned long *)0xd010492c
#define P_VDIN_DNLP_HIST21                         (volatile unsigned long *)0xd0104930
#define P_VDIN_DNLP_HIST22                         (volatile unsigned long *)0xd0104934
#define P_VDIN_DNLP_HIST23                         (volatile unsigned long *)0xd0104938
#define P_VDIN_DNLP_HIST24                         (volatile unsigned long *)0xd010493c
#define P_VDIN_DNLP_HIST25                         (volatile unsigned long *)0xd0104940
#define P_VDIN_DNLP_HIST26                         (volatile unsigned long *)0xd0104944
#define P_VDIN_DNLP_HIST27                         (volatile unsigned long *)0xd0104948
#define P_VDIN_DNLP_HIST28                         (volatile unsigned long *)0xd010494c
#define P_VDIN_DNLP_HIST29                         (volatile unsigned long *)0xd0104950
#define P_VDIN_DNLP_HIST30                         (volatile unsigned long *)0xd0104954
#define P_VDIN_DNLP_HIST31                         (volatile unsigned long *)0xd0104958
//Bit 31, local dimming statistic enable
//Bit 28, eol enable
//Bit 27:25, vertical line overlap number for max finding
//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION 
//Bit 6:0, region read index
#define P_VDIN_LDIM_STTS_HIST_REGION_IDX           (volatile unsigned long *)0xd010495c
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
#define P_VDIN_LDIM_STTS_HIST_SET_REGION           (volatile unsigned long *)0xd0104960
//REGION STATISTIC DATA READ OUT PORT, bit 29:20 max_comp2, bit 19:10 max_comp1, bit 9:0 max_comp0
#define P_VDIN_LDIM_STTS_HIST_READ_REGION          (volatile unsigned long *)0xd0104964
//Bit 18, reset bit, high active
//Bit 17, if true, widen hs/vs pulse
//Bit 16  vsync total counter always accumulating enable
//Bit 14:12, select hs/vs of video input channel to measure, 0: no selection, 1: vdi1, 2: vid2, 3: vid3, 4:vid4, 5:vdi5, 6:vid6, 7:vdi7, 8: vdi8
//Bit 11:4, vsync_span, define how many vsync span need to measure 
//Bit 2:0  meas_hs_index, index to select which HS counter/range
#define P_VDIN_MEAS_CTRL0                          (volatile unsigned long *)0xd0104968
//Read only
//19:16     meas_ind_total_count_n, every number of sync_span vsyncs, this count add 1
//15:0      high bit portion of vsync total counter
#define P_VDIN_MEAS_VS_COUNT_HI                    (volatile unsigned long *)0xd010496c
//Read only
//31:0, low bit portion of vsync total counter 
#define P_VDIN_MEAS_VS_COUNT_LO                    (volatile unsigned long *)0xd0104970
//according to the meas_hs_index in register VDIN_MEAS_CTRL0
//meas_hs_index == 0, first hs range
//meas_hs_index == 1, second hs range
//meas_hs_index == 2, third hs range
//meas_hs_index == 3, fourth hs range 
//bit 28:16 count_start
//bit 12:0 count_end
#define P_VDIN_MEAS_HS_RANGE                       (volatile unsigned long *)0xd0104974
//Read only
//according to the meas_hs_index in register VDIN_MEAS_CTRL0,
//meas_hs_index == 0, first range hs counter,
//meas_hs_index == 1, second range hs coutner
//meas_hs_index == 2, third range hs coutner
//meas_hs_index == 3, fourth range hs coutner
//23:0
#define P_VDIN_MEAS_HS_COUNT                       (volatile unsigned long *)0xd0104978
//Bit 8      white_enable
//Bit 7:0    blkbar_white_level
#define P_VDIN_BLKBAR_CTRL1                        (volatile unsigned long *)0xd010497c
// Bit 31:24 blkbar_black_level    threshold to judge a black point
// Bit 23:21 Reserved
// Bit 20:8  blkbar_hwidth         left and right region width
// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
// Bit 3     blkbar_det_en       
// Bit 2:1   blkbar_din_sel        
// bit blkbar_det_top_en
#define P_VDIN_BLKBAR_CTRL0                        (volatile unsigned long *)0xd0104980
// Bit 31:29 Reserved
// Bit 28:16 blkbar_hstart.        Left region start
// Bit 15:13 Reserved
// Bit 12:0  blkbar_hend.          Right region end
#define P_VDIN_BLKBAR_H_START_END                  (volatile unsigned long *)0xd0104984
// Bit 31:29 Reserved
// Bit 28:16 blkbar_vstart        
// Bit 15:13 Reserved
// Bit 12:0  blkbar_vend
#define P_VDIN_BLKBAR_V_START_END                  (volatile unsigned long *)0xd0104988
// Bit 31:20 Reserved
// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black  
#define P_VDIN_BLKBAR_CNT_THRESHOLD                (volatile unsigned long *)0xd010498c
// Bit 31:29 Reserved
// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
// Bit 15:13 Reserved
// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
#define P_VDIN_BLKBAR_ROW_TH1_TH2                  (volatile unsigned long *)0xd0104990
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
#define P_VDIN_BLKBAR_IND_LEFT_START_END           (volatile unsigned long *)0xd0104994
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
#define P_VDIN_BLKBAR_IND_RIGHT_START_END          (volatile unsigned long *)0xd0104998
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
#define P_VDIN_BLKBAR_IND_LEFT1_CNT                (volatile unsigned long *)0xd010499c
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. right part of the left region
#define P_VDIN_BLKBAR_IND_LEFT2_CNT                (volatile unsigned long *)0xd01049a0
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
#define P_VDIN_BLKBAR_IND_RIGHT1_CNT               (volatile unsigned long *)0xd01049a4
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
#define P_VDIN_BLKBAR_IND_RIGHT2_CNT               (volatile unsigned long *)0xd01049a8
//Readonly
// Bit 31:30 Resersed
// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
// Bit 28:16 blkbar_top_pos.            Top black bar position
// Bit 15:13 Reserved.
// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
#define P_VDIN_BLKBAR_STATUS0                      (volatile unsigned long *)0xd01049ac
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_left_pos.       Left black bar posiont
// Bit 15:13 Reserved
// Bit 12:0  blkbar_right_pos.      Right black bar position
#define P_VDIN_BLKBAR_STATUS1                      (volatile unsigned long *)0xd01049b0
//Bit 28:16 input window H start
//Bit 12:0  input window H end
#define P_VDIN_WIN_H_START_END                     (volatile unsigned long *)0xd01049b4
//Bit 28:16 input window H start
//Bit 12:0  input window V start
#define P_VDIN_WIN_V_START_END                     (volatile unsigned long *)0xd01049b8
//Bit 23:16 vdi8 asfifo_ctrl 
//Bit 15:8 vdi7 asfifo_ctrl 
//Bit 7:0 vdi6 asfifo_ctrl 
#define P_VDIN_ASFIFO_CTRL3                        (volatile unsigned long *)0xd01049bc

//VDIN0        8'h00 - 8'h7f
#define VDIN0_SCALE_COEF_IDX                    ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
#define VDIN0_SCALE_COEF                        ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF                   )
#define VDIN0_COM_CTRL0                         ((VDIN0_OFFSET << 2) + VDIN_COM_CTRL0                    )
#define VDIN0_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN0_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN0_LCNT_STATUS                       ((VDIN0_OFFSET << 2) + VDIN_LCNT_STATUS                  )
#define VDIN0_COM_STATUS0                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS0                  )
#define VDIN0_COM_STATUS1                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS1                  )
#define VDIN0_LCNT_SHADOW_STATUS                ((VDIN0_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
#define VDIN0_ASFIFO_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
#define VDIN0_ASFIFO_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
#define VDIN0_WIDTHM1I_WIDTHM1O                 ((VDIN0_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN0_SC_MISC_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
#define VDIN0_HSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
#define VDIN0_HSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
#define VDIN0_COM_STATUS2                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS2                  )
#define VDIN0_ASFIFO_CTRL2                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
#define VDIN0_MATRIX_CTRL                       ((VDIN0_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
#define VDIN0_MATRIX_COEF00_01                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
#define VDIN0_MATRIX_COEF02_10                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
#define VDIN0_MATRIX_COEF11_12                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
#define VDIN0_MATRIX_COEF20_21                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
#define VDIN0_MATRIX_COEF22                     ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF22                )
#define VDIN0_MATRIX_OFFSET0_1                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
#define VDIN0_MATRIX_OFFSET2                    ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
#define VDIN0_MATRIX_PRE_OFFSET0_1              ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN0_MATRIX_PRE_OFFSET2                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN0_LFIFO_CTRL                        ((VDIN0_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
#define VDIN0_COM_GCLK_CTRL                     ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
#define VDIN0_INTF_WIDTHM1                      ((VDIN0_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
#define VDIN0_WR_CTRL2                          ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL2                     )
#define VDIN0_WR_CTRL                           ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL                      )
#define VDIN0_WR_H_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_H_START_END               )
#define VDIN0_WR_V_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_V_START_END               )
#define VDIN0_VSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
#define VDIN0_VSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
#define VDIN0_SCIN_HEIGHTM1                     ((VDIN0_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
#define VDIN0_DUMMY_DATA                        ((VDIN0_OFFSET << 2) + VDIN_DUMMY_DATA                   )
#define VDIN0_MATRIX_PROBE_COLOR                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
#define VDIN0_MATRIX_HL_COLOR                   ((VDIN0_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
#define VDIN0_MATRIX_PROBE_POS                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
#define VDIN0_CHROMA_ADDR_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
#define VDIN0_CHROMA_DATA_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
#define VDIN0_CM_BRI_CON_CTRL                   ((VDIN0_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
#define VDIN0_HIST_CTRL                         ((VDIN0_OFFSET << 2) + VDIN_HIST_CTRL                    )
#define VDIN0_HIST_H_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_H_START_END             )
#define VDIN0_HIST_V_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_V_START_END             )
#define VDIN0_HIST_MAX_MIN                      ((VDIN0_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
#define VDIN0_HIST_SPL_VAL                      ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
#define VDIN0_HIST_SPL_PIX_CNT                  ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
#define VDIN0_HIST_CHROMA_SUM                   ((VDIN0_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
#define VDIN0_DNLP_HIST00                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST00                  )
#define VDIN0_DNLP_HIST01                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST01                  )
#define VDIN0_DNLP_HIST02                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST02                  )
#define VDIN0_DNLP_HIST03                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST03                  )
#define VDIN0_DNLP_HIST04                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST04                  )
#define VDIN0_DNLP_HIST05                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST05                  )
#define VDIN0_DNLP_HIST06                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST06                  )
#define VDIN0_DNLP_HIST07                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST07                  )
#define VDIN0_DNLP_HIST08                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST08                  )
#define VDIN0_DNLP_HIST09                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST09                  )
#define VDIN0_DNLP_HIST10                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST10                  )
#define VDIN0_DNLP_HIST11                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST11                  )
#define VDIN0_DNLP_HIST12                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST12                  )
#define VDIN0_DNLP_HIST13                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST13                  )
#define VDIN0_DNLP_HIST14                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST14                  )
#define VDIN0_DNLP_HIST15                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST15                  )
#define VDIN0_DNLP_HIST16                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST16                  )
#define VDIN0_DNLP_HIST17                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST17                  )
#define VDIN0_DNLP_HIST18                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST18                  )
#define VDIN0_DNLP_HIST19                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST19                  )
#define VDIN0_DNLP_HIST20                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST20                  )
#define VDIN0_DNLP_HIST21                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST21                  )
#define VDIN0_DNLP_HIST22                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST22                  )
#define VDIN0_DNLP_HIST23                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST23                  )
#define VDIN0_DNLP_HIST24                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST24                  )
#define VDIN0_DNLP_HIST25                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST25                  )
#define VDIN0_DNLP_HIST26                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST26                  )
#define VDIN0_DNLP_HIST27                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST27                  )
#define VDIN0_DNLP_HIST28                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST28                  )
#define VDIN0_DNLP_HIST29                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST29                  )
#define VDIN0_DNLP_HIST30                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST30                  )
#define VDIN0_DNLP_HIST31                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST31                  )
#define VDIN0_LDIM_STTS_HIST_REGION_IDX         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
#define VDIN0_LDIM_STTS_HIST_SET_REGION         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
#define VDIN0_LDIM_STTS_HIST_READ_REGION        ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
#define VDIN0_MEAS_CTRL0                        ((VDIN0_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
#define VDIN0_MEAS_VS_COUNT_HI                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
#define VDIN0_MEAS_VS_COUNT_LO                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
#define VDIN0_MEAS_HS_RANGE                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
#define VDIN0_MEAS_HS_COUNT                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
#define VDIN0_BLKBAR_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
#define VDIN0_BLKBAR_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
#define VDIN0_BLKBAR_H_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
#define VDIN0_BLKBAR_V_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
#define VDIN0_BLKBAR_CNT_THRESHOLD              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN0_BLKBAR_ROW_TH1_TH2                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN0_BLKBAR_IND_LEFT_START_END         ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN0_BLKBAR_IND_RIGHT_START_END        ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN0_BLKBAR_IND_LEFT1_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN0_BLKBAR_IND_LEFT2_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN0_BLKBAR_IND_RIGHT1_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN0_BLKBAR_IND_RIGHT2_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN0_BLKBAR_STATUS0                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
#define VDIN0_BLKBAR_STATUS1                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
#define VDIN0_WIN_H_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_H_START_END              )
#define VDIN0_WIN_V_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_V_START_END              )
#define VDIN0_ASFIFO_CTRL3                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )

//VDIN1        8'h70 - 8'hdf
#define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
#define VDIN1_SCALE_COEF                        ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF                   )
#define VDIN1_COM_CTRL0                         ((VDIN1_OFFSET << 2) + VDIN_COM_CTRL0                    )
#define VDIN1_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN1_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN1_LCNT_STATUS                       ((VDIN1_OFFSET << 2) + VDIN_LCNT_STATUS                  )
#define VDIN1_COM_STATUS0                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS0                  )
#define VDIN1_COM_STATUS1                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS1                  )
#define VDIN1_LCNT_SHADOW_STATUS                ((VDIN1_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
#define VDIN1_ASFIFO_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
#define VDIN1_ASFIFO_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
#define VDIN1_WIDTHM1I_WIDTHM1O                 ((VDIN1_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN1_SC_MISC_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
#define VDIN1_HSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
#define VDIN1_HSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
#define VDIN1_COM_STATUS2                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS2                  )
#define VDIN1_ASFIFO_CTRL2                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
#define VDIN1_MATRIX_CTRL                       ((VDIN1_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
#define VDIN1_MATRIX_COEF00_01                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
#define VDIN1_MATRIX_COEF02_10                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
#define VDIN1_MATRIX_COEF11_12                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
#define VDIN1_MATRIX_COEF20_21                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
#define VDIN1_MATRIX_COEF22                     ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF22                )
#define VDIN1_MATRIX_OFFSET0_1                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
#define VDIN1_MATRIX_OFFSET2                    ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
#define VDIN1_MATRIX_PRE_OFFSET0_1              ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN1_MATRIX_PRE_OFFSET2                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN1_LFIFO_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
#define VDIN1_COM_GCLK_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
#define VDIN1_INTF_WIDTHM1                      ((VDIN1_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
#define VDIN1_WR_CTRL2                          ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL2                     )
#define VDIN1_WR_CTRL                           ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL                      )
#define VDIN1_WR_H_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_H_START_END               )
#define VDIN1_WR_V_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_V_START_END               )
#define VDIN1_VSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
#define VDIN1_VSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
#define VDIN1_SCIN_HEIGHTM1                     ((VDIN1_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
#define VDIN1_DUMMY_DATA                        ((VDIN1_OFFSET << 2) + VDIN_DUMMY_DATA                   )
#define VDIN1_MATRIX_PROBE_COLOR                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
#define VDIN1_MATRIX_HL_COLOR                   ((VDIN1_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
#define VDIN1_MATRIX_PROBE_POS                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
#define VDIN1_CHROMA_ADDR_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
#define VDIN1_CHROMA_DATA_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
#define VDIN1_CM_BRI_CON_CTRL                   ((VDIN1_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
#define VDIN1_HIST_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HIST_CTRL                    )
#define VDIN1_HIST_H_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_H_START_END             )
#define VDIN1_HIST_V_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_V_START_END             )
#define VDIN1_HIST_MAX_MIN                      ((VDIN1_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
#define VDIN1_HIST_SPL_VAL                      ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
#define VDIN1_HIST_SPL_PIX_CNT                  ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
#define VDIN1_HIST_CHROMA_SUM                   ((VDIN1_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
#define VDIN1_DNLP_HIST00                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST00                  )
#define VDIN1_DNLP_HIST01                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST01                  )
#define VDIN1_DNLP_HIST02                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST02                  )
#define VDIN1_DNLP_HIST03                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST03                  )
#define VDIN1_DNLP_HIST04                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST04                  )
#define VDIN1_DNLP_HIST05                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST05                  )
#define VDIN1_DNLP_HIST06                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST06                  )
#define VDIN1_DNLP_HIST07                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST07                  )
#define VDIN1_DNLP_HIST08                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST08                  )
#define VDIN1_DNLP_HIST09                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST09                  )
#define VDIN1_DNLP_HIST10                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST10                  )
#define VDIN1_DNLP_HIST11                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST11                  )
#define VDIN1_DNLP_HIST12                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST12                  )
#define VDIN1_DNLP_HIST13                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST13                  )
#define VDIN1_DNLP_HIST14                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST14                  )
#define VDIN1_DNLP_HIST15                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST15                  )
#define VDIN1_DNLP_HIST16                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST16                  )
#define VDIN1_DNLP_HIST17                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST17                  )
#define VDIN1_DNLP_HIST18                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST18                  )
#define VDIN1_DNLP_HIST19                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST19                  )
#define VDIN1_DNLP_HIST20                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST20                  )
#define VDIN1_DNLP_HIST21                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST21                  )
#define VDIN1_DNLP_HIST22                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST22                  )
#define VDIN1_DNLP_HIST23                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST23                  )
#define VDIN1_DNLP_HIST24                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST24                  )
#define VDIN1_DNLP_HIST25                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST25                  )
#define VDIN1_DNLP_HIST26                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST26                  )
#define VDIN1_DNLP_HIST27                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST27                  )
#define VDIN1_DNLP_HIST28                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST28                  )
#define VDIN1_DNLP_HIST29                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST29                  )
#define VDIN1_DNLP_HIST30                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST30                  )
#define VDIN1_DNLP_HIST31                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST31                  )
#define VDIN1_LDIM_STTS_HIST_REGION_IDX         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
#define VDIN1_LDIM_STTS_HIST_SET_REGION         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
#define VDIN1_LDIM_STTS_HIST_READ_REGION        ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
#define VDIN1_MEAS_CTRL0                        ((VDIN1_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
#define VDIN1_MEAS_VS_COUNT_HI                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
#define VDIN1_MEAS_VS_COUNT_LO                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
#define VDIN1_MEAS_HS_RANGE                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
#define VDIN1_MEAS_HS_COUNT                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
#define VDIN1_BLKBAR_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
#define VDIN1_BLKBAR_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
#define VDIN1_BLKBAR_H_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
#define VDIN1_BLKBAR_V_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
#define VDIN1_BLKBAR_CNT_THRESHOLD              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN1_BLKBAR_ROW_TH1_TH2                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN1_BLKBAR_IND_LEFT_START_END         ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN1_BLKBAR_IND_RIGHT_START_END        ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN1_BLKBAR_IND_LEFT1_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN1_BLKBAR_IND_LEFT2_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN1_BLKBAR_IND_RIGHT1_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN1_BLKBAR_IND_RIGHT2_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN1_BLKBAR_STATUS0                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
#define VDIN1_BLKBAR_STATUS1                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
#define VDIN1_WIN_H_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_H_START_END              )
#define VDIN1_WIN_V_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_V_START_END              )
#define VDIN1_ASFIFO_CTRL3                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )

//========================================================================
//	registers for video postprocessing (12'h800 - 12'h87f)
//========================================================================
//
// Reading file:  vpp_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPP_VCBUS_BASE = 0x1d
// -----------------------------------------------
//===========================================================================
// Video postprocesing Registers 
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define P_VPP_DUMMY_DATA                           (volatile unsigned long *)0xd0107400
//input line length used in VPP
#define P_VPP_LINE_IN_LENGTH                       (volatile unsigned long *)0xd0107404
//input Picture height used in VPP
#define P_VPP_PIC_IN_HEIGHT                        (volatile unsigned long *)0xd0107408
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered 
//Bit 6:0 	coef index
#define P_VPP_SCALE_COEF_IDX                       (volatile unsigned long *)0xd010740c
//coefficients for vertical filter and horizontal filter
#define P_VPP_SCALE_COEF                           (volatile unsigned long *)0xd0107410
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		. 
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region	
//		.
//  ---------------------------  
//  ---------------------------  <------ region1_startp 
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_VPP_VSC_REGION12_STARTP                  (volatile unsigned long *)0xd0107414
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_VPP_VSC_REGION34_STARTP                  (volatile unsigned long *)0xd0107418
#define P_VPP_VSC_REGION4_ENDP                     (volatile unsigned long *)0xd010741c
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0	fraction part
#define P_VPP_VSC_START_PHASE_STEP                 (volatile unsigned long *)0xd0107420
//vertical scaler region0 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION0_PHASE_SLOPE              (volatile unsigned long *)0xd0107424
//vertical scaler region1 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION1_PHASE_SLOPE              (volatile unsigned long *)0xd0107428
//vertical scaler region3 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION3_PHASE_SLOPE              (volatile unsigned long *)0xd010742c
//vertical scaler region4 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION4_PHASE_SLOPE              (volatile unsigned long *)0xd0107430
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X, 
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field   
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field   
#define P_VPP_VSC_PHASE_CTRL                       (volatile unsigned long *)0xd0107434
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define P_VPP_VSC_INI_PHASE                        (volatile unsigned long *)0xd0107438
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_VPP_HSC_REGION12_STARTP                  (volatile unsigned long *)0xd0107440
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_VPP_HSC_REGION34_STARTP                  (volatile unsigned long *)0xd0107444
#define P_VPP_HSC_REGION4_ENDP                     (volatile unsigned long *)0xd0107448
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0	fraction part
#define P_VPP_HSC_START_PHASE_STEP                 (volatile unsigned long *)0xd010744c
//horizontal scaler region0 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION0_PHASE_SLOPE              (volatile unsigned long *)0xd0107450
//horizontal scaler region1 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION1_PHASE_SLOPE              (volatile unsigned long *)0xd0107454
//horizontal scaler region3 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION3_PHASE_SLOPE              (volatile unsigned long *)0xd0107458
//horizontal scaler region4 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION4_PHASE_SLOPE              (volatile unsigned long *)0xd010745c
//Bit 22:21   horizontal scaler initial repeat pixel0 number0
//Bit 19:16   horizontal scaler initial receiving number0   
//Bit 15:0    horizontal scaler top field initial phase0
#define P_VPP_HSC_PHASE_CTRL                       (volatile unsigned long *)0xd0107460
// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
// Bit 2:0 vertical scaler bank length
#define P_VPP_SC_MISC                              (volatile unsigned long *)0xd0107464
// preblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_PREBLEND_VD1_H_START_END             (volatile unsigned long *)0xd0107468
// preblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_PREBLEND_VD1_V_START_END             (volatile unsigned long *)0xd010746c
// postblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_POSTBLEND_VD1_H_START_END            (volatile unsigned long *)0xd0107470
// postblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_POSTBLEND_VD1_V_START_END            (volatile unsigned long *)0xd0107474
// preblend/postblend video2 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_BLEND_VD2_H_START_END                (volatile unsigned long *)0xd0107478
// preblend/postblend video2 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_BLEND_VD2_V_START_END                (volatile unsigned long *)0xd010747c
// preblend horizontal size
#define P_VPP_PREBLEND_H_SIZE                      (volatile unsigned long *)0xd0107480
// postblend horizontal size
#define P_VPP_POSTBLEND_H_SIZE                     (volatile unsigned long *)0xd0107484
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 15:8     preblend hold lines
//Bit 7:0      postblend hold lines
#define P_VPP_HOLD_LINES                           (volatile unsigned long *)0xd0107488
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define P_VPP_BLEND_ONECOLOR_CTRL                  (volatile unsigned long *)0xd010748c
//Read Only, VPP preblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define P_VPP_PREBLEND_CURRENT_XY                  (volatile unsigned long *)0xd0107490
//Read Only, VPP postblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define P_VPP_POSTBLEND_CURRENT_XY                 (volatile unsigned long *)0xd0107494
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// Bit 28   color management enable
// Bit 27,  if true, vd2 use viu2 output as the input, otherwise use normal vd2 from memory 
// Bit 26:18, vd2 alpha
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, vd2 enable for preblend
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, vd2 enable for postblend
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultipiled 
// Bit 8,  if true, osd2 is alpha premultipiled 
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,  
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//			 the aync fifo will be reseted.
// Bit 1,	  
// Bit 0	if true, the output result of VPP is saturated
#define P_VPP_MISC                                 (volatile unsigned long *)0xd0107498
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define P_VPP_OFIFO_SIZE                           (volatile unsigned long *)0xd010749c
//Read only
//Bit 28:17 current scale out fifo counter
//Bit 16:12 current afifo counter
//Bit 11:0 current ofifo counter
#define P_VPP_FIFO_STATUS                          (volatile unsigned long *)0xd01074a0
// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable 
// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable 
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
#define P_VPP_SMOKE_CTRL                           (volatile unsigned long *)0xd01074a4
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 chanel
//smoke2 for OSD2 chanel
//smoke3 for VD2 chanel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define P_VPP_SMOKE1_VAL                           (volatile unsigned long *)0xd01074a8
#define P_VPP_SMOKE2_VAL                           (volatile unsigned long *)0xd01074ac
#define P_VPP_SMOKE3_VAL                           (volatile unsigned long *)0xd01074b0
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE1_H_START_END                   (volatile unsigned long *)0xd01074b4
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE1_V_START_END                   (volatile unsigned long *)0xd01074b8
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE2_H_START_END                   (volatile unsigned long *)0xd01074bc
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE2_V_START_END                   (volatile unsigned long *)0xd01074c0
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE3_H_START_END                   (volatile unsigned long *)0xd01074c4
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE3_V_START_END                   (volatile unsigned long *)0xd01074c8
//Bit 27:16 scale out fifo line length minus 1
//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
#define P_VPP_SCO_FIFO_CTRL                        (volatile unsigned long *)0xd01074cc
//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 23 horizontal scaler double pixel mode
//Bit 22:21   horizontal scaler initial repeat pixel0 number1
//Bit 19:16   horizontal scaler initial receiving number1   
//Bit 15:0    horizontal scaler top field initial phase1
#define P_VPP_HSC_PHASE_CTRL1                      (volatile unsigned long *)0xd01074d0
//for 3D quincunx sub-sampling
//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
//22:20  prehsc pattern start
//18:16 prehsc pattern end
//15:8 hsc pattern, each patten 1 bit, from lsb -> msb
//6:4  hsc pattern start
//2:0  hsc pattern end
#define P_VPP_HSC_INI_PAT_CTRL                     (volatile unsigned long *)0xd01074d4
//Bit 3			minus black level enable for vadj2
//Bit 2			Video adjustment enable for vadj2
//Bit 1			minus black level enable for vadj1
//Bit 0			Video adjustment enable for vadj1
#define P_VPP_VADJ_CTRL                            (volatile unsigned long *)0xd0107500
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
#define P_VPP_VADJ1_Y                              (volatile unsigned long *)0xd0107504
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define P_VPP_VADJ1_MA_MB                          (volatile unsigned long *)0xd0107508
#define P_VPP_VADJ1_MC_MD                          (volatile unsigned long *)0xd010750c
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
#define P_VPP_VADJ2_Y                              (volatile unsigned long *)0xd0107510
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define P_VPP_VADJ2_MA_MB                          (volatile unsigned long *)0xd0107514
#define P_VPP_VADJ2_MC_MD                          (volatile unsigned long *)0xd0107518
//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur  
//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur  
//Bit 0 horizontal sharpness enable
#define P_VPP_HSHARP_CTRL                          (volatile unsigned long *)0xd0107540
//{1'b0,threhsold} < diff
//Bit 26:16  luma threshold0
//Bit 10:0   luma threshold1    
#define P_VPP_HSHARP_LUMA_THRESH01                 (volatile unsigned long *)0xd0107544
//
//Bit 26:16  luma threshold2
//Bit 10:0   luma threshold3    
#define P_VPP_HSHARP_LUMA_THRESH23                 (volatile unsigned long *)0xd0107548
//Bit 26:16  chroma threshold0
//Bit 10:0   chroma threshold1    
#define P_VPP_HSHARP_CHROMA_THRESH01               (volatile unsigned long *)0xd010754c
//Bit 26:16  chroma threshold2
//Bit 10:0   chroma threshold3    
#define P_VPP_HSHARP_CHROMA_THRESH23               (volatile unsigned long *)0xd0107550
//Bit 23:16 luma gain2
//Bit 15:8  luma gain1
//Bit 7:0   luma gain0
#define P_VPP_HSHARP_LUMA_GAIN                     (volatile unsigned long *)0xd0107554
//
//Bit 23:16 chroma gain2
//Bit 15:8  chroma gain1
//Bit 7:0   chroma gain0
#define P_VPP_HSHARP_CHROMA_GAIN                   (volatile unsigned long *)0xd0107558
//Read only 
//Bit 31, if it is true, it means this probe is valid in the last field/frame
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VPP_MATRIX_PROBE_COLOR                   (volatile unsigned long *)0xd0107570
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VPP_MATRIX_HL_COLOR                      (volatile unsigned long *)0xd0107574
//28:16 probe x, postion
//12:0  probe y, position  
#define P_VPP_MATRIX_PROBE_POS                     (volatile unsigned long *)0xd0107578
//Bit 16,  highlight_en
//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix, 010: select vd2 matrix
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    vd2 conversion matrix enable
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define P_VPP_MATRIX_CTRL                          (volatile unsigned long *)0xd010757c
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VPP_MATRIX_COEF00_01                     (volatile unsigned long *)0xd0107580
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define P_VPP_MATRIX_COEF02_10                     (volatile unsigned long *)0xd0107584
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VPP_MATRIX_COEF11_12                     (volatile unsigned long *)0xd0107588
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VPP_MATRIX_COEF20_21                     (volatile unsigned long *)0xd010758c
#define P_VPP_MATRIX_COEF22                        (volatile unsigned long *)0xd0107590
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VPP_MATRIX_OFFSET0_1                     (volatile unsigned long *)0xd0107594
//Bit 10:0  offset2
#define P_VPP_MATRIX_OFFSET2                       (volatile unsigned long *)0xd0107598
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VPP_MATRIX_PRE_OFFSET0_1                 (volatile unsigned long *)0xd010759c
//Bit 10:0  pre_offset2
#define P_VPP_MATRIX_PRE_OFFSET2                   (volatile unsigned long *)0xd01075a0
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define P_VPP_DUMMY_DATA1                          (volatile unsigned long *)0xd01075a4
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define P_VPP_GAINOFF_CTRL0                        (volatile unsigned long *)0xd01075a8
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define P_VPP_GAINOFF_CTRL1                        (volatile unsigned long *)0xd01075ac
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define P_VPP_GAINOFF_CTRL2                        (volatile unsigned long *)0xd01075b0
//Bit 26:16, pre_offset0, signed data 
//Bit 10:0, pre_offset1, signed data 
#define P_VPP_GAINOFF_CTRL3                        (volatile unsigned long *)0xd01075b4
//Bit 10:0, pre_offset2, signed data 
#define P_VPP_GAINOFF_CTRL4                        (volatile unsigned long *)0xd01075b8
//only two registers used in the color management, which are defined in the chroma_reg.h
//`define VPP_CHROMA_ADDR_PORT    8'h70
//`define VPP_CHROMA_DATA_PORT    8'h71
//
// Reading file:  chroma_reg.h
//
//**********************************************************************************
//* Copyright (c) 2008, AMLOGIC Inc.
//* All rights reserved
//**********************************************************************************
//* File :  chroma_reg.v
//* Author : Terrence Wang
//* Date : Dec 2008
//* Description :  
//*
//********************************************************************************** 
//* Modification History:
//* Date    Modified By         Reason
//**********************************************************************************
// synopsys translate_off
// synopsys translate_on
#define P_VPP_CHROMA_ADDR_PORT                     (volatile unsigned long *)0xd01075c0
#define P_VPP_CHROMA_DATA_PORT                     (volatile unsigned long *)0xd01075c4
//`define CHROMA_ADDR_PORT        8'h67
//`define CHROMA_DATA_PORT        8'h68

//  CHROMA_GAIN_REG_XX(00-07)
//  hue gain, sat gain function control
//  Bit 31      reg_sat_en                  enable sat adjustment in current region
//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
//                                          1'b1: increase  1'b0: decrease
//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
//                                          2'b01 central biggest   2'b00 one side biggest
//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
//                                          1'b1: left side biggest 1'b0 right side biggest  
//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
//                                          0x00-0xff
//  Bit 15      reg_hue_en                  enable hue adjustment in current region
//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
//                                          1'b1: clockwise 1'b0: anti-clockwise
//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
//                                          1'b1: parabola curve    1'b0: non-symmetry curve
//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
//                                          1'b1: right side change more    1'b0: left side change more
//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
//                                          0x00-0x80, note: should be no bigger than 0x80

    #define CHROMA_GAIN_REG00       0x00


//  HUE_HUE_RANGE_REG_XX(00-07)
//  hue range select
//  Bit 31:24   no use now
//  Bit 23:16   reg_hue_shift_range         define the angle of target region
//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
//                                          must be greater or equal than 8'd8
//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
//                                          the symmetry region hue_shift_range = reg_hue_shift_range
//                                          in symmetry region, all the sat and hue setting will be same with original region, 
//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
//                                          0x6000 means 360 degree
//                                          only region 0 and 1 can exceed 360 degrees.

    #define HUE_HUE_RANGE_REG00     0x01


//  HUE_RANGE_INV_REG_XX
//  Calculation should be follow
//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
//  HUE_RANGE_INV_REG_XX is to used to save divider

    #define HUE_RANGE_INV_REG00     0x02



//  for belowing each low, high, low_slope, high_slope group:
//            a_____________b
//            /             \               a = low  + 2^low_slope
//           /               \              b = high - 2^high_slope
//          /                 \             low_slope <= 7; high_slope <= 7
//         /                   \            b >= a
//  ______/_____________________\________
//       low                    high
//
//
//  HUE_LUM_RANGE_REG_XX(00-07)
//  luma range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
//                                          0x00-0xff

    #define HUE_LUM_RANGE_REG00     0x03

//  HUE_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
//                                          0x00-0xff

    #define HUE_SAT_RANGE_REG00     0x04

//  SAT_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
//                                          0x00-0xff

    #define SAT_SAT_RANGE_REG00     0x05


    #define CHROMA_GAIN_REG01       0x06
    #define HUE_HUE_RANGE_REG01     0x07
    #define HUE_RANGE_INV_REG01     0x08
    #define HUE_LUM_RANGE_REG01     0x09
    #define HUE_SAT_RANGE_REG01     0x0a
    #define SAT_SAT_RANGE_REG01     0x0b

    #define CHROMA_GAIN_REG02       0x0c
    #define HUE_HUE_RANGE_REG02     0x0d
    #define HUE_RANGE_INV_REG02     0x0e
    #define HUE_LUM_RANGE_REG02     0x0f
    #define HUE_SAT_RANGE_REG02     0x10
    #define SAT_SAT_RANGE_REG02     0x11


    #define CHROMA_GAIN_REG03       0x12
    #define HUE_HUE_RANGE_REG03     0x13
    #define HUE_RANGE_INV_REG03     0x14
    #define HUE_LUM_RANGE_REG03     0x15
    #define HUE_SAT_RANGE_REG03     0x16
    #define SAT_SAT_RANGE_REG03     0x17

    #define CHROMA_GAIN_REG04       0x18
    #define HUE_HUE_RANGE_REG04     0x19
    #define HUE_RANGE_INV_REG04     0x1a
    #define HUE_LUM_RANGE_REG04     0x1b
    #define HUE_SAT_RANGE_REG04     0x1c
    #define SAT_SAT_RANGE_REG04     0x1d

    #define CHROMA_GAIN_REG05       0x1e
    #define HUE_HUE_RANGE_REG05     0x1f
    #define HUE_RANGE_INV_REG05     0x20
    #define HUE_LUM_RANGE_REG05     0x21
    #define HUE_SAT_RANGE_REG05     0x22
    #define SAT_SAT_RANGE_REG05     0x23

    #define CHROMA_GAIN_REG06       0x24
    #define HUE_HUE_RANGE_REG06     0x25
    #define HUE_RANGE_INV_REG06     0x26
    #define HUE_LUM_RANGE_REG06     0x27
    #define HUE_SAT_RANGE_REG06     0x28
    #define SAT_SAT_RANGE_REG06     0x29

    #define CHROMA_GAIN_REG07       0x2a
    #define HUE_HUE_RANGE_REG07     0x2b
    #define HUE_RANGE_INV_REG07     0x2c
    #define HUE_LUM_RANGE_REG07     0x2d
    #define HUE_SAT_RANGE_REG07     0x2e
    #define SAT_SAT_RANGE_REG07     0x2f

//  REG_CHROMA_CONTROL
//  Bit 31      reg_chroma_en               enable color manage function
//                                          1'b1: enable    1'b0: bypass
//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
//  Bit 5       uv_adj_en                   final uv_adjust enable
//                                          1'b1: enable    1'b0: bypass
//  Bit 2       hue_en                      rgb to hue enable
//                                          1'b1: enable(default)   1'b0: bypass
//  Bit 1:0     csc_sel                     define input YUV with different color type
//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024
    #define REG_DEMO_CENTER_BAR     0x31   // default 32h'0
    #define REG_DEMO_HLIGHT_MODE    0x32   // default 32h'0
    #define REG_DEMO_OWR_DATA       0x33   // default 32h'0


////===========================================////
//// CM2 ADDR
////===========================================////

    #define SAT_BYYB_NODE_REG0          0x200   // default 32'h0 
    #define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
    #define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
    #define SAT_SRC_NODE_REG            0x203   // default 32'h0
    #define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
    #define FRM_SIZE_REG                0x205   // default 32'h0
    #define FITLER_CFG_REG              0x206   // default 32'h0
    #define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
    #define CM_ENH_CTL_REG              0x208   // default 32'h0

    #define ROI_X_SCOPE_REG             0x209   // default 32'h0
    #define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
    #define POI_XY_DIR_REG              0x20b   // default 32'h0
    #define COI_Y_SCOPE_REG             0x20c   // default 32'h0
    #define COI_H_SCOPE_REG             0x20d   // default 32'h0
    #define COI_S_SCOPE_REG             0x20e   // default 32'h0
    #define IFO_MODE_REG                0x20f   // default 32'h0
    #define POI_RPL_MODE_REG            0x210   // default 32'h0
    #define DEMO_OWR_YHS_REG            0x211   // default 32'h0
    #define DEMO_POI_Y_REG              0x212   // default 32'h0
    #define DEMO_POI_H_REG              0x213   // default 32'h0
    #define DEMO_POI_S_REG              0x214   // default 32'h0
    //`define LUMA_BYH_LIMT_REG           10'h215   // default 32'h0
    #define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
    #define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
    #define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
    #define UVHS_OFST_REG               0x218   // default 32'h0
    #define HUE_CFG_PARA_REG            0x219   // default 32'h0
    #define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
    #define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0    

////========= NODE 0 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 1 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 2 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 3 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 4 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 5 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 6 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 7 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 8 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 9 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 10 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 11 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 12 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 13 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx


/* Constraints 
0)
  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
  the 8 regions for hue adjustment are defined by: (example are for region 0)
    a) hue:
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_hue_sat_low_00 
        end:   reg_hue_sat_high_00  

  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
  the 8 regions for sat adjustment are defined by: (example are for region 0)
    a) hue: same as that for hue adjustment.
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_sat_sat_low_00
        end:   reg_sat_sat_high_00  

1)
  reg_hue_hue_shift_range_00[7:0]:
  reg_hue_hue_shift_range_01[7:0]:
  reg_hue_hue_shift_range_02[7:0]:
  reg_hue_hue_shift_range_03[7:0]:
  reg_hue_hue_shift_range_04[7:0]:
  reg_hue_hue_shift_range_05[7:0]:
  reg_hue_hue_shift_range_06[7:0]:
  reg_hue_hue_shift_range_07[7:0]:
  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx

2)
  all regions of 0-7 should meet below requirement. below is just an example for region 7.
  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >= 
        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)

  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)

  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)

  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)

3)
  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
  only region 0 and 1 can exceed 360 degrees. ie:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
  but below should be met:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1

  others could not exceed 360 degrees. ie:
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.

4)
  reg_hue_gain_00[7:0] <= 0x80.
  reg_hue_gain_01[7:0] <= 0x80.
  reg_hue_gain_02[7:0] <= 0x80.
  reg_hue_gain_03[7:0] <= 0x80.
  reg_hue_gain_04[7:0] <= 0x80.
  reg_hue_gain_05[7:0] <= 0x80.
  reg_hue_gain_06[7:0] <= 0x80.
  reg_hue_gain_07[7:0] <= 0x80.

5)
  below registers can only have two setting: 00 and 01.
    reg_hue_central_en_00[1:0]  .. _07[1:0]
    reg_sat_central_en_00[1:0]  .. _07[1:0]

6)
  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
   for example: below is for region 0:
   reg_hue_lum_low_slope_00[3:0]  <= 7
   reg_hue_lum_high_slope_00[3:0] <= 7
   reg_hue_sat_low_slope_00[3:0]  <= 7
   reg_hue_sat_high_slope_00[3:0] <= 7
   reg_sat_lum_low_slope_00[3:0]  <= 7
   reg_sat_lum_high_slope_00[3:0] <= 7
   reg_sat_sat_low_slope_00[3:0]  <= 7
   reg_sat_sat_high_slope_00[3:0] <= 7
*/

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  chroma_reg.h
//
//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
//because the register itself canot be set again without clk
//Bit 31:0
#define P_VPP_GCLK_CTRL0                           (volatile unsigned long *)0xd01075c8
//(front_lti), (front_cti), Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
//Bit 13:0
#define P_VPP_GCLK_CTRL1                           (volatile unsigned long *)0xd01075cc
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
#define P_VPP_SC_GCLK_CTRL                         (volatile unsigned long *)0xd01075d0
//Bit 17:9 VD1 alpha for preblend
//Bit 8:0 VD1 alpha for postblend
#define P_VPP_MISC1                                (volatile unsigned long *)0xd01075d8
//Bit 31:24     blackext_start
//Bit 23:16     blackext_slope1
//Bit 15:8      blackext_midpt
//Bit 7:0       blackext_slope2
#define P_VPP_BLACKEXT_CTRL                        (volatile unsigned long *)0xd0107600
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define P_VPP_DNLP_CTRL_00                         (volatile unsigned long *)0xd0107604
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define P_VPP_DNLP_CTRL_01                         (volatile unsigned long *)0xd0107608
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define P_VPP_DNLP_CTRL_02                         (volatile unsigned long *)0xd010760c
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define P_VPP_DNLP_CTRL_03                         (volatile unsigned long *)0xd0107610
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define P_VPP_DNLP_CTRL_04                         (volatile unsigned long *)0xd0107614
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define P_VPP_DNLP_CTRL_05                         (volatile unsigned long *)0xd0107618
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define P_VPP_DNLP_CTRL_06                         (volatile unsigned long *)0xd010761c
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define P_VPP_DNLP_CTRL_07                         (volatile unsigned long *)0xd0107620
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define P_VPP_DNLP_CTRL_08                         (volatile unsigned long *)0xd0107624
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define P_VPP_DNLP_CTRL_09                         (volatile unsigned long *)0xd0107628
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define P_VPP_DNLP_CTRL_10                         (volatile unsigned long *)0xd010762c
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define P_VPP_DNLP_CTRL_11                         (volatile unsigned long *)0xd0107630
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define P_VPP_DNLP_CTRL_12                         (volatile unsigned long *)0xd0107634
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define P_VPP_DNLP_CTRL_13                         (volatile unsigned long *)0xd0107638
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define P_VPP_DNLP_CTRL_14                         (volatile unsigned long *)0xd010763c
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define P_VPP_DNLP_CTRL_15                         (volatile unsigned long *)0xd0107640
//Bit 28        vlti_step
//Bit 27        vlti_step2
//Bit 26:25     hlti_step
//Bit 24:20     peaking_gain_h1
//Bit 19:15     peaking_gain_h2
//Bit 14:10     peaking_gain_h3
//Bit 9:5       peaking_gain_h4
//Bit 4:0       peaking_gain_h5
#define P_VPP_PEAKING_HGAIN                        (volatile unsigned long *)0xd0107644
//Bit 31        hsvsharp_buf_en
//Bit 30        hsvsharp_buf_c5line_mode
//Bit 29:25     peaking_gain_v1
//Bit 24:20     peaking_gain_v2
//Bit 19:15     peaking_gain_v3
//Bit 14:10     peaking_gain_v4
//Bit 9:5       peaking_gain_v5
//Bit 4:0       peaking_gain_v6
#define P_VPP_PEAKING_VGAIN                        (volatile unsigned long *)0xd0107648
//Bit 31:26     hpeaking_slope1
//Bit 25:20     hpeaking_slope2
//Bit 19:12     hpeaking_slope_th1
//Bit 11:6      vpeaking_slope1
//Bit 5:0       vpeaking_slope2
#define P_VPP_PEAKING_NLP_1                        (volatile unsigned long *)0xd010764c
//Bit 31:24     hpeaking_slope_th2
//Bit 23:16     hpeaking_nlp_coring_th
//Bit 15:8      hpeaking_nlp_pgain
//Bit 7:0       hpeaking_nlp_ngain
#define P_VPP_PEAKING_NLP_2                        (volatile unsigned long *)0xd0107650
//Bit 31:24     vpeaking_slope_th1
//Bit 23:18     speaking_slope1
//Bit 17:12     speaking_slope2
//Bit 11:4      speaking_slope_th1
//Bit 3:0       peaking_coring_gain
#define P_VPP_PEAKING_NLP_3                        (volatile unsigned long *)0xd0107654
//Bit 31:24     vpeaking_slope_th2
//Bit 23:16     vpeaking_nlp_coring_th
//Bit 15:8      vpeaking_nlp_pgain
//Bit 7:0       vpeaking_nlp_ngain
#define P_VPP_PEAKING_NLP_4                        (volatile unsigned long *)0xd0107658
//Bit 31:24     speaking_slope_th2
//Bit 23:16     speaking_nlp_coring_th
//Bit 15:8      speaking_nlp_pgain
//Bit 7:0       speaking_nlp_ngain
#define P_VPP_PEAKING_NLP_5                        (volatile unsigned long *)0xd010765c
//Bit 31:24     peaking_coring_th_l
//Bit 23:16     peaking_coring_th_h
//Bit 15:12     vlimit_high_coef
//Bit 11:8      vlimit_low_coef
//Bit 7:4       hlimit_high_coef
//Bit 3:0       hlimit_low_coef
#define P_VPP_SHARP_LIMIT                          (volatile unsigned long *)0xd0107660
//Bit 31:24     vlti_neg_gain
//Bit 23:16     vlti_pos_gain
//Bit 15:8      vlti_threshold
//Bit 7:0       vlti_blend_factor
#define P_VPP_VLTI_CTRL                            (volatile unsigned long *)0xd0107664
//Bit 31:24     hlti_neg_gain
//Bit 23:16     hlti_pos_gain
//Bit 15:8      hlti_threshold
//Bit 7:0       hlti_blend_factor
#define P_VPP_HLTI_CTRL                            (volatile unsigned long *)0xd0107668
//Bit 30        cti_c444to422_en
//Bit 29:28     cti_vfilter_type
//Bit 27        cti_c422to444_en
//Bit 26:24     cti_step2
//Bit 23:21     cti_step
//Bit 20:16     cti_blend_factor
//Bit 15        cti_median_mode
//Bit 14:8      cti_threshold
//Bit 7:0       cti_gain
#define P_VPP_CTI_CTRL                             (volatile unsigned long *)0xd010766c
//Bit 29        blue_stretch_cb_inc
//Bit 28        blue_stretch_cr_inc
//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
//Bit 23:16     blue_stretch_gain
//Bit 15:8      blue_stretch_gain_cb4cr
//Bit 7:0       blue_stretch_luma_high
#define P_VPP_BLUE_STRETCH_1                       (volatile unsigned long *)0xd0107670
//Bit 31:27     blue_stretch_error_crp
//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
//Bit 15:11     blue_stretch_error_crn
//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
#define P_VPP_BLUE_STRETCH_2                       (volatile unsigned long *)0xd0107674
//Bit 31:27     blue_stretch_error_cbp
//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
//Bit 15:11     blue_stretch_error_cbn
//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
#define P_VPP_BLUE_STRETCH_3                       (volatile unsigned long *)0xd0107678
//Bit 25:16 bypass_ccoring_ythd
//Bit 15:8, Chroma coring threshold
//Bit 3:0, Chroma coring slope
#define P_VPP_CCORING_CTRL                         (volatile unsigned long *)0xd0107680
//Bit 20 demo chroma coring enable
//Bit 19 demo black enxtension enable
//Bit 18 demo dynamic nonlinear luma processing enable
//Bit 17 demo hsvsharp enable
//Bit 16 demo bluestretch enable
//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
//Bit 4 chroma coring enable
//Bit 3 black enxtension enable
//Bit 2 dynamic nonlinear luma processing enable
//Bit 1 hsvsharp enable
//Bit 0 bluestretch enable
#define P_VPP_VE_ENABLE_CTRL                       (volatile unsigned long *)0xd0107684
//Bit 12:0, demo left or top screen width
#define P_VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH        (volatile unsigned long *)0xd0107688
 //  Bit 31      center bar enable
 //  Bit 27:24   center bar width    (*2)
 //  Bit 23:16   center bar Cr       (*4)
 //  Bit 15:8    center bar Cb       (*4)
 //  Bit 7:0     center bar y        (*4)
#define P_VPP_VE_DEMO_CENTER_BAR                   (volatile unsigned long *)0xd010768c
//28:16  ve_line_length
//12:0   ve_pic_height
#define P_VPP_VE_H_V_SIZE                          (volatile unsigned long *)0xd0107690
//Bit 10   reset bit, high active
//Bit 9    0: measuring rising edge, 1: measuring falling edge
//Bit 8    if true, accumulate the counter number, otherwise not
//Bit 7:0  vsync_span, define how many vsync span need to measure 
#define P_VPP_VDO_MEAS_CTRL                        (volatile unsigned long *)0xd01076a0
//Read only
//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
//15:0, high bit portion of counter
#define P_VPP_VDO_MEAS_VS_COUNT_HI                 (volatile unsigned long *)0xd01076a4
//Read only
//31:0, low bit portion of counter
#define P_VPP_VDO_MEAS_VS_COUNT_LO                 (volatile unsigned long *)0xd01076a8
//bit 11:9 vd2_sel,  001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection             
//bit 8:6 vd1_l_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//bit 5:3 vd1_r_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//note: the source vd1_l_sel selected cannot be used as the source of vd1_r_sel or vd2_sel
// vd1_r_sel is useful only vd1_interleave_mode is not 00. And the source vd1_r_sel used can not used for the vd2_sel any more.  
//bit 2:0 vd1_interleave_mode, 000: no interleave, 001: pixel interleaving, 010: line interleaving, 011: 2 pixel interleaving, 
// 100: 2 line interleaving
#define P_VPP_INPUT_CTRL                           (volatile unsigned long *)0xd01076ac
//bit 25:24 cti_bpf_sel
//bit 20:16 cti_blend_factor_gama
//bit 12:8 cti_blend_factor_beta
//bit 4:0 cti_blend_factor_alpha
#define P_VPP_CTI_CTRL2                            (volatile unsigned long *)0xd01076b0
#define P_VPP_PEAKING_SAT_THD1                     (volatile unsigned long *)0xd01076b4
#define P_VPP_PEAKING_SAT_THD2                     (volatile unsigned long *)0xd01076b8
#define P_VPP_PEAKING_SAT_THD3                     (volatile unsigned long *)0xd01076bc
#define P_VPP_PEAKING_SAT_THD4                     (volatile unsigned long *)0xd01076c0
#define P_VPP_PEAKING_SAT_THD5                     (volatile unsigned long *)0xd01076c4
#define P_VPP_PEAKING_SAT_THD6                     (volatile unsigned long *)0xd01076c8
#define P_VPP_PEAKING_SAT_THD7                     (volatile unsigned long *)0xd01076cc
#define P_VPP_PEAKING_SAT_THD8                     (volatile unsigned long *)0xd01076d0
#define P_VPP_PEAKING_SAT_THD9                     (volatile unsigned long *)0xd01076d4
#define P_VPP_PEAKING_GAIN_ADD1                    (volatile unsigned long *)0xd01076d8
#define P_VPP_PEAKING_GAIN_ADD2                    (volatile unsigned long *)0xd01076dc
//bit 15:8  peaking_factor
//bit 5     peaking_dnlp_demo_en
//bit 4     peaking_dnlp_en
//bit 3:0   peaking_filter_sel
#define P_VPP_PEAKING_DNLP                         (volatile unsigned long *)0xd01076e0
//bit 24    sharp_demo_win_en
//bit 23:12 sharp_demo_win_vend
//bit 11:0  sharp_demo_win_vstart
#define P_VPP_SHARP_DEMO_WIN_CTRL1                 (volatile unsigned long *)0xd01076e4
//bit 23:12 sharp_demo_win_hend
//bit 11:0  sharp_demo_win_hstart
#define P_VPP_SHARP_DEMO_WIN_CTRL2                 (volatile unsigned long *)0xd01076e8
//Bit 31:24     front_hlti_neg_gain
//Bit 23:16     front_hlti_pos_gain
//Bit 15:8      front_hlti_threshold
//Bit 7:0       front_hlti_blend_factor
#define P_VPP_FRONT_HLTI_CTRL                      (volatile unsigned long *)0xd01076ec
//Bit 31        front_enable, enable the front LTI&CTI before scaler
//Bit 26:24     front_cti_step2
//Bit 23:21     front_cti_step
//Bit 20:16     front_cti_blend_factor
//Bit 15        front_cti_median_mode
//Bit 14:8      front_cti_threshold
//Bit 7:0       front_cti_gain
#define P_VPP_FRONT_CTI_CTRL                       (volatile unsigned long *)0xd01076f0
//bit 29:28 front_hlti_step
//bit 25:24 front_cti_bpf_sel
//bit 20:16 front_cti_blend_factor_gama
//bit 12:8  front_cti_blend_factor_beta
//bit 4:0   front_cti_blend_factor_alpha
#define P_VPP_FRONT_CTI_CTRL2                      (volatile unsigned long *)0xd01076f4
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define P_VPP_OSD_VSC_PHASE_STEP                   (volatile unsigned long *)0xd0107700
//Bit 31:16, botttom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define P_VPP_OSD_VSC_INI_PHASE                    (volatile unsigned long *)0xd0107704
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length 
#define P_VPP_OSD_VSC_CTRL0                        (volatile unsigned long *)0xd0107708
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define P_VPP_OSD_HSC_PHASE_STEP                   (volatile unsigned long *)0xd010770c
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define P_VPP_OSD_HSC_INI_PHASE                    (volatile unsigned long *)0xd0107710
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define P_VPP_OSD_HSC_CTRL0                        (volatile unsigned long *)0xd0107714
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define P_VPP_OSD_HSC_INI_PAT_CTRL                 (volatile unsigned long *)0xd0107718
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define P_VPP_OSD_SC_DUMMY_DATA                    (volatile unsigned long *)0xd010771c
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable 
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define P_VPP_OSD_SC_CTRL0                         (volatile unsigned long *)0xd0107720
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define P_VPP_OSD_SCI_WH_M1                        (volatile unsigned long *)0xd0107724
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define P_VPP_OSD_SCO_H_START_END                  (volatile unsigned long *)0xd0107728
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define P_VPP_OSD_SCO_V_START_END                  (volatile unsigned long *)0xd010772c
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define P_VPP_OSD_SCALE_COEF_IDX                   (volatile unsigned long *)0xd0107730
//coefficients for vertical filter and horizontal filter
#define P_VPP_OSD_SCALE_COEF                       (volatile unsigned long *)0xd0107734
//Bit 12:0 line number use to generate interrupt when line == this number
#define P_VPP_INT_LINE_NUM                         (volatile unsigned long *)0xd0107738
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_regs.h
//
//
// Reading file:  vpp2_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPP2_VCBUS_BASE = 0x19
// -----------------------------------------------
//===========================================================================
// Video postprocesing Registers 
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    
// Bit 15:8     CB
// Bit 7:0      CR 
#define P_VPP2_DUMMY_DATA                          (volatile unsigned long *)0xd0106400
//input line length used in VPP
#define P_VPP2_LINE_IN_LENGTH                      (volatile unsigned long *)0xd0106404
//input Picture height used in VPP
#define P_VPP2_PIC_IN_HEIGHT                       (volatile unsigned long *)0xd0106408
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15    index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)  
//Bit 14    1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered 
//Bit 6:0   coef index
#define P_VPP2_SCALE_COEF_IDX                      (volatile unsigned long *)0xd010640c
//coefficients for vertical filter and horizontal filter
#define P_VPP2_SCALE_COEF                          (volatile unsigned long *)0xd0106410
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//      . 
//      .
//      .           region0        <---------- nonlinear region or nonscaling region    
//      .
//  ---------------------------  
//  ---------------------------  <------ region1_startp 
//      .
//      .           region1         <---------- nonlinear region
//      .
//      .
//  ---------------------------  
//  ---------------------------  <------ region2_startp
//      .
//      .           region2         <---------- linear region
//      .
//      .
//  ---------------------------  
//  ---------------------------  <------ region3_startp
//      .
//      .           region3         <---------- nonlinear region
//      .
//      .
//  ---------------------------  
//  ---------------------------  <------ region4_startp
//      .
//      .           region4         <---------- nonlinear region or nonoscaling region
//      .
//      .
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_VPP2_VSC_REGION12_STARTP                 (volatile unsigned long *)0xd0106414
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_VPP2_VSC_REGION34_STARTP                 (volatile unsigned long *)0xd0106418
#define P_VPP2_VSC_REGION4_ENDP                    (volatile unsigned long *)0xd010641c
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0  fraction part
#define P_VPP2_VSC_START_PHASE_STEP                (volatile unsigned long *)0xd0106420
//vertical scaler region0 phase slope, Bit24 signed bit
#define P_VPP2_VSC_REGION0_PHASE_SLOPE             (volatile unsigned long *)0xd0106424
//vertical scaler region1 phase slope, Bit24 signed bit
#define P_VPP2_VSC_REGION1_PHASE_SLOPE             (volatile unsigned long *)0xd0106428
//vertical scaler region3 phase slope, Bit24 signed bit
#define P_VPP2_VSC_REGION3_PHASE_SLOPE             (volatile unsigned long *)0xd010642c
//vertical scaler region4 phase slope, Bit24 signed bit
#define P_VPP2_VSC_REGION4_PHASE_SLOPE             (volatile unsigned long *)0xd0106430
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X, 
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field   
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field   
#define P_VPP2_VSC_PHASE_CTRL                      (volatile unsigned long *)0xd0106434
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define P_VPP2_VSC_INI_PHASE                       (volatile unsigned long *)0xd0106438
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_VPP2_HSC_REGION12_STARTP                 (volatile unsigned long *)0xd0106440
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_VPP2_HSC_REGION34_STARTP                 (volatile unsigned long *)0xd0106444
#define P_VPP2_HSC_REGION4_ENDP                    (volatile unsigned long *)0xd0106448
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0  fraction part
#define P_VPP2_HSC_START_PHASE_STEP                (volatile unsigned long *)0xd010644c
//horizontal scaler region0 phase slope, Bit24 signed bit
#define P_VPP2_HSC_REGION0_PHASE_SLOPE             (volatile unsigned long *)0xd0106450
//horizontal scaler region1 phase slope, Bit24 signed bit
#define P_VPP2_HSC_REGION1_PHASE_SLOPE             (volatile unsigned long *)0xd0106454
//horizontal scaler region3 phase slope, Bit24 signed bit
#define P_VPP2_HSC_REGION3_PHASE_SLOPE             (volatile unsigned long *)0xd0106458
//horizontal scaler region4 phase slope, Bit24 signed bit
#define P_VPP2_HSC_REGION4_PHASE_SLOPE             (volatile unsigned long *)0xd010645c
//Bit 22:21   horizontal scaler initial repeat pixel0 number
//Bit 19:16   horizontal scaler initial receiving number   
//Bit 15:0    horizontal scaler top field initial phase
#define P_VPP2_HSC_PHASE_CTRL                      (volatile unsigned long *)0xd0106460
// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
// Bit 2:0 vertical scaler bank length
#define P_VPP2_SC_MISC                             (volatile unsigned long *)0xd0106464
// preblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_PREBLEND_VD1_H_START_END            (volatile unsigned long *)0xd0106468
// preblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_PREBLEND_VD1_V_START_END            (volatile unsigned long *)0xd010646c
// postblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_POSTBLEND_VD1_H_START_END           (volatile unsigned long *)0xd0106470
// postblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_POSTBLEND_VD1_V_START_END           (volatile unsigned long *)0xd0106474
// preblend horizontal size
#define P_VPP2_PREBLEND_H_SIZE                     (volatile unsigned long *)0xd0106480
// postblend horizontal size
#define P_VPP2_POSTBLEND_H_SIZE                    (volatile unsigned long *)0xd0106484
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 15:8     preblend hold lines
//Bit 7:0      postblend hold lines
#define P_VPP2_HOLD_LINES                          (volatile unsigned long *)0xd0106488
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define P_VPP2_BLEND_ONECOLOR_CTRL                 (volatile unsigned long *)0xd010648c
//Read Only, VPP preblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define P_VPP2_PREBLEND_CURRENT_XY                 (volatile unsigned long *)0xd0106490
//Read Only, VPP postblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define P_VPP2_POSTBLEND_CURRENT_XY                (volatile unsigned long *)0xd0106494
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// bit 28   color management enable
// Bit 27,  reserved 
// Bit 26:18, reserved
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, reserved
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, reserved
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultipiled 
// Bit 8,  if true, osd2 is alpha premultipiled 
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,  
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//           the aync fifo will be reseted.
// Bit 1,     
// Bit 0    if true, the output result of VPP is saturated
#define P_VPP2_MISC                                (volatile unsigned long *)0xd0106498
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define P_VPP2_OFIFO_SIZE                          (volatile unsigned long *)0xd010649c
//Read only
//Bit 28:17 current scale out fifo counter
//Bit 16:12 current afifo counter
//Bit 11:0 current ofifo counter
#define P_VPP2_FIFO_STATUS                         (volatile unsigned long *)0xd01064a0
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
#define P_VPP2_SMOKE_CTRL                          (volatile unsigned long *)0xd01064a4
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 chanel
//smoke2 for OSD2 chanel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define P_VPP2_SMOKE1_VAL                          (volatile unsigned long *)0xd01064a8
#define P_VPP2_SMOKE2_VAL                          (volatile unsigned long *)0xd01064ac
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_SMOKE1_H_START_END                  (volatile unsigned long *)0xd01064b4
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_SMOKE1_V_START_END                  (volatile unsigned long *)0xd01064b8
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_SMOKE2_H_START_END                  (volatile unsigned long *)0xd01064bc
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP2_SMOKE2_V_START_END                  (volatile unsigned long *)0xd01064c0
//Bit 27:16 scale out fifo line length minus 1
//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
#define P_VPP2_SCO_FIFO_CTRL                       (volatile unsigned long *)0xd01064cc
//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 23 horizontal scaler double pixel mode
//Bit 22:21   horizontal scaler initial repeat pixel0 number1
//Bit 19:16   horizontal scaler initial receiving number1   
//Bit 15:0    horizontal scaler top field initial phase1
#define P_VPP2_HSC_PHASE_CTRL1                     (volatile unsigned long *)0xd01064d0
//for 3D quincunx sub-sampling
//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
//22:20  prehsc pattern start
//18:16 prehsc pattern end
//15:8 pattern, each patten 1 bit, from lsb -> msb
//6:4  pattern start
//2:0  pattern end
#define P_VPP2_HSC_INI_PAT_CTRL                    (volatile unsigned long *)0xd01064d4
//Bit 3         minus black level enable for vadj2
//Bit 2         Video adjustment enable for vadj2
//Bit 1         minus black level enable for vadj1
//Bit 0         Video adjustment enable for vadj1
#define P_VPP2_VADJ_CTRL                           (volatile unsigned long *)0xd0106500
//Bit 16:8  brightness, signed value
//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
#define P_VPP2_VADJ1_Y                             (volatile unsigned long *)0xd0106504
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define P_VPP2_VADJ1_MA_MB                         (volatile unsigned long *)0xd0106508
#define P_VPP2_VADJ1_MC_MD                         (volatile unsigned long *)0xd010650c
//Bit 16:8  brightness, signed value
//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
#define P_VPP2_VADJ2_Y                             (volatile unsigned long *)0xd0106510
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define P_VPP2_VADJ2_MA_MB                         (volatile unsigned long *)0xd0106514
#define P_VPP2_VADJ2_MC_MD                         (volatile unsigned long *)0xd0106518
//Read only 
//Bit 31, if it is true, it means this probe is valid in the last field/frame
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VPP2_MATRIX_PROBE_COLOR                  (volatile unsigned long *)0xd0106570
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VPP2_MATRIX_HL_COLOR                     (volatile unsigned long *)0xd0106574
//28:16 probe x, postion
//12:0  probe y, position  
#define P_VPP2_MATRIX_PROBE_POS                    (volatile unsigned long *)0xd0106578
//Bit 16,  highlight_en
//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix,
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    reserved
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define P_VPP2_MATRIX_CTRL                         (volatile unsigned long *)0xd010657c
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VPP2_MATRIX_COEF00_01                    (volatile unsigned long *)0xd0106580
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define P_VPP2_MATRIX_COEF02_10                    (volatile unsigned long *)0xd0106584
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VPP2_MATRIX_COEF11_12                    (volatile unsigned long *)0xd0106588
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VPP2_MATRIX_COEF20_21                    (volatile unsigned long *)0xd010658c
#define P_VPP2_MATRIX_COEF22                       (volatile unsigned long *)0xd0106590
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VPP2_MATRIX_OFFSET0_1                    (volatile unsigned long *)0xd0106594
//Bit 10:0  offset2
#define P_VPP2_MATRIX_OFFSET2                      (volatile unsigned long *)0xd0106598
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VPP2_MATRIX_PRE_OFFSET0_1                (volatile unsigned long *)0xd010659c
//Bit 10:0  pre_offset2
#define P_VPP2_MATRIX_PRE_OFFSET2                  (volatile unsigned long *)0xd01065a0
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define P_VPP2_DUMMY_DATA1                         (volatile unsigned long *)0xd01065a4
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define P_VPP2_GAINOFF_CTRL0                       (volatile unsigned long *)0xd01065a8
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define P_VPP2_GAINOFF_CTRL1                       (volatile unsigned long *)0xd01065ac
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define P_VPP2_GAINOFF_CTRL2                       (volatile unsigned long *)0xd01065b0
//Bit 26:16, pre_offset0, signed data 
//Bit 10:0, pre_offset1, signed data 
#define P_VPP2_GAINOFF_CTRL3                       (volatile unsigned long *)0xd01065b4
//Bit 10:0, pre_offset2, signed data 
#define P_VPP2_GAINOFF_CTRL4                       (volatile unsigned long *)0xd01065b8
//only two registers used in the color management, which are defined in the chroma_reg.h
#define P_VPP2_CHROMA_ADDR_PORT                    (volatile unsigned long *)0xd01065c0
#define P_VPP2_CHROMA_DATA_PORT                    (volatile unsigned long *)0xd01065c4
//`include "chroma_reg.h"       //defined inside is the indirect addressed registers
//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
//because the register itself canot be set again without clk
//Bit 31:0
#define P_VPP2_GCLK_CTRL0                          (volatile unsigned long *)0xd01065c8
//Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
//Bit 9:0
#define P_VPP2_GCLK_CTRL1                          (volatile unsigned long *)0xd01065cc
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
#define P_VPP2_SC_GCLK_CTRL                        (volatile unsigned long *)0xd01065d0
//Bit 17:9 VD1 alpha for preblend
//Bit 8:0 VD1 alpha for postblend
#define P_VPP2_MISC1                               (volatile unsigned long *)0xd01065d8
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define P_VPP2_DNLP_CTRL_00                        (volatile unsigned long *)0xd0106604
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define P_VPP2_DNLP_CTRL_01                        (volatile unsigned long *)0xd0106608
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define P_VPP2_DNLP_CTRL_02                        (volatile unsigned long *)0xd010660c
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define P_VPP2_DNLP_CTRL_03                        (volatile unsigned long *)0xd0106610
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define P_VPP2_DNLP_CTRL_04                        (volatile unsigned long *)0xd0106614
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define P_VPP2_DNLP_CTRL_05                        (volatile unsigned long *)0xd0106618
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define P_VPP2_DNLP_CTRL_06                        (volatile unsigned long *)0xd010661c
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define P_VPP2_DNLP_CTRL_07                        (volatile unsigned long *)0xd0106620
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define P_VPP2_DNLP_CTRL_08                        (volatile unsigned long *)0xd0106624
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define P_VPP2_DNLP_CTRL_09                        (volatile unsigned long *)0xd0106628
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define P_VPP2_DNLP_CTRL_10                        (volatile unsigned long *)0xd010662c
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define P_VPP2_DNLP_CTRL_11                        (volatile unsigned long *)0xd0106630
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define P_VPP2_DNLP_CTRL_12                        (volatile unsigned long *)0xd0106634
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define P_VPP2_DNLP_CTRL_13                        (volatile unsigned long *)0xd0106638
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define P_VPP2_DNLP_CTRL_14                        (volatile unsigned long *)0xd010663c
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define P_VPP2_DNLP_CTRL_15                        (volatile unsigned long *)0xd0106640
//Bit 20 reserved
//Bit 19 reserved
//Bit 18 demo dynamic nonlinear luma processing enable
//Bit 17 reserved
//Bit 16 reserved
//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
//Bit 4 reserved
//Bit 3 reserved
//Bit 2 dynamic nonlinear luma processing enable
//Bit 1 reserved
//Bit 0 reserved
#define P_VPP2_VE_ENABLE_CTRL                      (volatile unsigned long *)0xd0106684
//Bit 12:0, demo left or top screen width
#define P_VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH       (volatile unsigned long *)0xd0106688
 //  Bit 31      center bar enable
 //  Bit 27:24   center bar width    (*2)
 //  Bit 23:16   center bar Cr       (*4)
 //  Bit 15:8    center bar Cb       (*4)
 //  Bit 7:0     center bar y        (*4)
#define P_VPP2_VE_DEMO_CENTER_BAR                  (volatile unsigned long *)0xd010668c
//28:16  ve_line_length
//12:0   ve_pic_height
#define P_VPP2_VE_H_V_SIZE                         (volatile unsigned long *)0xd0106690
//Bit 10   reset bit, high active
//Bit 9    0: measuring rising edge, 1: measuring falling edge
//Bit 8    if true, accumulate the counter number, otherwise not
//Bit 7:0  vsync_span, define how many vsync span need to measure 
#define P_VPP2_VDO_MEAS_CTRL                       (volatile unsigned long *)0xd01066a0
//Read only
//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
//15:0, high bit portion of counter
#define P_VPP2_VDO_MEAS_VS_COUNT_HI                (volatile unsigned long *)0xd01066a4
//Read only
//31:0, low bit portion of counter
#define P_VPP2_VDO_MEAS_VS_COUNT_LO                (volatile unsigned long *)0xd01066a8
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define P_VPP2_OSD_VSC_PHASE_STEP                  (volatile unsigned long *)0xd0106700
//Bit 31:16, botttom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define P_VPP2_OSD_VSC_INI_PHASE                   (volatile unsigned long *)0xd0106704
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length 
#define P_VPP2_OSD_VSC_CTRL0                       (volatile unsigned long *)0xd0106708
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define P_VPP2_OSD_HSC_PHASE_STEP                  (volatile unsigned long *)0xd010670c
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define P_VPP2_OSD_HSC_INI_PHASE                   (volatile unsigned long *)0xd0106710
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define P_VPP2_OSD_HSC_CTRL0                       (volatile unsigned long *)0xd0106714
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define P_VPP2_OSD_HSC_INI_PAT_CTRL                (volatile unsigned long *)0xd0106718
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define P_VPP2_OSD_SC_DUMMY_DATA                   (volatile unsigned long *)0xd010671c
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable 
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define P_VPP2_OSD_SC_CTRL0                        (volatile unsigned long *)0xd0106720
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define P_VPP2_OSD_SCI_WH_M1                       (volatile unsigned long *)0xd0106724
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define P_VPP2_OSD_SCO_H_START_END                 (volatile unsigned long *)0xd0106728
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define P_VPP2_OSD_SCO_V_START_END                 (volatile unsigned long *)0xd010672c
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define P_VPP2_OSD_SCALE_COEF_IDX                  (volatile unsigned long *)0xd0106730
//coefficients for vertical filter and horizontal filter
#define P_VPP2_OSD_SCALE_COEF                      (volatile unsigned long *)0xd0106734
//Bit 12:0 line number use to generate interrupt when line == this number
#define P_VPP2_INT_LINE_NUM                        (volatile unsigned long *)0xd0106738
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp2_regs.h
//
//
// Reading file:  vregs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VIU_VCBUS_BASE = 0x1a
// -----------------------------------------------
#define P_VIU_ADDR_START                           (volatile unsigned long *)0xd0106800
#define P_VIU_ADDR_END                             (volatile unsigned long *)0xd0106bfc
//`define TRACE_REG 8'ff
//------------------------------------------------------------------------------
// VIU top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  4 RW, vd2_reset
// Bit  5 RW, vd2_fmt_reset
// Bit  6 RW, di_dsr1to2_reset
// Bit  7 RW, vpp_reset
// Bit  8 RW, di_if1_reset
// Bit  9 RW, di_if1_fmt_reset
// Bit 10 RW, di_inp_reset
// Bit 11 RW, di_inp_fmt_reset
// Bit 12 RW, di_mem_reset
// Bit 13 RW, di_mem_fmt_reset
// Bit 14 RW, di_nr_wr_mif_reset
// Bit 15 RW, dein_wr_mif_reset
// Bit 16 RW, di_chan2_mif_reset
// Bit 17 RW, di_mtn_wr_mif_reset
// Bit 18 RW, di_mtn_rd_mif_reset
// Bit 19 RW, di_mad_reset
// Bit 20 RW, vdin0_reset
// Bit 21 RW, vdin1_reset
// Bit 22 RW, nrin_mux_reset
// Bit 23 RW, vdin0_wr_reset
// Bit 24 RW, vdin1_wr_reset
// Bit 25 RW, reserved
// Bit 26 RW, d2d3_reset
// Bit 27 RW, di_cont_wr_mif_reset
// Bit 28 RW, di_cont_rd_mif_reset
#define P_VIU_SW_RESET                             (volatile unsigned long *)0xd0106804
//7:0 fix_disable
#define P_VIU_MISC_CTRL0                           (volatile unsigned long *)0xd0106818
#define P_D2D3_INTF_LENGTH                         (volatile unsigned long *)0xd0106820
// Bit 31:30 vdin0 dout splitter, bit 0 turns on vdin0 to old path, bit 1 turns on vdin0 to d2d3_intf vdin0 input path        
// Bit 29:28 vdin1 dout splitter, bit 0 turns on vdin1 to old path, bit 1 turns on vdin1 to d2d3_intf vdin1 input path  
// Bit 27:26 NR write dout splitter, bit 0 turns on NR write to old path, bit 1 turns on NR WR to d2d3_intf NR WR input path  
// Bit 23 if true, turn on clk_d2d3_reg (register clock)
// Bit 22 if true, turn on clk_d2d3
// Bit 21 reg_v1_go_line
// Bit 20 reg_v1_go_field   
// Bit 19 reg_v0_go_field
// Bit 18:16 v1_gofld_sel, 000: display go_field/go_line, 001: DI pre_frame_rst/go_line, 010: vdin0 go_field/go_line, 
//011: vdin1 go_field/go_line, otherwise: force go_field by reg_v1_go_field(bit20), force go_line by reg_v1_go_line(bit21)
// Bit 15:13 v0_gofld_sel, 000: display go_field, 001: DI pre_frame_rst, 010: vdin0 go_field, 011: vdin1 go_field, otherwise: force go_field by
// reg_v0_go_field(bit19)
// Bit 12:6 hole_lines for d2d3 depth read interface
// Bit 5:4 d2d3_v1_sel, 2'b01: video display read interface(DI or vd1 fomart output), 2'b10: scale output, otherwise nothing as v1
// Bit 3 use_vdin_eol, if true, use vdin eol as the v0_eol, otherwise using length to get the v0_eol
// Bit 2:0  d2d3_v0_sel  001: vdin0, 010: vdin1, 011: NRW, 100: video display read interface(DI or vd1 fomart output), 101: vpp scale output
//
#define P_D2D3_INTF_CTRL0                          (volatile unsigned long *)0xd0106824
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU_OSD1_CTRL_STAT                       (volatile unsigned long *)0xd0106840
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU_OSD1_CTRL_STAT2                      (volatile unsigned long *)0xd01068b4
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU_OSD1_COLOR_ADDR                      (volatile unsigned long *)0xd0106844
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD1_COLOR                           (volatile unsigned long *)0xd0106848
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD1_TCOLOR_AG0                      (volatile unsigned long *)0xd010685c
#define P_VIU_OSD1_TCOLOR_AG1                      (volatile unsigned long *)0xd0106860
#define P_VIU_OSD1_TCOLOR_AG2                      (volatile unsigned long *)0xd0106864
#define P_VIU_OSD1_TCOLOR_AG3                      (volatile unsigned long *)0xd0106868
// Bit 31:30 Reserved
// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
// Bit 27:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU_OSD1_BLK0_CFG_W0                     (volatile unsigned long *)0xd010686c
#define P_VIU_OSD1_BLK1_CFG_W0                     (volatile unsigned long *)0xd010687c
#define P_VIU_OSD1_BLK2_CFG_W0                     (volatile unsigned long *)0xd010688c
#define P_VIU_OSD1_BLK3_CFG_W0                     (volatile unsigned long *)0xd010689c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU_OSD1_BLK0_CFG_W1                     (volatile unsigned long *)0xd0106870
#define P_VIU_OSD1_BLK1_CFG_W1                     (volatile unsigned long *)0xd0106880
#define P_VIU_OSD1_BLK2_CFG_W1                     (volatile unsigned long *)0xd0106890
#define P_VIU_OSD1_BLK3_CFG_W1                     (volatile unsigned long *)0xd01068a0
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU_OSD1_BLK0_CFG_W2                     (volatile unsigned long *)0xd0106874
#define P_VIU_OSD1_BLK1_CFG_W2                     (volatile unsigned long *)0xd0106884
#define P_VIU_OSD1_BLK2_CFG_W2                     (volatile unsigned long *)0xd0106894
#define P_VIU_OSD1_BLK3_CFG_W2                     (volatile unsigned long *)0xd01068a4
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU_OSD1_BLK0_CFG_W3                     (volatile unsigned long *)0xd0106878
#define P_VIU_OSD1_BLK1_CFG_W3                     (volatile unsigned long *)0xd0106888
#define P_VIU_OSD1_BLK2_CFG_W3                     (volatile unsigned long *)0xd0106898
#define P_VIU_OSD1_BLK3_CFG_W3                     (volatile unsigned long *)0xd01068a8
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU_OSD1_BLK0_CFG_W4                     (volatile unsigned long *)0xd010684c
#define P_VIU_OSD1_BLK1_CFG_W4                     (volatile unsigned long *)0xd0106850
#define P_VIU_OSD1_BLK2_CFG_W4                     (volatile unsigned long *)0xd0106854
#define P_VIU_OSD1_BLK3_CFG_W4                     (volatile unsigned long *)0xd0106858
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU_OSD1_FIFO_CTRL_STAT                  (volatile unsigned long *)0xd01068ac
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU_OSD1_TEST_RDDATA                     (volatile unsigned long *)0xd01068b0
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU_OSD1_PROT_CTRL                       (volatile unsigned long *)0xd01068b8
//------------------------------------------------------------------------------
// OSD2 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU_OSD2_CTRL_STAT                       (volatile unsigned long *)0xd01068c0
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU_OSD2_CTRL_STAT2                      (volatile unsigned long *)0xd0106934
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU_OSD2_COLOR_ADDR                      (volatile unsigned long *)0xd01068c4
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD2_COLOR                           (volatile unsigned long *)0xd01068c8
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define P_VIU_OSD2_HL1_H_START_END                 (volatile unsigned long *)0xd01068cc
#define P_VIU_OSD2_HL1_V_START_END                 (volatile unsigned long *)0xd01068d0
#define P_VIU_OSD2_HL2_H_START_END                 (volatile unsigned long *)0xd01068d4
#define P_VIU_OSD2_HL2_V_START_END                 (volatile unsigned long *)0xd01068d8
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD2_TCOLOR_AG0                      (volatile unsigned long *)0xd01068dc
#define P_VIU_OSD2_TCOLOR_AG1                      (volatile unsigned long *)0xd01068e0
#define P_VIU_OSD2_TCOLOR_AG2                      (volatile unsigned long *)0xd01068e4
#define P_VIU_OSD2_TCOLOR_AG3                      (volatile unsigned long *)0xd01068e8
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU_OSD2_BLK0_CFG_W0                     (volatile unsigned long *)0xd01068ec
#define P_VIU_OSD2_BLK1_CFG_W0                     (volatile unsigned long *)0xd01068fc
#define P_VIU_OSD2_BLK2_CFG_W0                     (volatile unsigned long *)0xd010690c
#define P_VIU_OSD2_BLK3_CFG_W0                     (volatile unsigned long *)0xd010691c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU_OSD2_BLK0_CFG_W1                     (volatile unsigned long *)0xd01068f0
#define P_VIU_OSD2_BLK1_CFG_W1                     (volatile unsigned long *)0xd0106900
#define P_VIU_OSD2_BLK2_CFG_W1                     (volatile unsigned long *)0xd0106910
#define P_VIU_OSD2_BLK3_CFG_W1                     (volatile unsigned long *)0xd0106920
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU_OSD2_BLK0_CFG_W2                     (volatile unsigned long *)0xd01068f4
#define P_VIU_OSD2_BLK1_CFG_W2                     (volatile unsigned long *)0xd0106904
#define P_VIU_OSD2_BLK2_CFG_W2                     (volatile unsigned long *)0xd0106914
#define P_VIU_OSD2_BLK3_CFG_W2                     (volatile unsigned long *)0xd0106924
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU_OSD2_BLK0_CFG_W3                     (volatile unsigned long *)0xd01068f8
#define P_VIU_OSD2_BLK1_CFG_W3                     (volatile unsigned long *)0xd0106908
#define P_VIU_OSD2_BLK2_CFG_W3                     (volatile unsigned long *)0xd0106918
#define P_VIU_OSD2_BLK3_CFG_W3                     (volatile unsigned long *)0xd0106928
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU_OSD2_BLK0_CFG_W4                     (volatile unsigned long *)0xd0106990
#define P_VIU_OSD2_BLK1_CFG_W4                     (volatile unsigned long *)0xd0106994
#define P_VIU_OSD2_BLK2_CFG_W4                     (volatile unsigned long *)0xd0106998
#define P_VIU_OSD2_BLK3_CFG_W4                     (volatile unsigned long *)0xd010699c
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU_OSD2_FIFO_CTRL_STAT                  (volatile unsigned long *)0xd010692c
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU_OSD2_TEST_RDDATA                     (volatile unsigned long *)0xd0106930
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU_OSD2_PROT_CTRL                       (volatile unsigned long *)0xd0106938
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
#define P_VD1_IF0_GEN_REG                          (volatile unsigned long *)0xd0106940
#define P_VD1_IF0_CANVAS0                          (volatile unsigned long *)0xd0106944
#define P_VD1_IF0_CANVAS1                          (volatile unsigned long *)0xd0106948
#define P_VD1_IF0_LUMA_X0                          (volatile unsigned long *)0xd010694c
#define P_VD1_IF0_LUMA_Y0                          (volatile unsigned long *)0xd0106950
#define P_VD1_IF0_CHROMA_X0                        (volatile unsigned long *)0xd0106954
#define P_VD1_IF0_CHROMA_Y0                        (volatile unsigned long *)0xd0106958
#define P_VD1_IF0_LUMA_X1                          (volatile unsigned long *)0xd010695c
#define P_VD1_IF0_LUMA_Y1                          (volatile unsigned long *)0xd0106960
#define P_VD1_IF0_CHROMA_X1                        (volatile unsigned long *)0xd0106964
#define P_VD1_IF0_CHROMA_Y1                        (volatile unsigned long *)0xd0106968
#define P_VD1_IF0_RPT_LOOP                         (volatile unsigned long *)0xd010696c
#define P_VD1_IF0_LUMA0_RPT_PAT                    (volatile unsigned long *)0xd0106970
#define P_VD1_IF0_CHROMA0_RPT_PAT                  (volatile unsigned long *)0xd0106974
#define P_VD1_IF0_LUMA1_RPT_PAT                    (volatile unsigned long *)0xd0106978
#define P_VD1_IF0_CHROMA1_RPT_PAT                  (volatile unsigned long *)0xd010697c
#define P_VD1_IF0_LUMA_PSEL                        (volatile unsigned long *)0xd0106980
#define P_VD1_IF0_CHROMA_PSEL                      (volatile unsigned long *)0xd0106984
#define P_VD1_IF0_DUMMY_PIXEL                      (volatile unsigned long *)0xd0106988
#define P_VD1_IF0_LUMA_FIFO_SIZE                   (volatile unsigned long *)0xd010698c
#define P_VD1_IF0_RANGE_MAP_Y                      (volatile unsigned long *)0xd01069a8
#define P_VD1_IF0_RANGE_MAP_CB                     (volatile unsigned long *)0xd01069ac
#define P_VD1_IF0_RANGE_MAP_CR                     (volatile unsigned long *)0xd01069b0
#define P_VD1_IF0_GEN_REG2                         (volatile unsigned long *)0xd01069b4
#define P_VD1_IF0_PROT_CNTL                        (volatile unsigned long *)0xd01069b8
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define P_VIU_VD1_FMT_CTRL                         (volatile unsigned long *)0xd01069a0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define P_VIU_VD1_FMT_W                            (volatile unsigned long *)0xd01069a4
//------------------------------------------------------------------------------
// VD2 path
//------------------------------------------------------------------------------
#define P_VD2_IF0_GEN_REG                          (volatile unsigned long *)0xd01069c0
#define P_VD2_IF0_CANVAS0                          (volatile unsigned long *)0xd01069c4
#define P_VD2_IF0_CANVAS1                          (volatile unsigned long *)0xd01069c8
#define P_VD2_IF0_LUMA_X0                          (volatile unsigned long *)0xd01069cc
#define P_VD2_IF0_LUMA_Y0                          (volatile unsigned long *)0xd01069d0
#define P_VD2_IF0_CHROMA_X0                        (volatile unsigned long *)0xd01069d4
#define P_VD2_IF0_CHROMA_Y0                        (volatile unsigned long *)0xd01069d8
#define P_VD2_IF0_LUMA_X1                          (volatile unsigned long *)0xd01069dc
#define P_VD2_IF0_LUMA_Y1                          (volatile unsigned long *)0xd01069e0
#define P_VD2_IF0_CHROMA_X1                        (volatile unsigned long *)0xd01069e4
#define P_VD2_IF0_CHROMA_Y1                        (volatile unsigned long *)0xd01069e8
#define P_VD2_IF0_RPT_LOOP                         (volatile unsigned long *)0xd01069ec
#define P_VD2_IF0_LUMA0_RPT_PAT                    (volatile unsigned long *)0xd01069f0
#define P_VD2_IF0_CHROMA0_RPT_PAT                  (volatile unsigned long *)0xd01069f4
#define P_VD2_IF0_LUMA1_RPT_PAT                    (volatile unsigned long *)0xd01069f8
#define P_VD2_IF0_CHROMA1_RPT_PAT                  (volatile unsigned long *)0xd01069fc
#define P_VD2_IF0_LUMA_PSEL                        (volatile unsigned long *)0xd0106a00
#define P_VD2_IF0_CHROMA_PSEL                      (volatile unsigned long *)0xd0106a04
#define P_VD2_IF0_DUMMY_PIXEL                      (volatile unsigned long *)0xd0106a08
#define P_VD2_IF0_LUMA_FIFO_SIZE                   (volatile unsigned long *)0xd0106a0c
#define P_VD2_IF0_RANGE_MAP_Y                      (volatile unsigned long *)0xd0106a28
#define P_VD2_IF0_RANGE_MAP_CB                     (volatile unsigned long *)0xd0106a2c
#define P_VD2_IF0_RANGE_MAP_CR                     (volatile unsigned long *)0xd0106a30
#define P_VD2_IF0_GEN_REG2                         (volatile unsigned long *)0xd0106a34
#define P_VD2_IF0_PROT_CNTL                        (volatile unsigned long *)0xd0106a38
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define P_VIU_VD2_FMT_CTRL                         (volatile unsigned long *)0xd0106a20
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define P_VIU_VD2_FMT_W                            (volatile unsigned long *)0xd0106a24
//todo add comment
#define P_LDIM_STTS_GCLK_CTRL0                     (volatile unsigned long *)0xd0106a40
#define P_LDIM_STTS_CTRL0                          (volatile unsigned long *)0xd0106a44
#define P_LDIM_STTS_WIDTHM1_HEIGHTM1               (volatile unsigned long *)0xd0106a48
#define P_LDIM_STTS_MATRIX_COEF00_01               (volatile unsigned long *)0xd0106a4c
#define P_LDIM_STTS_MATRIX_COEF02_10               (volatile unsigned long *)0xd0106a50
#define P_LDIM_STTS_MATRIX_COEF11_12               (volatile unsigned long *)0xd0106a54
#define P_LDIM_STTS_MATRIX_COEF20_21               (volatile unsigned long *)0xd0106a58
#define P_LDIM_STTS_MATRIX_COEF22                  (volatile unsigned long *)0xd0106a5c
#define P_LDIM_STTS_MATRIX_OFFSET0_1               (volatile unsigned long *)0xd0106a60
#define P_LDIM_STTS_MATRIX_OFFSET2                 (volatile unsigned long *)0xd0106a64
#define P_LDIM_STTS_MATRIX_PRE_OFFSET0_1           (volatile unsigned long *)0xd0106a68
#define P_LDIM_STTS_MATRIX_PRE_OFFSET2             (volatile unsigned long *)0xd0106a6c
#define P_LDIM_STTS_MATRIX_HL_COLOR                (volatile unsigned long *)0xd0106a70
#define P_LDIM_STTS_MATRIX_PROBE_POS               (volatile unsigned long *)0xd0106a74
//read only
#define P_LDIM_STTS_MATRIX_PROBE_COLOR             (volatile unsigned long *)0xd0106a78
//Bit 31, local dimming statistic enable
//Bit 29, 1: output region histogram 16bit 0:output region histogram 20bit 
//Bit 28, eol enable
//Bit 27:25, vertical line overlap number for max finding
//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//Bit 15:14, 1: region read index auto increase per block read finished to VDIN_LDIM_STTS_HIST_READ_REGION 
//			 2: region read index auto increase per read finished to VDIN_LDIM_STTS_HIST_READ_REGION
//			 0/3: disable read index self increase
//Bit 13:8, region read sub index, which mux the hist & max-finding result to cbus port, refer to LDIM_STTS_HIST_READ_REGION
//Bit 6:0, region read index
#define P_LDIM_STTS_HIST_REGION_IDX                (volatile unsigned long *)0xd0106a80
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
#define P_LDIM_STTS_HIST_SET_REGION                (volatile unsigned long *)0xd0106a84
//if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data. 
//if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0. 
//output sequence as rd_sub_idx from 0~47: {max_comp2, comp0_hist0}, {max_comp1, comp0_hist1}, {max_comp0, comp0_hist2}, 
//										   comp0_hist3 ... comp2_hist16
//if LDIM_STTS_HIST_REGION_IDX[29] == 1, that is output hist with 16bit data. 
//if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0. 
//output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//										   comp0_hist3 ... comp2_hist16
//if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data. 
//if LDIM_STTS_HIST_REGION_IDX[21] == 1, that is output 32hist bins in comp 0. 
//output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//										   comp0_hist3 ...comp0_hist31 ... comp1_hist16
#define P_LDIM_STTS_HIST_READ_REGION               (volatile unsigned long *)0xd0106a88
//DEINTERLACE module start from 8'h90 end to 8'hff
// -----------------------------------------------
// CBUS_BASE:  MAD_VCBUS_BASE = 0x17
// -----------------------------------------------
#define P_DI_PRE_CTRL                              (volatile unsigned long *)0xd0105c00
// bit 31,      cbus_pre_frame_rst
// bit 30,      cbus_pre_soft_rst
// bit 29,      pre_field_num 
// bit 25,      di_cont_read_en
// bit 22,      mtn_after_nr
// bit 21:16,   pre_hold_fifo_lines
// bit 15,      nr_wr_by
// bit 14,      use_vdin_go_line
// bit 13,      di_prevdin_en
// bit 12,      di_pre_viu_link
// bit 11,      di_pre_repeat
// bit 10,      di_pre_drop_1st
// bit  9,      di_buf2_en
// bit  8,      di_chan2_en
// bit  7,      prenr_hist_en
// bit  6,      chan2_hist_en
// bit  5,      hist_check_en
// bit  4,      check_after_nr
// bit  3,      check222p_en
// bit  2,      check322p_en
// bit  1,      mtn_en
// bit  0,      nr_en
#define P_DI_POST_CTRL                             (volatile unsigned long *)0xd0105c04
// bit 31,      cbus_post_frame_rst
// bit 30,      cbus_post_soft_rst
// bit 29,      post_field_num
// bit 21:16,   post_hold_fifo_lines
// bit 13,      prepost_link
// bit 12,      di_post_viu_link
// bit 11,      di_post_repeat
// bit 10,      di_post_drop_1st
// bit  9,      mif0_to_vpp_en
// bit  8,      di_vpp_out_en
// bit  7,      di_wr_bk_en
// bit  6,      di_mux_en
// bit  5,      di_blend_en
// bit  4,      di_mtnp_read_en
// bit  3,      di_mtn_buf_en
// bit  2,      di_ei_en
// bit  1,      di_buf1_en
// bit  0,      di_buf0_en
#define P_DI_POST_SIZE                             (volatile unsigned long *)0xd0105c08
//bit 28:16,    vsize1post
//bit 12:0,     hsize1post
#define P_DI_PRE_SIZE                              (volatile unsigned long *)0xd0105c0c
//bit 28:16,    vsize1pre
//bit 12:0,     hsize1pre
#define P_DI_EI_CTRL0                              (volatile unsigned long *)0xd0105c10
//bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter && ...right>filter && ...top>filter && ...bot>filter -> filter
//bit 15:8,     ei0_threshold[2:+] 
//bit 3,        ei0_vertical
//bit 2,        ei0_bpscf2
//bit 1,        ei0_bpsfar1
#define P_DI_EI_CTRL1                              (volatile unsigned long *)0xd0105c14
//bit 31:24,    ei0_diff
//bit 23:16,    ei0_angle45
//bit 15:8,     ei0_peak
//bit 7:0,      ei0_cross
#define P_DI_EI_CTRL2                              (volatile unsigned long *)0xd0105c18
//bit 31:24,    ei0_close2
//bit 23:16,    ei0_close1
//bit 15:8,     ei0_far2
//bit 7:0,      ei0_far1
#define P_DI_NR_CTRL0                              (volatile unsigned long *)0xd0105c1c
//bit 26,       nr_cue_en
//bit 25,       nr2_en
#define P_DI_NR_CTRL1                              (volatile unsigned long *)0xd0105c20
//bit 31:30,    mot_p1txtcore_mode  
//bit 29:24,    mot_p1txtcore_clmt  
//bit 21:16,    mot_p1txtcore_ylmt  
//bit 15:8,     mot_p1txtcore_crate  
//bit 7:0,      mot_p1txtcore_yrate  
#define P_DI_NR_CTRL2                              (volatile unsigned long *)0xd0105c24
//bit 29:24,    mot_curtxtcore_clmt  
//bit 21:16,    mot_curtxtcore_ylmt  
//bit 15:8,     mot_curtxtcore_crate  
//bit 7:0,      mot_curtxtcore_yrate  
#define P_DI_NR_CTRL3                              (volatile unsigned long *)0xd0105c28
//no use
#define P_DI_MTN_CTRL                              (volatile unsigned long *)0xd0105c2c
//bit 31,      mtn_lpfen         
//bit 30,      mtn_uven         
//bit 29,      mtn_modify_en    
//bit 28:24,   mtn_char_diff_cnt
//bit 23:16,   mtn_low_level    
//bit 15:8,    mtn_high_level   
//bit 7:0,     mtn_diff_level   
#define P_DI_MTN_CTRL1                             (volatile unsigned long *)0xd0105c30
//bit 9:8,     mtn_shift
//bit 7:0,     mtn_reduce
#define P_DI_BLEND_CTRL                            (volatile unsigned long *)0xd0105c34
//bit 31,      blend_1_en         
//bit 30,      blend_mtn_lpf      
//bit 28,      post_mb_en         
//bit 27,      blend_mtn3p_max    
//bit 26,      blend_mtn3p_min    
//bit 25,      blend_mtn3p_ave    
//bit 24,      blend_mtn3p_maxtb  
//bit 23,      blend_mtn_flt_en   
//bit 22,      blend_data_flt_en  
//bit 21:20,   blend_top_mode     
//bit 19,      blend_reg3_enable  
//bit 18,      blend_reg2_enable  
//bit 17,      blend_reg1_enable  
//bit 16,      blend_reg0_enable  
//bit 15:14,   blend_reg3_mode    
//bit 13:12,   blend_reg2_mode    
//bit 11:10,   blend_reg1_mode    
//bit 9:8,     blend_reg0_mode    
//bit 7:0,     kdeint             
#define P_DI_BLEND_CTRL1                           (volatile unsigned long *)0xd0105c38
//bit 31:24,   blend_char_level
//bit 23:16,   blend_angle_thd 
//bit 15:8,    blend_filt_thd  
//bit 7:0,     blend_diff_thd  
#define P_DI_BLEND_CTRL2                           (volatile unsigned long *)0xd0105c3c
//bit 11:8,    blend_mtn_no_mov
//bit 7:0,     blend_black_level
#define P_DI_BLEND_REG0_X                          (volatile unsigned long *)0xd0105c40
//bit 27:16,   blend_reg0_startx
//bit 11:0,    blend_reg0_endx
#define P_DI_BLEND_REG0_Y                          (volatile unsigned long *)0xd0105c44
#define P_DI_BLEND_REG1_X                          (volatile unsigned long *)0xd0105c48
#define P_DI_BLEND_REG1_Y                          (volatile unsigned long *)0xd0105c4c
#define P_DI_BLEND_REG2_X                          (volatile unsigned long *)0xd0105c50
#define P_DI_BLEND_REG2_Y                          (volatile unsigned long *)0xd0105c54
#define P_DI_BLEND_REG3_X                          (volatile unsigned long *)0xd0105c58
#define P_DI_BLEND_REG3_Y                          (volatile unsigned long *)0xd0105c5c
#define P_DI_CLKG_CTRL                             (volatile unsigned long *)0xd0105c60
//bit 31:24,   pre_gclk_ctrl
//bit 23:16,   post_gclk_ctrl
//bit 1,       di_gate_all
//bit 0,       di_no_clk_gate
#define P_DI_EI_CTRL3                              (volatile unsigned long *)0xd0105c64
//bit 31,      reg_ei_1
//bit 30,      reg_demon_en
//bit 26:24,   reg_demon_mux
//bit 23:20,   reg_right_win
//bit 19:16,   reg_left_win
//bit 7:4,     reg_ei_sadm_quatize_margin
//bit 1:0,     reg_ei_sad_relative_mode
#define P_DI_EI_CTRL4                              (volatile unsigned long *)0xd0105c68
//bit 29,      reg_ei_caldrt_ambliike2_biasvertical
//bit 28:24,   reg_ei_caldrt_addxla2list_drtmax
//bit 22:20,   reg_ei_caldrt_addxla2list_signm0th
//bit 19,      reg_ei_caldrt_addxla2list_mode
//bit 18:16,   reg_ei_signm_sad_cor_rate
//bit 15:12,   reg_ei_signm_sadi_cor_rate
//bit 11:6,    reg_ei_signm_sadi_cor_ofst
//bit 5:0,     reg_ei_signm_sad_ofst
#define P_DI_EI_CTRL5                              (volatile unsigned long *)0xd0105c6c
//bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd
//bit 26:24,   reg_ei_caldrt_cnflctchk_mg
//bit 23:22,   reg_ei_caldrt_cnflctchk_ws
//bit 21,      reg_ei_caldrt_cnflctchk_en
//bit 20,      reg_ei_caldrt_verfrc_final_en
//bit 19,      reg_ei_caldrt_verfrc_retimflt_en
//bit 18:16,   reg_ei_caldrt_verftc_eithratemth
//bit 15,      reg_ei_caldrt_verfrc_retiming_en
//bit 14:12,   reg_ei_caldrt_verfrc_bothratemth
//bit 11:9,    reg_ei_caldrt_ver_thrd
//bit 8:4,     reg_ei_caldrt_addxla2list_drtmin
//bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit
#define P_DI_EI_CTRL6                              (volatile unsigned long *)0xd0105c70
//bit 31:24,   reg_ei_caldrt_abext_sad12thhig
//bit 23:16,   reg_ei_caldrt_abext_sad00thlow
//bit 15:8,    reg_ei_caldrt_abext_sad12thlow
//bit 6:4,     reg_ei_caldrt_abext_ratemth
//bit 2:0,     reg_ei_caldrt_abext_drtthrd
#define P_DI_EI_CTRL7                              (volatile unsigned long *)0xd0105c74
//bit 29,      reg_ei_caldrt_xlanopeak_codien
//bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax
//bit 23,      reg_ei_caldrt_xlanopeak_en
//bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha
//bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd
//bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd
//bit 28:24,   reg_ei_caldrt_abext_sad00rate
//bit 28:24,   reg_ei_caldrt_abext_sad12rate
//bit 28:24,   reg_ei_caldrt_abext_sad00thhig          
#define P_DI_EI_CTRL8                              (volatile unsigned long *)0xd0105c78
//bit 30:28,   reg_ei_assign_headtail_magin
//bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode
//bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth
//bit 20,      reg_ei_caldrt_histchk_cnfid
//bit 19:16,   reg_ei_caldrt_histchk_thrd
//bit 15,      reg_ei_caldrt_histchk_abext
//bit 14,      reg_ei_caldrt_histchk_npen
//bit 13:11,   reg_ei_caldrt_amblike2_drtmg
//bit 10:8,    reg_ei_caldrt_amblike2_valmg
//bit 7:4,     reg_ei_caldrt_amblike2_alpha
//bit 3:0,     reg_ei_caldrt_amblike2_drtth
#define P_DI_EI_CTRL9                              (volatile unsigned long *)0xd0105c7c
//bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3
//bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en
//bit 26:24,   reg_ei_caldrt_conf_drtth
//bit 23:20,   reg_ei_caldrt_conf_absdrtth
//bit 19:18,   reg_ei_caldrt_abcheck_mode1
//bit 17:16,   reg_ei_caldrt_abcheck_mode0
//bit 15:12,   reg_ei_caldrt_abcheck_drth1
//bit 11:8,    reg_ei_caldrt_abcheck_drth0
//bit 6:4,     reg_ei_caldrt_abpnchk1_th
//bit 1,       reg_ei_caldrt_abpnchk1_en
//bit 0,       reg_ei_caldrt_abpnchk0_en
#define P_DI_EI_CTRL10                             (volatile unsigned long *)0xd0105e4c
//bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth
//bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd
//bit 23:20,   reg_ei_caldrt_hstrrgchk_mg
//bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul
//bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf
//bit 17:16,   reg_ei_caldrt_hstrrgchk_ws
//bit 15,      reg_ei_caldrt_hstrrgchk_en
//bit 14:13,   reg_ei_caldrt_hpncheck_mode
//bit 12,      reg_ei_caldrt_hpncheck_mute
//bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2
//bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1
//bit 5:4,     reg_ei_caldrt_hcnfcheck_mode
//bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2
#define P_DI_EI_CTRL11                             (volatile unsigned long *)0xd0105e78
//bit 30:29,   reg_ei_amb_detect_mode
//bit 28:24,   reg_ei_amb_detect_winth
//bit 23:21,   reg_ei_amb_decide_rppth
//bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth
//bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode
//bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode
//bit 13:12,   reg_ei_retime_lastvertfrcchk_mode
//bit 11:8,    reg_ei_retime_lastpnchk_drtth
//bit 6,       reg_ei_retime_lastpnchk_en
//bit 5:4,     reg_ei_retime_mode
//bit 3,       reg_ei_retime_last_en
//bit 2,       reg_ei_retime_ab_en
//bit 1,       reg_ei_caldrt_hstrvertfrcchk_en
//bit 0,       reg_ei_caldrt_hstrrgchk_mode
#define P_DI_EI_CTRL12                             (volatile unsigned long *)0xd0105e7c
//bit 31:28,   reg_ei_drtdelay2_lmt
//bit 27:26,   reg_ei_drtdelay2_notver_lrwin
//bit 25:24,   reg_ei_drtdelay_mode
//bit 23,      reg_ei_drtdelay2_mode
//bit 22:20,   reg_ei_assign_xla_signm0th
//bit 19,      reg_ei_assign_pkbiasvert_en
//bit 18,      reg_ei_assign_xla_en
//bit 17:16,   reg_ei_assign_xla_mode
//bit 15:12,   reg_ei_assign_nlfilter_magin
//bit 11:8,    reg_ei_localsearch_maxrange
//bit 7:4,     reg_ei_xla_drtth
//bit 3:0,     reg_ei_flatmsad_thrd
#define P_DI_EI_CTRL13                             (volatile unsigned long *)0xd0105ea0
//bit 27:24,   reg_ei_int_drt2x_chrdrt_limit
//bit 23:20,   reg_ei_int_drt16x_core
//bit 19:16,   reg_ei_int_drtdelay2_notver_cancv
//bit 15:8,    reg_ei_int_drtdelay2_notver_sadth
//bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth
#define P_DI_EI_XWIN0                              (volatile unsigned long *)0xd0105e60
//bit 27:16,   ei_xend0
//bit 11:0,    ei_xstart0
#define P_DI_EI_XWIN1                              (volatile unsigned long *)0xd0105e64
// DEINTERLACE mode check.
#define P_DI_MC_REG0_X                             (volatile unsigned long *)0xd0105c80
//bit 27:16,   mc_reg0_start_x 
//bit 11:0,    mc_reg0_end_x 
#define P_DI_MC_REG0_Y                             (volatile unsigned long *)0xd0105c84
#define P_DI_MC_REG1_X                             (volatile unsigned long *)0xd0105c88
#define P_DI_MC_REG1_Y                             (volatile unsigned long *)0xd0105c8c
#define P_DI_MC_REG2_X                             (volatile unsigned long *)0xd0105c90
#define P_DI_MC_REG2_Y                             (volatile unsigned long *)0xd0105c94
#define P_DI_MC_REG3_X                             (volatile unsigned long *)0xd0105c98
#define P_DI_MC_REG3_Y                             (volatile unsigned long *)0xd0105c9c
#define P_DI_MC_REG4_X                             (volatile unsigned long *)0xd0105ca0
#define P_DI_MC_REG4_Y                             (volatile unsigned long *)0xd0105ca4
#define P_DI_MC_32LVL0                             (volatile unsigned long *)0xd0105ca8
//bit 31:24,   mc_reg2_32lvl
//bit 23:16,   mc_reg1_32lvl
//bit 15:8,    mc_reg0_32lvl
//bit 7:0,     field_32lvl
#define P_DI_MC_32LVL1                             (volatile unsigned long *)0xd0105cac
//bit 15:8,    mc_reg3_32lvl
//bit 7:0,     mc_reg4_32lvl
#define P_DI_MC_22LVL0                             (volatile unsigned long *)0xd0105cb0
//bit 31:16,   mc_reg0_22lvl
//bit 15:0,    field_22lvl
#define P_DI_MC_22LVL1                             (volatile unsigned long *)0xd0105cb4
//bit 31:16,   mc_reg2_22lvl
//bit 15:0,    mc_reg1_22lvl
#define P_DI_MC_22LVL2                             (volatile unsigned long *)0xd0105cb8
//bit 31:16,   mc_reg4_22lvl
//bit 15:0,    mc_reg3_22lvl
#define P_DI_MC_CTRL                               (volatile unsigned long *)0xd0105cbc
//bit 4,       mc_reg4_en 
//bit 3,       mc_reg3_en 
//bit 2,       mc_reg2_en 
//bit 1,       mc_reg1_en 
//bit 0,       mc_reg0_en 
#define P_DI_INTR_CTRL                             (volatile unsigned long *)0xd0105cc0
#define P_DI_INFO_ADDR                             (volatile unsigned long *)0xd0105cc4
#define P_DI_INFO_DATA                             (volatile unsigned long *)0xd0105cc8
#define P_DI_PRE_HOLD                              (volatile unsigned long *)0xd0105ccc
#define P_DI_MTN_1_CTRL1                           (volatile unsigned long *)0xd0105d00
//bit 31,      mtn_1_en
//bit 30,      mtn_init
//bit 29,      di2nr_txt_en
//bit 28,      di2nr_txt_mode
//bit 27:24,   mtn_def
//bit 23:16,   mtn_adp_yc
//bit 15:8,    mtn_adp_2c
//bit 7:0,     mtn_adp_2y
#define P_DI_MTN_1_CTRL2                           (volatile unsigned long *)0xd0105d04
//bit 31:24,   mtn_ykinter
//bit 23:16,   mtn_ckinter
//bit 15:8,    mtn_ykintra
//bit  7:0,    mtn_ckintra
#define P_DI_MTN_1_CTRL3                           (volatile unsigned long *)0xd0105d08
//bit 31:24,   mtn_tyrate 
//bit 23:16,   mtn_tcrate
//bit 15: 8,   mtn_mxcmby
//bit  7: 0,   mtn_mxcmbc
#define P_DI_MTN_1_CTRL4                           (volatile unsigned long *)0xd0105d0c
//bit 31:24,   mtn_tcorey
//bit 23:16,   mtn_tcorec
//bit 15: 8,   mtn_minth
//bit  7: 0,   mtn_maxth
#define P_DI_MTN_1_CTRL5                           (volatile unsigned long *)0xd0105d10
//bit 31:24,   mtn_m1b_extnd
//bit 23:16,   mtn_m1b_extndmtn_m1b_errod
//bit 15: 8,   mtn_m1b_extndmtn_core_ykinter
//bit  7: 0,   mtn_m1b_extndmtn_core_ckinter
#define P_DI_MTN_1_CTRL6                           (volatile unsigned long *)0xd0105ea4
//bit 31:24,   mtn_m1b_extnd
//bit 23:16,   mtn_m1b_extndmtn_m1b_errod
//bit 15: 8,   mtn_m1b_extndmtn_core_ykinter
//bit  7: 0,   mtn_m1b_extndmtn_core_ckinter
#define P_DI_MTN_1_CTRL7                           (volatile unsigned long *)0xd0105ea8
//bit 31:24,   mtn_core_mxcmby
//bit 23:16,   mtn_core_mxcmbc
//bit 15: 8,   mtn_core_y     
//bit  7: 0,   mtn_core_c     
#define P_DI_MTN_1_CTRL8                           (volatile unsigned long *)0xd0105eac
//bit 31:24,   mtn_fcore_ykinter
//bit 23:16,   mtn_fcore_ckinter
//bit 15: 8,   mtn_fcore_ykintra
//bit  7: 0,   mtn_fcore_ckintra
#define P_DI_MTN_1_CTRL9                           (volatile unsigned long *)0xd0105eb0
//bit 31:24,   mtn_fcore_2yrate 
//bit 23:16,   mtn_fcore_2crate
//bit 15: 8,   mtn_fcore_y     
//bit  7: 0,   mtn_fcore_c     
#define P_DI_MTN_1_CTRL10                          (volatile unsigned long *)0xd0105eb4
//bit 27:24,   mtn_motfld0 
//bit 19:16,   mtn_stlfld0  
//bit 11: 8,   mtn_motfld1  
//bit  3: 0,   mtn_stlfld1  
#define P_DI_MTN_1_CTRL11                          (volatile unsigned long *)0xd0105eb8
//bit 27:24,   mtn_smotevn
//bit 20:16,   mtn_smotodd
//bit 11: 8,   mtn_sstlevn
//bit  4: 0,   mtn_sstlodd
#define P_DI_MTN_1_CTRL12                          (volatile unsigned long *)0xd0105ebc
//bit 31:24,   mtn_mgain
//bit 17:16,   mtn_mmode
//bit 15: 8,   mtn_sthrd
//bit  4: 0,   mtn_sgain
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f
#define P_DET3D_MOTN_CFG                           (volatile unsigned long *)0xd0105cd0
#define P_DET3D_CB_CFG                             (volatile unsigned long *)0xd0105cd4
#define P_DET3D_SPLT_CFG                           (volatile unsigned long *)0xd0105cd8
#define P_DET3D_HV_MUTE                            (volatile unsigned long *)0xd0105cdc
#define P_DET3D_MAT_STA_P1M1                       (volatile unsigned long *)0xd0105ce0
#define P_DET3D_MAT_STA_P1TH                       (volatile unsigned long *)0xd0105ce4
#define P_DET3D_MAT_STA_M1TH                       (volatile unsigned long *)0xd0105ce8
#define P_DET3D_MAT_STA_RSFT                       (volatile unsigned long *)0xd0105cec
#define P_DET3D_MAT_SYMTC_TH                       (volatile unsigned long *)0xd0105cf0
#define P_DET3D_RO_DET_CB_HOR                      (volatile unsigned long *)0xd0105cf4
#define P_DET3D_RO_DET_CB_VER                      (volatile unsigned long *)0xd0105cf8
#define P_DET3D_RO_SPLT_HT                         (volatile unsigned long *)0xd0105cfc
//// DET 3D REG DEFINE END ////
//// NR2 REG DEFINE BEGIN////
#define P_NR2_MET_NM_CTRL                          (volatile unsigned long *)0xd0105d14
#define P_NR2_MET_NM_YCTRL                         (volatile unsigned long *)0xd0105d18
#define P_NR2_MET_NM_CCTRL                         (volatile unsigned long *)0xd0105d1c
#define P_NR2_MET_NM_TNR                           (volatile unsigned long *)0xd0105d20
#define P_NR2_MET_NMFRM_TNR_YLEV                   (volatile unsigned long *)0xd0105d24
#define P_NR2_MET_NMFRM_TNR_YCNT                   (volatile unsigned long *)0xd0105d28
#define P_NR2_MET_NMFRM_TNR_CLEV                   (volatile unsigned long *)0xd0105d2c
#define P_NR2_MET_NMFRM_TNR_CCNT                   (volatile unsigned long *)0xd0105d30
#define P_NR2_3DEN_MODE                            (volatile unsigned long *)0xd0105d34
#define P_NR2_IIR_CTRL                             (volatile unsigned long *)0xd0105d38
#define P_NR2_SW_EN                                (volatile unsigned long *)0xd0105d3c
#define P_NR2_FRM_SIZE                             (volatile unsigned long *)0xd0105d40
#define P_NR2_SNR_SAD_CFG                          (volatile unsigned long *)0xd0105d44
#define P_NR2_MATNR_SNR_OS                         (volatile unsigned long *)0xd0105d48
#define P_NR2_MATNR_SNR_NRM_CFG                    (volatile unsigned long *)0xd0105d4c
#define P_NR2_MATNR_SNR_NRM_GAIN                   (volatile unsigned long *)0xd0105d50
#define P_NR2_MATNR_SNR_LPF_CFG                    (volatile unsigned long *)0xd0105d54
#define P_NR2_MATNR_SNR_USF_GAIN                   (volatile unsigned long *)0xd0105d58
#define P_NR2_MATNR_SNR_EDGE2B                     (volatile unsigned long *)0xd0105d5c
#define P_NR2_MATNR_BETA_EGAIN                     (volatile unsigned long *)0xd0105d60
#define P_NR2_MATNR_BETA_BRT                       (volatile unsigned long *)0xd0105d64
#define P_NR2_MATNR_XBETA_CFG                      (volatile unsigned long *)0xd0105d68
#define P_NR2_MATNR_YBETA_SCL                      (volatile unsigned long *)0xd0105d6c
#define P_NR2_MATNR_CBETA_SCL                      (volatile unsigned long *)0xd0105d70
#define P_NR2_SNR_MASK                             (volatile unsigned long *)0xd0105d74
#define P_NR2_SAD2NORM_LUT0                        (volatile unsigned long *)0xd0105d78
#define P_NR2_SAD2NORM_LUT1                        (volatile unsigned long *)0xd0105d7c
#define P_NR2_SAD2NORM_LUT2                        (volatile unsigned long *)0xd0105d80
#define P_NR2_SAD2NORM_LUT3                        (volatile unsigned long *)0xd0105d84
#define P_NR2_EDGE2BETA_LUT0                       (volatile unsigned long *)0xd0105d88
#define P_NR2_EDGE2BETA_LUT1                       (volatile unsigned long *)0xd0105d8c
#define P_NR2_EDGE2BETA_LUT2                       (volatile unsigned long *)0xd0105d90
#define P_NR2_EDGE2BETA_LUT3                       (volatile unsigned long *)0xd0105d94
#define P_NR2_MOTION2BETA_LUT0                     (volatile unsigned long *)0xd0105d98
#define P_NR2_MOTION2BETA_LUT1                     (volatile unsigned long *)0xd0105d9c
#define P_NR2_MOTION2BETA_LUT2                     (volatile unsigned long *)0xd0105da0
#define P_NR2_MOTION2BETA_LUT3                     (volatile unsigned long *)0xd0105da4
#define P_NR2_MATNR_MTN_CRTL                       (volatile unsigned long *)0xd0105da8
#define P_NR2_MATNR_MTN_CRTL2                      (volatile unsigned long *)0xd0105dac
#define P_NR2_MATNR_MTN_COR                        (volatile unsigned long *)0xd0105db0
#define P_NR2_MATNR_MTN_GAIN                       (volatile unsigned long *)0xd0105db4
#define P_NR2_MATNR_DEGHOST                        (volatile unsigned long *)0xd0105db8
#define P_NR2_MATNR_ALPHALP_LUT0                   (volatile unsigned long *)0xd0105dbc
#define P_NR2_MATNR_ALPHALP_LUT1                   (volatile unsigned long *)0xd0105dc0
#define P_NR2_MATNR_ALPHALP_LUT2                   (volatile unsigned long *)0xd0105dc4
#define P_NR2_MATNR_ALPHALP_LUT3                   (volatile unsigned long *)0xd0105dc8
#define P_NR2_MATNR_ALPHAHP_LUT0                   (volatile unsigned long *)0xd0105dcc
#define P_NR2_MATNR_ALPHAHP_LUT1                   (volatile unsigned long *)0xd0105dd0
#define P_NR2_MATNR_ALPHAHP_LUT2                   (volatile unsigned long *)0xd0105dd4
#define P_NR2_MATNR_ALPHAHP_LUT3                   (volatile unsigned long *)0xd0105dd8
#define P_NR2_MATNR_MTNB_BRT                       (volatile unsigned long *)0xd0105ddc
#define P_NR2_CUE_MODE                             (volatile unsigned long *)0xd0105de0
#define P_NR2_CUE_CON_MOT_TH                       (volatile unsigned long *)0xd0105de4
#define P_NR2_CUE_CON_DIF0                         (volatile unsigned long *)0xd0105de8
#define P_NR2_CUE_CON_DIF1                         (volatile unsigned long *)0xd0105dec
#define P_NR2_CUE_CON_DIF2                         (volatile unsigned long *)0xd0105df0
#define P_NR2_CUE_CON_DIF3                         (volatile unsigned long *)0xd0105df4
#define P_NR2_CUE_PRG_DIF                          (volatile unsigned long *)0xd0105df8
#define P_NR2_CONV_MODE                            (volatile unsigned long *)0xd0105dfc
//// NR2 REG DEFINE END ////
//// DET 3D REG DEFINE BEGIN ////
////  8'h80~8'h8f
#define P_DET3D_RO_SPLT_HB                         (volatile unsigned long *)0xd0105e00
#define P_DET3D_RO_SPLT_VL                         (volatile unsigned long *)0xd0105e04
#define P_DET3D_RO_SPLT_VR                         (volatile unsigned long *)0xd0105e08
#define P_DET3D_RO_MAT_LUMA_LR                     (volatile unsigned long *)0xd0105e0c
#define P_DET3D_RO_MAT_LUMA_TB                     (volatile unsigned long *)0xd0105e10
#define P_DET3D_RO_MAT_CHRU_LR                     (volatile unsigned long *)0xd0105e14
#define P_DET3D_RO_MAT_CHRU_TB                     (volatile unsigned long *)0xd0105e18
#define P_DET3D_RO_MAT_CHRV_LR                     (volatile unsigned long *)0xd0105e1c
#define P_DET3D_RO_MAT_CHRV_TB                     (volatile unsigned long *)0xd0105e20
#define P_DET3D_RO_MAT_HEDG_LR                     (volatile unsigned long *)0xd0105e24
#define P_DET3D_RO_MAT_HEDG_TB                     (volatile unsigned long *)0xd0105e28
#define P_DET3D_RO_MAT_VEDG_LR                     (volatile unsigned long *)0xd0105e2c
#define P_DET3D_RO_MAT_VEDG_TB                     (volatile unsigned long *)0xd0105e30
#define P_DET3D_RO_MAT_MOTN_LR                     (volatile unsigned long *)0xd0105e34
#define P_DET3D_RO_MAT_MOTN_TB                     (volatile unsigned long *)0xd0105e38
#define P_DET3D_RO_FRM_MOTN                        (volatile unsigned long *)0xd0105e3c
/// mat ram read enter addr
#define P_DET3D_RAMRD_ADDR_PORT                    (volatile unsigned long *)0xd0105e68
#define P_DET3D_RAMRD_DATA_PORT                    (volatile unsigned long *)0xd0105e6c
#define P_NR2_CFR_PARA_CFG0                        (volatile unsigned long *)0xd0105e70
#define P_NR2_CFR_PARA_CFG1                        (volatile unsigned long *)0xd0105e74
//// DET 3D REG DEFINE END ////
#define P_DI_NR_1_CTRL0                            (volatile unsigned long *)0xd0105e50
#define P_DI_NR_1_CTRL1                            (volatile unsigned long *)0xd0105e54
#define P_DI_NR_1_CTRL2                            (volatile unsigned long *)0xd0105e58
#define P_DI_NR_1_CTRL3                            (volatile unsigned long *)0xd0105e5c
#define P_DI_CONTWR_X                              (volatile unsigned long *)0xd0105e80
#define P_DI_CONTWR_Y                              (volatile unsigned long *)0xd0105e84
#define P_DI_CONTWR_CTRL                           (volatile unsigned long *)0xd0105e88
#define P_DI_CONTPRD_X                             (volatile unsigned long *)0xd0105e8c
#define P_DI_CONTPRD_Y                             (volatile unsigned long *)0xd0105e90
#define P_DI_CONTP2RD_X                            (volatile unsigned long *)0xd0105e94
#define P_DI_CONTP2RD_Y                            (volatile unsigned long *)0xd0105e98
#define P_DI_CONTRD_CTRL                           (volatile unsigned long *)0xd0105e9c
#define P_DI_NRWR_X                                (volatile unsigned long *)0xd0105f00
#define P_DI_NRWR_Y                                (volatile unsigned long *)0xd0105f04
#define P_DI_NRWR_CTRL                             (volatile unsigned long *)0xd0105f08
#define P_DI_MTNWR_X                               (volatile unsigned long *)0xd0105f0c
#define P_DI_MTNWR_Y                               (volatile unsigned long *)0xd0105f10
#define P_DI_MTNWR_CTRL                            (volatile unsigned long *)0xd0105f14
#define P_DI_DIWR_X                                (volatile unsigned long *)0xd0105f18
#define P_DI_DIWR_Y                                (volatile unsigned long *)0xd0105f1c
#define P_DI_DIWR_CTRL                             (volatile unsigned long *)0xd0105f20
#define P_DI_MTNCRD_X                              (volatile unsigned long *)0xd0105f24
#define P_DI_MTNCRD_Y                              (volatile unsigned long *)0xd0105f28
#define P_DI_MTNPRD_X                              (volatile unsigned long *)0xd0105f2c
#define P_DI_MTNPRD_Y                              (volatile unsigned long *)0xd0105f30
#define P_DI_MTNRD_CTRL                            (volatile unsigned long *)0xd0105f34
#define P_DI_INP_GEN_REG                           (volatile unsigned long *)0xd0105f38
#define P_DI_INP_CANVAS0                           (volatile unsigned long *)0xd0105f3c
#define P_DI_INP_LUMA_X0                           (volatile unsigned long *)0xd0105f40
#define P_DI_INP_LUMA_Y0                           (volatile unsigned long *)0xd0105f44
#define P_DI_INP_CHROMA_X0                         (volatile unsigned long *)0xd0105f48
#define P_DI_INP_CHROMA_Y0                         (volatile unsigned long *)0xd0105f4c
#define P_DI_INP_RPT_LOOP                          (volatile unsigned long *)0xd0105f50
#define P_DI_INP_LUMA0_RPT_PAT                     (volatile unsigned long *)0xd0105f54
#define P_DI_INP_CHROMA0_RPT_PAT                   (volatile unsigned long *)0xd0105f58
#define P_DI_INP_DUMMY_PIXEL                       (volatile unsigned long *)0xd0105f5c
#define P_DI_INP_LUMA_FIFO_SIZE                    (volatile unsigned long *)0xd0105f60
#define P_DI_INP_RANGE_MAP_Y                       (volatile unsigned long *)0xd0105ee8
#define P_DI_INP_RANGE_MAP_CB                      (volatile unsigned long *)0xd0105eec
#define P_DI_INP_RANGE_MAP_CR                      (volatile unsigned long *)0xd0105ef0
#define P_DI_INP_GEN_REG2                          (volatile unsigned long *)0xd0105e44
#define P_DI_INP_FMT_CTRL                          (volatile unsigned long *)0xd0105f64
#define P_DI_INP_FMT_W                             (volatile unsigned long *)0xd0105f68
#define P_DI_MEM_GEN_REG                           (volatile unsigned long *)0xd0105f6c
#define P_DI_MEM_CANVAS0                           (volatile unsigned long *)0xd0105f70
#define P_DI_MEM_LUMA_X0                           (volatile unsigned long *)0xd0105f74
#define P_DI_MEM_LUMA_Y0                           (volatile unsigned long *)0xd0105f78
#define P_DI_MEM_CHROMA_X0                         (volatile unsigned long *)0xd0105f7c
#define P_DI_MEM_CHROMA_Y0                         (volatile unsigned long *)0xd0105f80
#define P_DI_MEM_RPT_LOOP                          (volatile unsigned long *)0xd0105f84
#define P_DI_MEM_LUMA0_RPT_PAT                     (volatile unsigned long *)0xd0105f88
#define P_DI_MEM_CHROMA0_RPT_PAT                   (volatile unsigned long *)0xd0105f8c
#define P_DI_MEM_DUMMY_PIXEL                       (volatile unsigned long *)0xd0105f90
#define P_DI_MEM_LUMA_FIFO_SIZE                    (volatile unsigned long *)0xd0105f94
#define P_DI_MEM_RANGE_MAP_Y                       (volatile unsigned long *)0xd0105ef4
#define P_DI_MEM_RANGE_MAP_CB                      (volatile unsigned long *)0xd0105ef8
#define P_DI_MEM_RANGE_MAP_CR                      (volatile unsigned long *)0xd0105efc
#define P_DI_MEM_GEN_REG2                          (volatile unsigned long *)0xd0105e48
#define P_DI_MEM_FMT_CTRL                          (volatile unsigned long *)0xd0105f98
#define P_DI_MEM_FMT_W                             (volatile unsigned long *)0xd0105f9c
#define P_DI_IF1_GEN_REG                           (volatile unsigned long *)0xd0105fa0
#define P_DI_IF1_CANVAS0                           (volatile unsigned long *)0xd0105fa4
#define P_DI_IF1_LUMA_X0                           (volatile unsigned long *)0xd0105fa8
#define P_DI_IF1_LUMA_Y0                           (volatile unsigned long *)0xd0105fac
#define P_DI_IF1_CHROMA_X0                         (volatile unsigned long *)0xd0105fb0
#define P_DI_IF1_CHROMA_Y0                         (volatile unsigned long *)0xd0105fb4
#define P_DI_IF1_RPT_LOOP                          (volatile unsigned long *)0xd0105fb8
#define P_DI_IF1_LUMA0_RPT_PAT                     (volatile unsigned long *)0xd0105fbc
#define P_DI_IF1_CHROMA0_RPT_PAT                   (volatile unsigned long *)0xd0105fc0
#define P_DI_IF1_DUMMY_PIXEL                       (volatile unsigned long *)0xd0105fc4
#define P_DI_IF1_LUMA_FIFO_SIZE                    (volatile unsigned long *)0xd0105fc8
#define P_DI_IF1_RANGE_MAP_Y                       (volatile unsigned long *)0xd0105ff0
#define P_DI_IF1_RANGE_MAP_CB                      (volatile unsigned long *)0xd0105ff4
#define P_DI_IF1_RANGE_MAP_CR                      (volatile unsigned long *)0xd0105ff8
#define P_DI_IF1_GEN_REG2                          (volatile unsigned long *)0xd0105e40
#define P_DI_IF1_FMT_CTRL                          (volatile unsigned long *)0xd0105fcc
#define P_DI_IF1_FMT_W                             (volatile unsigned long *)0xd0105fd0
#define P_DI_CHAN2_GEN_REG                         (volatile unsigned long *)0xd0105fd4
#define P_DI_CHAN2_CANVAS0                         (volatile unsigned long *)0xd0105fd8
#define P_DI_CHAN2_LUMA_X0                         (volatile unsigned long *)0xd0105fdc
#define P_DI_CHAN2_LUMA_Y0                         (volatile unsigned long *)0xd0105fe0
#define P_DI_CHAN2_CHROMA_X0                       (volatile unsigned long *)0xd0105fe4
#define P_DI_CHAN2_CHROMA_Y0                       (volatile unsigned long *)0xd0105fe8
#define P_DI_CHAN2_RPT_LOOP                        (volatile unsigned long *)0xd0105fec
#define P_DI_CHAN2_LUMA0_RPT_PAT                   (volatile unsigned long *)0xd0105ec0
#define P_DI_CHAN2_CHROMA0_RPT_PAT                 (volatile unsigned long *)0xd0105ec4
#define P_DI_CHAN2_DUMMY_PIXEL                     (volatile unsigned long *)0xd0105ec8
#define P_DI_CHAN2_LUMA_FIFO_SIZE                  (volatile unsigned long *)0xd0105ecc
#define P_DI_CHAN2_RANGE_MAP_Y                     (volatile unsigned long *)0xd0105ed0
#define P_DI_CHAN2_RANGE_MAP_CB                    (volatile unsigned long *)0xd0105ed4
#define P_DI_CHAN2_RANGE_MAP_CR                    (volatile unsigned long *)0xd0105ed8
#define P_DI_CHAN2_GEN_REG2                        (volatile unsigned long *)0xd0105edc
#define P_DI_CHAN2_FMT_CTRL                        (volatile unsigned long *)0xd0105ee0
#define P_DI_CHAN2_FMT_W                           (volatile unsigned long *)0xd0105ee4
//
// Closing file:  vregs.h
//
//
// Reading file:  v2regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Interface 2 Registers    0xe00 - 0xeff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VIU2_VCBUS_BASE = 0x1e
// -----------------------------------------------
#define P_VIU2_ADDR_START                          (volatile unsigned long *)0xd0107800
#define P_VIU2_ADDR_END                            (volatile unsigned long *)0xd0107bfc
//------------------------------------------------------------------------------
// VIU2 top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  7 RW, vpp_reset
#define P_VIU2_SW_RESET                            (volatile unsigned long *)0xd0107804
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU2_OSD1_CTRL_STAT                      (volatile unsigned long *)0xd0107840
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU2_OSD1_CTRL_STAT2                     (volatile unsigned long *)0xd01078b4
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU2_OSD1_COLOR_ADDR                     (volatile unsigned long *)0xd0107844
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU2_OSD1_COLOR                          (volatile unsigned long *)0xd0107848
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU2_OSD1_TCOLOR_AG0                     (volatile unsigned long *)0xd010785c
#define P_VIU2_OSD1_TCOLOR_AG1                     (volatile unsigned long *)0xd0107860
#define P_VIU2_OSD1_TCOLOR_AG2                     (volatile unsigned long *)0xd0107864
#define P_VIU2_OSD1_TCOLOR_AG3                     (volatile unsigned long *)0xd0107868
// Bit 31:30 Reserved
// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
// Bit 27:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU2_OSD1_BLK0_CFG_W0                    (volatile unsigned long *)0xd010786c
#define P_VIU2_OSD1_BLK1_CFG_W0                    (volatile unsigned long *)0xd010787c
#define P_VIU2_OSD1_BLK2_CFG_W0                    (volatile unsigned long *)0xd010788c
#define P_VIU2_OSD1_BLK3_CFG_W0                    (volatile unsigned long *)0xd010789c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU2_OSD1_BLK0_CFG_W1                    (volatile unsigned long *)0xd0107870
#define P_VIU2_OSD1_BLK1_CFG_W1                    (volatile unsigned long *)0xd0107880
#define P_VIU2_OSD1_BLK2_CFG_W1                    (volatile unsigned long *)0xd0107890
#define P_VIU2_OSD1_BLK3_CFG_W1                    (volatile unsigned long *)0xd01078a0
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU2_OSD1_BLK0_CFG_W2                    (volatile unsigned long *)0xd0107874
#define P_VIU2_OSD1_BLK1_CFG_W2                    (volatile unsigned long *)0xd0107884
#define P_VIU2_OSD1_BLK2_CFG_W2                    (volatile unsigned long *)0xd0107894
#define P_VIU2_OSD1_BLK3_CFG_W2                    (volatile unsigned long *)0xd01078a4
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU2_OSD1_BLK0_CFG_W3                    (volatile unsigned long *)0xd0107878
#define P_VIU2_OSD1_BLK1_CFG_W3                    (volatile unsigned long *)0xd0107888
#define P_VIU2_OSD1_BLK2_CFG_W3                    (volatile unsigned long *)0xd0107898
#define P_VIU2_OSD1_BLK3_CFG_W3                    (volatile unsigned long *)0xd01078a8
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU2_OSD1_BLK0_CFG_W4                    (volatile unsigned long *)0xd010784c
#define P_VIU2_OSD1_BLK1_CFG_W4                    (volatile unsigned long *)0xd0107850
#define P_VIU2_OSD1_BLK2_CFG_W4                    (volatile unsigned long *)0xd0107854
#define P_VIU2_OSD1_BLK3_CFG_W4                    (volatile unsigned long *)0xd0107858
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU2_OSD1_FIFO_CTRL_STAT                 (volatile unsigned long *)0xd01078ac
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU2_OSD1_TEST_RDDATA                    (volatile unsigned long *)0xd01078b0
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU2_OSD1_PROT_CTRL                      (volatile unsigned long *)0xd01078b8
//------------------------------------------------------------------------------
// OSD2 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU2_OSD2_CTRL_STAT                      (volatile unsigned long *)0xd01078c0
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU2_OSD2_CTRL_STAT2                     (volatile unsigned long *)0xd0107934
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU2_OSD2_COLOR_ADDR                     (volatile unsigned long *)0xd01078c4
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU2_OSD2_COLOR                          (volatile unsigned long *)0xd01078c8
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define P_VIU2_OSD2_HL1_H_START_END                (volatile unsigned long *)0xd01078cc
#define P_VIU2_OSD2_HL1_V_START_END                (volatile unsigned long *)0xd01078d0
#define P_VIU2_OSD2_HL2_H_START_END                (volatile unsigned long *)0xd01078d4
#define P_VIU2_OSD2_HL2_V_START_END                (volatile unsigned long *)0xd01078d8
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU2_OSD2_TCOLOR_AG0                     (volatile unsigned long *)0xd01078dc
#define P_VIU2_OSD2_TCOLOR_AG1                     (volatile unsigned long *)0xd01078e0
#define P_VIU2_OSD2_TCOLOR_AG2                     (volatile unsigned long *)0xd01078e4
#define P_VIU2_OSD2_TCOLOR_AG3                     (volatile unsigned long *)0xd01078e8
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU2_OSD2_BLK0_CFG_W0                    (volatile unsigned long *)0xd01078ec
#define P_VIU2_OSD2_BLK1_CFG_W0                    (volatile unsigned long *)0xd01078fc
#define P_VIU2_OSD2_BLK2_CFG_W0                    (volatile unsigned long *)0xd010790c
#define P_VIU2_OSD2_BLK3_CFG_W0                    (volatile unsigned long *)0xd010791c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU2_OSD2_BLK0_CFG_W1                    (volatile unsigned long *)0xd01078f0
#define P_VIU2_OSD2_BLK1_CFG_W1                    (volatile unsigned long *)0xd0107900
#define P_VIU2_OSD2_BLK2_CFG_W1                    (volatile unsigned long *)0xd0107910
#define P_VIU2_OSD2_BLK3_CFG_W1                    (volatile unsigned long *)0xd0107920
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU2_OSD2_BLK0_CFG_W2                    (volatile unsigned long *)0xd01078f4
#define P_VIU2_OSD2_BLK1_CFG_W2                    (volatile unsigned long *)0xd0107904
#define P_VIU2_OSD2_BLK2_CFG_W2                    (volatile unsigned long *)0xd0107914
#define P_VIU2_OSD2_BLK3_CFG_W2                    (volatile unsigned long *)0xd0107924
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU2_OSD2_BLK0_CFG_W3                    (volatile unsigned long *)0xd01078f8
#define P_VIU2_OSD2_BLK1_CFG_W3                    (volatile unsigned long *)0xd0107908
#define P_VIU2_OSD2_BLK2_CFG_W3                    (volatile unsigned long *)0xd0107918
#define P_VIU2_OSD2_BLK3_CFG_W3                    (volatile unsigned long *)0xd0107928
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU2_OSD2_BLK0_CFG_W4                    (volatile unsigned long *)0xd0107990
#define P_VIU2_OSD2_BLK1_CFG_W4                    (volatile unsigned long *)0xd0107994
#define P_VIU2_OSD2_BLK2_CFG_W4                    (volatile unsigned long *)0xd0107998
#define P_VIU2_OSD2_BLK3_CFG_W4                    (volatile unsigned long *)0xd010799c
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:22 R,  Reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU2_OSD2_FIFO_CTRL_STAT                 (volatile unsigned long *)0xd010792c
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU2_OSD2_TEST_RDDATA                    (volatile unsigned long *)0xd0107930
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU2_OSD2_PROT_CTRL                      (volatile unsigned long *)0xd0107938
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
#define P_VIU2_VD1_IF0_GEN_REG                     (volatile unsigned long *)0xd0107940
#define P_VIU2_VD1_IF0_CANVAS0                     (volatile unsigned long *)0xd0107944
#define P_VIU2_VD1_IF0_CANVAS1                     (volatile unsigned long *)0xd0107948
#define P_VIU2_VD1_IF0_LUMA_X0                     (volatile unsigned long *)0xd010794c
#define P_VIU2_VD1_IF0_LUMA_Y0                     (volatile unsigned long *)0xd0107950
#define P_VIU2_VD1_IF0_CHROMA_X0                   (volatile unsigned long *)0xd0107954
#define P_VIU2_VD1_IF0_CHROMA_Y0                   (volatile unsigned long *)0xd0107958
#define P_VIU2_VD1_IF0_LUMA_X1                     (volatile unsigned long *)0xd010795c
#define P_VIU2_VD1_IF0_LUMA_Y1                     (volatile unsigned long *)0xd0107960
#define P_VIU2_VD1_IF0_CHROMA_X1                   (volatile unsigned long *)0xd0107964
#define P_VIU2_VD1_IF0_CHROMA_Y1                   (volatile unsigned long *)0xd0107968
#define P_VIU2_VD1_IF0_RPT_LOOP                    (volatile unsigned long *)0xd010796c
#define P_VIU2_VD1_IF0_LUMA0_RPT_PAT               (volatile unsigned long *)0xd0107970
#define P_VIU2_VD1_IF0_CHROMA0_RPT_PAT             (volatile unsigned long *)0xd0107974
#define P_VIU2_VD1_IF0_LUMA1_RPT_PAT               (volatile unsigned long *)0xd0107978
#define P_VIU2_VD1_IF0_CHROMA1_RPT_PAT             (volatile unsigned long *)0xd010797c
#define P_VIU2_VD1_IF0_LUMA_PSEL                   (volatile unsigned long *)0xd0107980
#define P_VIU2_VD1_IF0_CHROMA_PSEL                 (volatile unsigned long *)0xd0107984
#define P_VIU2_VD1_IF0_DUMMY_PIXEL                 (volatile unsigned long *)0xd0107988
#define P_VIU2_VD1_IF0_LUMA_FIFO_SIZE              (volatile unsigned long *)0xd010798c
#define P_VIU2_VD1_IF0_RANGE_MAP_Y                 (volatile unsigned long *)0xd01079a8
#define P_VIU2_VD1_IF0_RANGE_MAP_CB                (volatile unsigned long *)0xd01079ac
#define P_VIU2_VD1_IF0_RANGE_MAP_CR                (volatile unsigned long *)0xd01079b0
#define P_VIU2_VD1_IF0_GEN_REG2                    (volatile unsigned long *)0xd01079b4
#define P_VIU2_VD1_IF0_PROT_CNTL                   (volatile unsigned long *)0xd01079b8
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define P_VIU2_VD1_FMT_CTRL                        (volatile unsigned long *)0xd01079a0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define P_VIU2_VD1_FMT_W                           (volatile unsigned long *)0xd01079a4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  v2regs.h
//
//
// Reading file:  venc_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VENC_VCBUS_BASE = 0x1b
// -----------------------------------------------
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define P_ENCP_VFIFO2VD_CTL                        (volatile unsigned long *)0xd0106d60
// bit 12:0 -- vfifo2vd_pixel_start 
#define P_ENCP_VFIFO2VD_PIXEL_START                (volatile unsigned long *)0xd0106d64
// bit 12:00 -- vfifo2vd_pixel_end   
#define P_ENCP_VFIFO2VD_PIXEL_END                  (volatile unsigned long *)0xd0106d68
// bit 10:0 -- vfifo2vd_line_top_start 
#define P_ENCP_VFIFO2VD_LINE_TOP_START             (volatile unsigned long *)0xd0106d6c
// bit 10:00 -- vfifo2vd_line_top_end   
#define P_ENCP_VFIFO2VD_LINE_TOP_END               (volatile unsigned long *)0xd0106d70
// bit 10:00 -- vfifo2vd_line_bot_start 
#define P_ENCP_VFIFO2VD_LINE_BOT_START             (volatile unsigned long *)0xd0106d74
// bit 10:00 -- vfifo2vd_line_bot_end   
#define P_ENCP_VFIFO2VD_LINE_BOT_END               (volatile unsigned long *)0xd0106d78
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define P_VENC_SYNC_ROUTE                          (volatile unsigned long *)0xd0106d80
		//			 encoder address space is assigned 
		//			 to the video encoder interface status 
		//			 register
#define P_VENC_VIDEO_EXSRC                         (volatile unsigned long *)0xd0106d84
#define P_VENC_DVI_SETTING                         (volatile unsigned long *)0xd0106d88
#define P_VENC_C656_CTRL                           (volatile unsigned long *)0xd0106d8c
#define P_VENC_UPSAMPLE_CTRL0                      (volatile unsigned long *)0xd0106d90
#define P_VENC_UPSAMPLE_CTRL1                      (volatile unsigned long *)0xd0106d94
#define P_VENC_UPSAMPLE_CTRL2                      (volatile unsigned long *)0xd0106d98
// Invert control for tcon output
// bit[15:14] -- vsync, hsync, 
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define P_TCON_INVERT_CTL                          (volatile unsigned long *)0xd0106d9c
#define P_VENC_VIDEO_PROG_MODE                     (volatile unsigned long *)0xd0106da0
//---- Venc pixel/line info
#define P_VENC_ENCI_LINE                           (volatile unsigned long *)0xd0106da4
#define P_VENC_ENCI_PIXEL                          (volatile unsigned long *)0xd0106da8
#define P_VENC_ENCP_LINE                           (volatile unsigned long *)0xd0106dac
#define P_VENC_ENCP_PIXEL                          (volatile unsigned long *)0xd0106db0
//---- Status
#define P_VENC_STATA                               (volatile unsigned long *)0xd0106db4
//---- Interrupt setting
#define P_VENC_INTCTRL                             (volatile unsigned long *)0xd0106db8
#define P_VENC_INTFLAG                             (volatile unsigned long *)0xd0106dbc
//--------- Video test configuration
#define P_VENC_VIDEO_TST_EN                        (volatile unsigned long *)0xd0106dc0
#define P_VENC_VIDEO_TST_MDSEL                     (volatile unsigned long *)0xd0106dc4
#define P_VENC_VIDEO_TST_Y                         (volatile unsigned long *)0xd0106dc8
#define P_VENC_VIDEO_TST_CB                        (volatile unsigned long *)0xd0106dcc
#define P_VENC_VIDEO_TST_CR                        (volatile unsigned long *)0xd0106dd0
#define P_VENC_VIDEO_TST_CLRBAR_STRT               (volatile unsigned long *)0xd0106dd4
#define P_VENC_VIDEO_TST_CLRBAR_WIDTH              (volatile unsigned long *)0xd0106dd8
#define P_VENC_VIDEO_TST_VDCNT_STSET               (volatile unsigned long *)0xd0106ddc
//----- Video dac setting
#define P_VENC_VDAC_DACSEL0                        (volatile unsigned long *)0xd0106de0
#define P_VENC_VDAC_DACSEL1                        (volatile unsigned long *)0xd0106de4
#define P_VENC_VDAC_DACSEL2                        (volatile unsigned long *)0xd0106de8
#define P_VENC_VDAC_DACSEL3                        (volatile unsigned long *)0xd0106dec
#define P_VENC_VDAC_DACSEL4                        (volatile unsigned long *)0xd0106df0
#define P_VENC_VDAC_DACSEL5                        (volatile unsigned long *)0xd0106df4
#define P_VENC_VDAC_SETTING                        (volatile unsigned long *)0xd0106df8
#define P_VENC_VDAC_TST_VAL                        (volatile unsigned long *)0xd0106dfc
#define P_VENC_VDAC_DAC0_GAINCTRL                  (volatile unsigned long *)0xd0106fc0
#define P_VENC_VDAC_DAC0_OFFSET                    (volatile unsigned long *)0xd0106fc4
#define P_VENC_VDAC_DAC1_GAINCTRL                  (volatile unsigned long *)0xd0106fc8
#define P_VENC_VDAC_DAC1_OFFSET                    (volatile unsigned long *)0xd0106fcc
#define P_VENC_VDAC_DAC2_GAINCTRL                  (volatile unsigned long *)0xd0106fd0
#define P_VENC_VDAC_DAC2_OFFSET                    (volatile unsigned long *)0xd0106fd4
#define P_VENC_VDAC_DAC3_GAINCTRL                  (volatile unsigned long *)0xd0106fd8
#define P_VENC_VDAC_DAC3_OFFSET                    (volatile unsigned long *)0xd0106fdc
#define P_VENC_VDAC_DAC4_GAINCTRL                  (volatile unsigned long *)0xd0106fe0
#define P_VENC_VDAC_DAC4_OFFSET                    (volatile unsigned long *)0xd0106fe4
#define P_VENC_VDAC_DAC5_GAINCTRL                  (volatile unsigned long *)0xd0106fe8
#define P_VENC_VDAC_DAC5_OFFSET                    (volatile unsigned long *)0xd0106fec
#define P_VENC_VDAC_FIFO_CTRL                      (volatile unsigned long *)0xd0106ff0
#define P_ENCL_TCON_INVERT_CTL                     (volatile unsigned long *)0xd0106ff4
//
// Closing file:  venc_regs.h
//
//
// Reading file:  enc480p_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define P_ENCP_VIDEO_EN                            (volatile unsigned long *)0xd0106e00
#define P_ENCP_VIDEO_SYNC_MODE                     (volatile unsigned long *)0xd0106e04
#define P_ENCP_MACV_EN                             (volatile unsigned long *)0xd0106e08
#define P_ENCP_VIDEO_Y_SCL                         (volatile unsigned long *)0xd0106e0c
#define P_ENCP_VIDEO_PB_SCL                        (volatile unsigned long *)0xd0106e10
#define P_ENCP_VIDEO_PR_SCL                        (volatile unsigned long *)0xd0106e14
#define P_ENCP_VIDEO_SYNC_SCL                      (volatile unsigned long *)0xd0106e18
#define P_ENCP_VIDEO_MACV_SCL                      (volatile unsigned long *)0xd0106e1c
#define P_ENCP_VIDEO_Y_OFFST                       (volatile unsigned long *)0xd0106e20
#define P_ENCP_VIDEO_PB_OFFST                      (volatile unsigned long *)0xd0106e24
#define P_ENCP_VIDEO_PR_OFFST                      (volatile unsigned long *)0xd0106e28
#define P_ENCP_VIDEO_SYNC_OFFST                    (volatile unsigned long *)0xd0106e2c
#define P_ENCP_VIDEO_MACV_OFFST                    (volatile unsigned long *)0xd0106e30
//----- Video mode
#define P_ENCP_VIDEO_MODE                          (volatile unsigned long *)0xd0106e34
#define P_ENCP_VIDEO_MODE_ADV                      (volatile unsigned long *)0xd0106e38
//--------------- Debug pins
#define P_ENCP_DBG_PX_RST                          (volatile unsigned long *)0xd0106e40
#define P_ENCP_DBG_LN_RST                          (volatile unsigned long *)0xd0106e44
#define P_ENCP_DBG_PX_INT                          (volatile unsigned long *)0xd0106e48
#define P_ENCP_DBG_LN_INT                          (volatile unsigned long *)0xd0106e4c
//----------- Video Advanced setting
#define P_ENCP_VIDEO_YFP1_HTIME                    (volatile unsigned long *)0xd0106e50
#define P_ENCP_VIDEO_YFP2_HTIME                    (volatile unsigned long *)0xd0106e54
#define P_ENCP_VIDEO_YC_DLY                        (volatile unsigned long *)0xd0106e58
#define P_ENCP_VIDEO_MAX_PXCNT                     (volatile unsigned long *)0xd0106e5c
#define P_ENCP_VIDEO_HSPULS_BEGIN                  (volatile unsigned long *)0xd0106e60
#define P_ENCP_VIDEO_HSPULS_END                    (volatile unsigned long *)0xd0106e64
#define P_ENCP_VIDEO_HSPULS_SWITCH                 (volatile unsigned long *)0xd0106e68
#define P_ENCP_VIDEO_VSPULS_BEGIN                  (volatile unsigned long *)0xd0106e6c
#define P_ENCP_VIDEO_VSPULS_END                    (volatile unsigned long *)0xd0106e70
#define P_ENCP_VIDEO_VSPULS_BLINE                  (volatile unsigned long *)0xd0106e74
#define P_ENCP_VIDEO_VSPULS_ELINE                  (volatile unsigned long *)0xd0106e78
#define P_ENCP_VIDEO_EQPULS_BEGIN                  (volatile unsigned long *)0xd0106e7c
#define P_ENCP_VIDEO_EQPULS_END                    (volatile unsigned long *)0xd0106e80
#define P_ENCP_VIDEO_EQPULS_BLINE                  (volatile unsigned long *)0xd0106e84
#define P_ENCP_VIDEO_EQPULS_ELINE                  (volatile unsigned long *)0xd0106e88
#define P_ENCP_VIDEO_HAVON_END                     (volatile unsigned long *)0xd0106e8c
#define P_ENCP_VIDEO_HAVON_BEGIN                   (volatile unsigned long *)0xd0106e90
#define P_ENCP_VIDEO_VAVON_ELINE                   (volatile unsigned long *)0xd0106ebc
#define P_ENCP_VIDEO_VAVON_BLINE                   (volatile unsigned long *)0xd0106e98
#define P_ENCP_VIDEO_HSO_BEGIN                     (volatile unsigned long *)0xd0106e9c
#define P_ENCP_VIDEO_HSO_END                       (volatile unsigned long *)0xd0106ea0
#define P_ENCP_VIDEO_VSO_BEGIN                     (volatile unsigned long *)0xd0106ea4
#define P_ENCP_VIDEO_VSO_END                       (volatile unsigned long *)0xd0106ea8
#define P_ENCP_VIDEO_VSO_BLINE                     (volatile unsigned long *)0xd0106eac
#define P_ENCP_VIDEO_VSO_ELINE                     (volatile unsigned long *)0xd0106eb0
#define P_ENCP_VIDEO_SYNC_WAVE_CURVE               (volatile unsigned long *)0xd0106eb4
#define P_ENCP_VIDEO_MAX_LNCNT                     (volatile unsigned long *)0xd0106eb8
#define P_ENCP_VIDEO_SY_VAL                        (volatile unsigned long *)0xd0106ec0
#define P_ENCP_VIDEO_SY2_VAL                       (volatile unsigned long *)0xd0106ec4
#define P_ENCP_VIDEO_BLANKY_VAL                    (volatile unsigned long *)0xd0106ec8
#define P_ENCP_VIDEO_BLANKPB_VAL                   (volatile unsigned long *)0xd0106ecc
#define P_ENCP_VIDEO_BLANKPR_VAL                   (volatile unsigned long *)0xd0106ed0
#define P_ENCP_VIDEO_HOFFST                        (volatile unsigned long *)0xd0106ed4
#define P_ENCP_VIDEO_VOFFST                        (volatile unsigned long *)0xd0106ed8
#define P_ENCP_VIDEO_RGB_CTRL                      (volatile unsigned long *)0xd0106edc
#define P_ENCP_VIDEO_FILT_CTRL                     (volatile unsigned long *)0xd0106ee0
#define P_ENCP_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned long *)0xd0106ee4
#define P_ENCP_VIDEO_OFLD_VOAV_OFST                (volatile unsigned long *)0xd0106ee8
#define P_ENCP_VIDEO_MATRIX_CB                     (volatile unsigned long *)0xd0106eec
#define P_ENCP_VIDEO_MATRIX_CR                     (volatile unsigned long *)0xd0106ef0
#define P_ENCP_VIDEO_RGBIN_CTRL                    (volatile unsigned long *)0xd0106ef4
//------------------Macrovision advanced setting
#define P_ENCP_MACV_BLANKY_VAL                     (volatile unsigned long *)0xd0106f00
#define P_ENCP_MACV_MAXY_VAL                       (volatile unsigned long *)0xd0106f04
#define P_ENCP_MACV_1ST_PSSYNC_STRT                (volatile unsigned long *)0xd0106f08
#define P_ENCP_MACV_PSSYNC_STRT                    (volatile unsigned long *)0xd0106f0c
#define P_ENCP_MACV_AGC_STRT                       (volatile unsigned long *)0xd0106f10
#define P_ENCP_MACV_AGC_END                        (volatile unsigned long *)0xd0106f14
#define P_ENCP_MACV_WAVE_END                       (volatile unsigned long *)0xd0106f18
#define P_ENCP_MACV_STRTLINE                       (volatile unsigned long *)0xd0106f1c
#define P_ENCP_MACV_ENDLINE                        (volatile unsigned long *)0xd0106f20
#define P_ENCP_MACV_TS_CNT_MAX_L                   (volatile unsigned long *)0xd0106f24
#define P_ENCP_MACV_TS_CNT_MAX_H                   (volatile unsigned long *)0xd0106f28
#define P_ENCP_MACV_TIME_DOWN                      (volatile unsigned long *)0xd0106f2c
#define P_ENCP_MACV_TIME_LO                        (volatile unsigned long *)0xd0106f30
#define P_ENCP_MACV_TIME_UP                        (volatile unsigned long *)0xd0106f34
#define P_ENCP_MACV_TIME_RST                       (volatile unsigned long *)0xd0106f38
//---------------- VBI control -------------------
#define P_ENCP_VBI_CTRL                            (volatile unsigned long *)0xd0106f40
#define P_ENCP_VBI_SETTING                         (volatile unsigned long *)0xd0106f44
#define P_ENCP_VBI_BEGIN                           (volatile unsigned long *)0xd0106f48
#define P_ENCP_VBI_WIDTH                           (volatile unsigned long *)0xd0106f4c
#define P_ENCP_VBI_HVAL                            (volatile unsigned long *)0xd0106f50
#define P_ENCP_VBI_DATA0                           (volatile unsigned long *)0xd0106f54
#define P_ENCP_VBI_DATA1                           (volatile unsigned long *)0xd0106f58
//----------------C656 OUT Control------------- Grant
#define P_C656_HS_ST                               (volatile unsigned long *)0xd0106f80
#define P_C656_HS_ED                               (volatile unsigned long *)0xd0106f84
#define P_C656_VS_LNST_E                           (volatile unsigned long *)0xd0106f88
#define P_C656_VS_LNST_O                           (volatile unsigned long *)0xd0106f8c
#define P_C656_VS_LNED_E                           (volatile unsigned long *)0xd0106f90
#define P_C656_VS_LNED_O                           (volatile unsigned long *)0xd0106f94
#define P_C656_FS_LNST                             (volatile unsigned long *)0xd0106f98
#define P_C656_FS_LNED                             (volatile unsigned long *)0xd0106f9c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  enc480p_regs.h
//
//
// Reading file:  enci_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define P_ENCI_VIDEO_MODE                          (volatile unsigned long *)0xd0106c00
#define P_ENCI_VIDEO_MODE_ADV                      (volatile unsigned long *)0xd0106c04
#define P_ENCI_VIDEO_FSC_ADJ                       (volatile unsigned long *)0xd0106c08
#define P_ENCI_VIDEO_BRIGHT                        (volatile unsigned long *)0xd0106c0c
#define P_ENCI_VIDEO_CONT                          (volatile unsigned long *)0xd0106c10
#define P_ENCI_VIDEO_SAT                           (volatile unsigned long *)0xd0106c14
#define P_ENCI_VIDEO_HUE                           (volatile unsigned long *)0xd0106c18
#define P_ENCI_VIDEO_SCH                           (volatile unsigned long *)0xd0106c1c
#define P_ENCI_SYNC_MODE                           (volatile unsigned long *)0xd0106c20
#define P_ENCI_SYNC_CTRL                           (volatile unsigned long *)0xd0106c24
#define P_ENCI_SYNC_HSO_BEGIN                      (volatile unsigned long *)0xd0106c28
#define P_ENCI_SYNC_HSO_END                        (volatile unsigned long *)0xd0106c2c
#define P_ENCI_SYNC_VSO_EVN                        (volatile unsigned long *)0xd0106c30
#define P_ENCI_SYNC_VSO_ODD                        (volatile unsigned long *)0xd0106c34
#define P_ENCI_SYNC_VSO_EVNLN                      (volatile unsigned long *)0xd0106c38
#define P_ENCI_SYNC_VSO_ODDLN                      (volatile unsigned long *)0xd0106c3c
#define P_ENCI_SYNC_HOFFST                         (volatile unsigned long *)0xd0106c40
#define P_ENCI_SYNC_VOFFST                         (volatile unsigned long *)0xd0106c44
#define P_ENCI_SYNC_ADJ                            (volatile unsigned long *)0xd0106c48
#define P_ENCI_RGB_SETTING                         (volatile unsigned long *)0xd0106c4c
//`define	ENCI_CMPN_MATRIX_CB		8'h14
//`define	ENCI_CMPN_MATRIX_CR		8'h15
#define P_ENCI_DE_H_BEGIN                          (volatile unsigned long *)0xd0106c58
#define P_ENCI_DE_H_END                            (volatile unsigned long *)0xd0106c5c
#define P_ENCI_DE_V_BEGIN_EVEN                     (volatile unsigned long *)0xd0106c60
#define P_ENCI_DE_V_END_EVEN                       (volatile unsigned long *)0xd0106c64
#define P_ENCI_DE_V_BEGIN_ODD                      (volatile unsigned long *)0xd0106c68
#define P_ENCI_DE_V_END_ODD                        (volatile unsigned long *)0xd0106c6c
#define P_ENCI_VBI_SETTING                         (volatile unsigned long *)0xd0106c80
#define P_ENCI_VBI_CCDT_EVN                        (volatile unsigned long *)0xd0106c84
#define P_ENCI_VBI_CCDT_ODD                        (volatile unsigned long *)0xd0106c88
#define P_ENCI_VBI_CC525_LN                        (volatile unsigned long *)0xd0106c8c
#define P_ENCI_VBI_CC625_LN                        (volatile unsigned long *)0xd0106c90
#define P_ENCI_VBI_WSSDT                           (volatile unsigned long *)0xd0106c94
#define P_ENCI_VBI_WSS_LN                          (volatile unsigned long *)0xd0106c98
#define P_ENCI_VBI_CGMSDT_L                        (volatile unsigned long *)0xd0106c9c
#define P_ENCI_VBI_CGMSDT_H                        (volatile unsigned long *)0xd0106ca0
#define P_ENCI_VBI_CGMS_LN                         (volatile unsigned long *)0xd0106ca4
#define P_ENCI_VBI_TTX_HTIME                       (volatile unsigned long *)0xd0106ca8
#define P_ENCI_VBI_TTX_LN                          (volatile unsigned long *)0xd0106cac
#define P_ENCI_VBI_TTXDT0                          (volatile unsigned long *)0xd0106cb0
#define P_ENCI_VBI_TTXDT1                          (volatile unsigned long *)0xd0106cb4
#define P_ENCI_VBI_TTXDT2                          (volatile unsigned long *)0xd0106cb8
#define P_ENCI_VBI_TTXDT3                          (volatile unsigned long *)0xd0106cbc
#define P_ENCI_MACV_N0                             (volatile unsigned long *)0xd0106cc0
#define P_ENCI_MACV_N1                             (volatile unsigned long *)0xd0106cc4
#define P_ENCI_MACV_N2                             (volatile unsigned long *)0xd0106cc8
#define P_ENCI_MACV_N3                             (volatile unsigned long *)0xd0106ccc
#define P_ENCI_MACV_N4                             (volatile unsigned long *)0xd0106cd0
#define P_ENCI_MACV_N5                             (volatile unsigned long *)0xd0106cd4
#define P_ENCI_MACV_N6                             (volatile unsigned long *)0xd0106cd8
#define P_ENCI_MACV_N7                             (volatile unsigned long *)0xd0106cdc
#define P_ENCI_MACV_N8                             (volatile unsigned long *)0xd0106ce0
#define P_ENCI_MACV_N9                             (volatile unsigned long *)0xd0106ce4
#define P_ENCI_MACV_N10                            (volatile unsigned long *)0xd0106ce8
#define P_ENCI_MACV_N11                            (volatile unsigned long *)0xd0106cec
#define P_ENCI_MACV_N12                            (volatile unsigned long *)0xd0106cf0
#define P_ENCI_MACV_N13                            (volatile unsigned long *)0xd0106cf4
#define P_ENCI_MACV_N14                            (volatile unsigned long *)0xd0106cf8
#define P_ENCI_MACV_N15                            (volatile unsigned long *)0xd0106cfc
#define P_ENCI_MACV_N16                            (volatile unsigned long *)0xd0106d00
#define P_ENCI_MACV_N17                            (volatile unsigned long *)0xd0106d04
#define P_ENCI_MACV_N18                            (volatile unsigned long *)0xd0106d08
#define P_ENCI_MACV_N19                            (volatile unsigned long *)0xd0106d0c
#define P_ENCI_MACV_N20                            (volatile unsigned long *)0xd0106d10
#define P_ENCI_MACV_N21                            (volatile unsigned long *)0xd0106d14
#define P_ENCI_MACV_N22                            (volatile unsigned long *)0xd0106d18
//`define	ENCI_MACV_P_AGC			8'h47
#define P_ENCI_DBG_PX_RST                          (volatile unsigned long *)0xd0106d20
#define P_ENCI_DBG_FLDLN_RST                       (volatile unsigned long *)0xd0106d24
#define P_ENCI_DBG_PX_INT                          (volatile unsigned long *)0xd0106d28
#define P_ENCI_DBG_FLDLN_INT                       (volatile unsigned long *)0xd0106d2c
#define P_ENCI_DBG_MAXPX                           (volatile unsigned long *)0xd0106d30
#define P_ENCI_DBG_MAXLN                           (volatile unsigned long *)0xd0106d34
#define P_ENCI_MACV_MAX_AMP                        (volatile unsigned long *)0xd0106d40
#define P_ENCI_MACV_PULSE_LO                       (volatile unsigned long *)0xd0106d44
#define P_ENCI_MACV_PULSE_HI                       (volatile unsigned long *)0xd0106d48
#define P_ENCI_MACV_BKP_MAX                        (volatile unsigned long *)0xd0106d4c
#define P_ENCI_CFILT_CTRL                          (volatile unsigned long *)0xd0106d50
#define P_ENCI_CFILT7                              (volatile unsigned long *)0xd0106d54
#define P_ENCI_YC_DELAY                            (volatile unsigned long *)0xd0106d58
#define P_ENCI_VIDEO_EN                            (volatile unsigned long *)0xd0106d5c
//
// Closing file:  enci_regs.h
//
//
// Reading file:  venc2_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef; RDMA registers 0xcf0 - 0xcff)
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VENC2_VCBUS_BASE = 0x1c
// -----------------------------------------------
// Program video control signals from ENCI core to DVI/HDMI interface
#define P_ENCI_DVI_HSO_BEGIN                       (volatile unsigned long *)0xd0107000
#define P_ENCI_DVI_HSO_END                         (volatile unsigned long *)0xd0107004
#define P_ENCI_DVI_VSO_BLINE_EVN                   (volatile unsigned long *)0xd0107008
#define P_ENCI_DVI_VSO_BLINE_ODD                   (volatile unsigned long *)0xd010700c
#define P_ENCI_DVI_VSO_ELINE_EVN                   (volatile unsigned long *)0xd0107010
#define P_ENCI_DVI_VSO_ELINE_ODD                   (volatile unsigned long *)0xd0107014
#define P_ENCI_DVI_VSO_BEGIN_EVN                   (volatile unsigned long *)0xd0107018
#define P_ENCI_DVI_VSO_BEGIN_ODD                   (volatile unsigned long *)0xd010701c
#define P_ENCI_DVI_VSO_END_EVN                     (volatile unsigned long *)0xd0107020
#define P_ENCI_DVI_VSO_END_ODD                     (volatile unsigned long *)0xd0107024
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define P_ENCI_CFILT_CTRL2                         (volatile unsigned long *)0xd0107028
#define P_ENCI_DACSEL_0                            (volatile unsigned long *)0xd010702c
#define P_ENCI_DACSEL_1                            (volatile unsigned long *)0xd0107030
#define P_ENCP_DACSEL_0                            (volatile unsigned long *)0xd0107034
#define P_ENCP_DACSEL_1                            (volatile unsigned long *)0xd0107038
#define P_ENCP_MAX_LINE_SWITCH_POINT               (volatile unsigned long *)0xd010703c
#define P_ENCI_TST_EN                              (volatile unsigned long *)0xd0107040
#define P_ENCI_TST_MDSEL                           (volatile unsigned long *)0xd0107044
#define P_ENCI_TST_Y                               (volatile unsigned long *)0xd0107048
#define P_ENCI_TST_CB                              (volatile unsigned long *)0xd010704c
#define P_ENCI_TST_CR                              (volatile unsigned long *)0xd0107050
#define P_ENCI_TST_CLRBAR_STRT                     (volatile unsigned long *)0xd0107054
#define P_ENCI_TST_CLRBAR_WIDTH                    (volatile unsigned long *)0xd0107058
#define P_ENCI_TST_VDCNT_STSET                     (volatile unsigned long *)0xd010705c
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define P_ENCI_VFIFO2VD_CTL                        (volatile unsigned long *)0xd0107060
// bit 12:0 -- vfifo2vd_pixel_start 
#define P_ENCI_VFIFO2VD_PIXEL_START                (volatile unsigned long *)0xd0107064
// bit 12:00 -- vfifo2vd_pixel_end   
#define P_ENCI_VFIFO2VD_PIXEL_END                  (volatile unsigned long *)0xd0107068
// bit 10:0 -- vfifo2vd_line_top_start 
#define P_ENCI_VFIFO2VD_LINE_TOP_START             (volatile unsigned long *)0xd010706c
// bit 10:00 -- vfifo2vd_line_top_end   
#define P_ENCI_VFIFO2VD_LINE_TOP_END               (volatile unsigned long *)0xd0107070
// bit 10:00 -- vfifo2vd_line_bot_start 
#define P_ENCI_VFIFO2VD_LINE_BOT_START             (volatile unsigned long *)0xd0107074
// bit 10:00 -- vfifo2vd_line_bot_end   
#define P_ENCI_VFIFO2VD_LINE_BOT_END               (volatile unsigned long *)0xd0107078
#define P_ENCI_VFIFO2VD_CTL2                       (volatile unsigned long *)0xd010707c
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define P_ENCT_VFIFO2VD_CTL                        (volatile unsigned long *)0xd0107080
// bit 12:0 -- vfifo2vd_pixel_start 
#define P_ENCT_VFIFO2VD_PIXEL_START                (volatile unsigned long *)0xd0107084
// bit 12:00 -- vfifo2vd_pixel_end   
#define P_ENCT_VFIFO2VD_PIXEL_END                  (volatile unsigned long *)0xd0107088
// bit 10:0 -- vfifo2vd_line_top_start 
#define P_ENCT_VFIFO2VD_LINE_TOP_START             (volatile unsigned long *)0xd010708c
// bit 10:00 -- vfifo2vd_line_top_end   
#define P_ENCT_VFIFO2VD_LINE_TOP_END               (volatile unsigned long *)0xd0107090
// bit 10:00 -- vfifo2vd_line_bot_start 
#define P_ENCT_VFIFO2VD_LINE_BOT_START             (volatile unsigned long *)0xd0107094
// bit 10:00 -- vfifo2vd_line_bot_end   
#define P_ENCT_VFIFO2VD_LINE_BOT_END               (volatile unsigned long *)0xd0107098
#define P_ENCT_VFIFO2VD_CTL2                       (volatile unsigned long *)0xd010709c
#define P_ENCT_TST_EN                              (volatile unsigned long *)0xd01070a0
#define P_ENCT_TST_MDSEL                           (volatile unsigned long *)0xd01070a4
#define P_ENCT_TST_Y                               (volatile unsigned long *)0xd01070a8
#define P_ENCT_TST_CB                              (volatile unsigned long *)0xd01070ac
#define P_ENCT_TST_CR                              (volatile unsigned long *)0xd01070b0
#define P_ENCT_TST_CLRBAR_STRT                     (volatile unsigned long *)0xd01070b4
#define P_ENCT_TST_CLRBAR_WIDTH                    (volatile unsigned long *)0xd01070b8
#define P_ENCT_TST_VDCNT_STSET                     (volatile unsigned long *)0xd01070bc
// Program video control signals from ENCP core to DVI/HDMI interface
#define P_ENCP_DVI_HSO_BEGIN                       (volatile unsigned long *)0xd01070c0
#define P_ENCP_DVI_HSO_END                         (volatile unsigned long *)0xd01070c4
#define P_ENCP_DVI_VSO_BLINE_EVN                   (volatile unsigned long *)0xd01070c8
#define P_ENCP_DVI_VSO_BLINE_ODD                   (volatile unsigned long *)0xd01070cc
#define P_ENCP_DVI_VSO_ELINE_EVN                   (volatile unsigned long *)0xd01070d0
#define P_ENCP_DVI_VSO_ELINE_ODD                   (volatile unsigned long *)0xd01070d4
#define P_ENCP_DVI_VSO_BEGIN_EVN                   (volatile unsigned long *)0xd01070d8
#define P_ENCP_DVI_VSO_BEGIN_ODD                   (volatile unsigned long *)0xd01070dc
#define P_ENCP_DVI_VSO_END_EVN                     (volatile unsigned long *)0xd01070e0
#define P_ENCP_DVI_VSO_END_ODD                     (volatile unsigned long *)0xd01070e4
#define P_ENCP_DE_H_BEGIN                          (volatile unsigned long *)0xd01070e8
#define P_ENCP_DE_H_END                            (volatile unsigned long *)0xd01070ec
#define P_ENCP_DE_V_BEGIN_EVEN                     (volatile unsigned long *)0xd01070f0
#define P_ENCP_DE_V_END_EVEN                       (volatile unsigned long *)0xd01070f4
#define P_ENCP_DE_V_BEGIN_ODD                      (volatile unsigned long *)0xd01070f8
#define P_ENCP_DE_V_END_ODD                        (volatile unsigned long *)0xd01070fc
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCI_SYNC_LINE_LENGTH                    (volatile unsigned long *)0xd0107100
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCI_SYNC_PIXEL_EN                       (volatile unsigned long *)0xd0107104
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCI_SYNC_TO_LINE_EN                     (volatile unsigned long *)0xd0107108
// Bit 12:0 - sync target pixel
#define P_ENCI_SYNC_TO_PIXEL                       (volatile unsigned long *)0xd010710c
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCP_SYNC_LINE_LENGTH                    (volatile unsigned long *)0xd0107110
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCP_SYNC_PIXEL_EN                       (volatile unsigned long *)0xd0107114
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCP_SYNC_TO_LINE_EN                     (volatile unsigned long *)0xd0107118
// Bit 12:0 - sync target pixel
#define P_ENCP_SYNC_TO_PIXEL                       (volatile unsigned long *)0xd010711c
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCT_SYNC_LINE_LENGTH                    (volatile unsigned long *)0xd0107120
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCT_SYNC_PIXEL_EN                       (volatile unsigned long *)0xd0107124
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCT_SYNC_TO_LINE_EN                     (volatile unsigned long *)0xd0107128
// Bit 12:0 - sync target pixel
#define P_ENCT_SYNC_TO_PIXEL                       (volatile unsigned long *)0xd010712c
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCL_SYNC_LINE_LENGTH                    (volatile unsigned long *)0xd0107130
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCL_SYNC_PIXEL_EN                       (volatile unsigned long *)0xd0107134
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCL_SYNC_TO_LINE_EN                     (volatile unsigned long *)0xd0107138
// Bit 12:0 - sync target pixel
#define P_ENCL_SYNC_TO_PIXEL                       (volatile unsigned long *)0xd010713c
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define P_ENCP_VFIFO2VD_CTL2                       (volatile unsigned long *)0xd0107140
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define P_VENC_DVI_SETTING_MORE                    (volatile unsigned long *)0xd0107144
#define P_VENC_VDAC_DAC4_FILT_CTRL0                (volatile unsigned long *)0xd0107150
#define P_VENC_VDAC_DAC4_FILT_CTRL1                (volatile unsigned long *)0xd0107154
#define P_VENC_VDAC_DAC5_FILT_CTRL0                (volatile unsigned long *)0xd0107158
#define P_VENC_VDAC_DAC5_FILT_CTRL1                (volatile unsigned long *)0xd010715c
//Bit 0   filter_en
#define P_VENC_VDAC_DAC0_FILT_CTRL0                (volatile unsigned long *)0xd0107160
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC0_FILT_CTRL1                (volatile unsigned long *)0xd0107164
//Bit 0   filter_en
#define P_VENC_VDAC_DAC1_FILT_CTRL0                (volatile unsigned long *)0xd0107168
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC1_FILT_CTRL1                (volatile unsigned long *)0xd010716c
//Bit 0   filter_en
#define P_VENC_VDAC_DAC2_FILT_CTRL0                (volatile unsigned long *)0xd0107170
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC2_FILT_CTRL1                (volatile unsigned long *)0xd0107174
//Bit 0   filter_en
#define P_VENC_VDAC_DAC3_FILT_CTRL0                (volatile unsigned long *)0xd0107178
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC3_FILT_CTRL1                (volatile unsigned long *)0xd010717c
//===========================================================================
// ENCT registers
#define P_ENCT_VIDEO_EN                            (volatile unsigned long *)0xd0107180
#define P_ENCT_VIDEO_Y_SCL                         (volatile unsigned long *)0xd0107184
#define P_ENCT_VIDEO_PB_SCL                        (volatile unsigned long *)0xd0107188
#define P_ENCT_VIDEO_PR_SCL                        (volatile unsigned long *)0xd010718c
#define P_ENCT_VIDEO_Y_OFFST                       (volatile unsigned long *)0xd0107190
#define P_ENCT_VIDEO_PB_OFFST                      (volatile unsigned long *)0xd0107194
#define P_ENCT_VIDEO_PR_OFFST                      (volatile unsigned long *)0xd0107198
//----- Video mode
#define P_ENCT_VIDEO_MODE                          (volatile unsigned long *)0xd010719c
#define P_ENCT_VIDEO_MODE_ADV                      (volatile unsigned long *)0xd01071a0
//--------------- Debug pins
#define P_ENCT_DBG_PX_RST                          (volatile unsigned long *)0xd01071a4
#define P_ENCT_DBG_LN_RST                          (volatile unsigned long *)0xd01071a8
#define P_ENCT_DBG_PX_INT                          (volatile unsigned long *)0xd01071ac
#define P_ENCT_DBG_LN_INT                          (volatile unsigned long *)0xd01071b0
//----------- Video Advanced setting
#define P_ENCT_VIDEO_YFP1_HTIME                    (volatile unsigned long *)0xd01071b4
#define P_ENCT_VIDEO_YFP2_HTIME                    (volatile unsigned long *)0xd01071b8
#define P_ENCT_VIDEO_YC_DLY                        (volatile unsigned long *)0xd01071bc
#define P_ENCT_VIDEO_MAX_PXCNT                     (volatile unsigned long *)0xd01071c0
#define P_ENCT_VIDEO_HAVON_END                     (volatile unsigned long *)0xd01071c4
#define P_ENCT_VIDEO_HAVON_BEGIN                   (volatile unsigned long *)0xd01071c8
#define P_ENCT_VIDEO_VAVON_ELINE                   (volatile unsigned long *)0xd01071cc
#define P_ENCT_VIDEO_VAVON_BLINE                   (volatile unsigned long *)0xd01071d0
#define P_ENCT_VIDEO_HSO_BEGIN                     (volatile unsigned long *)0xd01071d4
#define P_ENCT_VIDEO_HSO_END                       (volatile unsigned long *)0xd01071d8
#define P_ENCT_VIDEO_VSO_BEGIN                     (volatile unsigned long *)0xd01071dc
#define P_ENCT_VIDEO_VSO_END                       (volatile unsigned long *)0xd01071e0
#define P_ENCT_VIDEO_VSO_BLINE                     (volatile unsigned long *)0xd01071e4
#define P_ENCT_VIDEO_VSO_ELINE                     (volatile unsigned long *)0xd01071e8
#define P_ENCT_VIDEO_MAX_LNCNT                     (volatile unsigned long *)0xd01071ec
#define P_ENCT_VIDEO_BLANKY_VAL                    (volatile unsigned long *)0xd01071f0
#define P_ENCT_VIDEO_BLANKPB_VAL                   (volatile unsigned long *)0xd01071f4
#define P_ENCT_VIDEO_BLANKPR_VAL                   (volatile unsigned long *)0xd01071f8
#define P_ENCT_VIDEO_HOFFST                        (volatile unsigned long *)0xd01071fc
#define P_ENCT_VIDEO_VOFFST                        (volatile unsigned long *)0xd0107200
#define P_ENCT_VIDEO_RGB_CTRL                      (volatile unsigned long *)0xd0107204
#define P_ENCT_VIDEO_FILT_CTRL                     (volatile unsigned long *)0xd0107208
#define P_ENCT_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned long *)0xd010720c
#define P_ENCT_VIDEO_OFLD_VOAV_OFST                (volatile unsigned long *)0xd0107210
#define P_ENCT_VIDEO_MATRIX_CB                     (volatile unsigned long *)0xd0107214
#define P_ENCT_VIDEO_MATRIX_CR                     (volatile unsigned long *)0xd0107218
#define P_ENCT_VIDEO_RGBIN_CTRL                    (volatile unsigned long *)0xd010721c
#define P_ENCT_MAX_LINE_SWITCH_POINT               (volatile unsigned long *)0xd0107220
#define P_ENCT_DACSEL_0                            (volatile unsigned long *)0xd0107224
#define P_ENCT_DACSEL_1                            (volatile unsigned long *)0xd0107228
//===========================================================================
// For ENCL
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define P_ENCL_VFIFO2VD_CTL                        (volatile unsigned long *)0xd0107240
// bit 12:0 -- vfifo2vd_pixel_start 
#define P_ENCL_VFIFO2VD_PIXEL_START                (volatile unsigned long *)0xd0107244
// bit 12:00 -- vfifo2vd_pixel_end   
#define P_ENCL_VFIFO2VD_PIXEL_END                  (volatile unsigned long *)0xd0107248
// bit 10:0 -- vfifo2vd_line_top_start 
#define P_ENCL_VFIFO2VD_LINE_TOP_START             (volatile unsigned long *)0xd010724c
// bit 10:00 -- vfifo2vd_line_top_end   
#define P_ENCL_VFIFO2VD_LINE_TOP_END               (volatile unsigned long *)0xd0107250
// bit 10:00 -- vfifo2vd_line_bot_start 
#define P_ENCL_VFIFO2VD_LINE_BOT_START             (volatile unsigned long *)0xd0107254
// bit 10:00 -- vfifo2vd_line_bot_end   
#define P_ENCL_VFIFO2VD_LINE_BOT_END               (volatile unsigned long *)0xd0107258
#define P_ENCL_VFIFO2VD_CTL2                       (volatile unsigned long *)0xd010725c
#define P_ENCL_TST_EN                              (volatile unsigned long *)0xd0107260
#define P_ENCL_TST_MDSEL                           (volatile unsigned long *)0xd0107264
#define P_ENCL_TST_Y                               (volatile unsigned long *)0xd0107268
#define P_ENCL_TST_CB                              (volatile unsigned long *)0xd010726c
#define P_ENCL_TST_CR                              (volatile unsigned long *)0xd0107270
#define P_ENCL_TST_CLRBAR_STRT                     (volatile unsigned long *)0xd0107274
#define P_ENCL_TST_CLRBAR_WIDTH                    (volatile unsigned long *)0xd0107278
#define P_ENCL_TST_VDCNT_STSET                     (volatile unsigned long *)0xd010727c
//===========================================================================
// ENCL registers
#define P_ENCL_VIDEO_EN                            (volatile unsigned long *)0xd0107280
#define P_ENCL_VIDEO_Y_SCL                         (volatile unsigned long *)0xd0107284
#define P_ENCL_VIDEO_PB_SCL                        (volatile unsigned long *)0xd0107288
#define P_ENCL_VIDEO_PR_SCL                        (volatile unsigned long *)0xd010728c
#define P_ENCL_VIDEO_Y_OFFST                       (volatile unsigned long *)0xd0107290
#define P_ENCL_VIDEO_PB_OFFST                      (volatile unsigned long *)0xd0107294
#define P_ENCL_VIDEO_PR_OFFST                      (volatile unsigned long *)0xd0107298
//----- Video mode
#define P_ENCL_VIDEO_MODE                          (volatile unsigned long *)0xd010729c
#define P_ENCL_VIDEO_MODE_ADV                      (volatile unsigned long *)0xd01072a0
//--------------- Debug pins
#define P_ENCL_DBG_PX_RST                          (volatile unsigned long *)0xd01072a4
#define P_ENCL_DBG_LN_RST                          (volatile unsigned long *)0xd01072a8
#define P_ENCL_DBG_PX_INT                          (volatile unsigned long *)0xd01072ac
#define P_ENCL_DBG_LN_INT                          (volatile unsigned long *)0xd01072b0
//----------- Video Advanced setting
#define P_ENCL_VIDEO_YFP1_HTIME                    (volatile unsigned long *)0xd01072b4
#define P_ENCL_VIDEO_YFP2_HTIME                    (volatile unsigned long *)0xd01072b8
#define P_ENCL_VIDEO_YC_DLY                        (volatile unsigned long *)0xd01072bc
#define P_ENCL_VIDEO_MAX_PXCNT                     (volatile unsigned long *)0xd01072c0
#define P_ENCL_VIDEO_HAVON_END                     (volatile unsigned long *)0xd01072c4
#define P_ENCL_VIDEO_HAVON_BEGIN                   (volatile unsigned long *)0xd01072c8
#define P_ENCL_VIDEO_VAVON_ELINE                   (volatile unsigned long *)0xd01072cc
#define P_ENCL_VIDEO_VAVON_BLINE                   (volatile unsigned long *)0xd01072d0
#define P_ENCL_VIDEO_HSO_BEGIN                     (volatile unsigned long *)0xd01072d4
#define P_ENCL_VIDEO_HSO_END                       (volatile unsigned long *)0xd01072d8
#define P_ENCL_VIDEO_VSO_BEGIN                     (volatile unsigned long *)0xd01072dc
#define P_ENCL_VIDEO_VSO_END                       (volatile unsigned long *)0xd01072e0
#define P_ENCL_VIDEO_VSO_BLINE                     (volatile unsigned long *)0xd01072e4
#define P_ENCL_VIDEO_VSO_ELINE                     (volatile unsigned long *)0xd01072e8
#define P_ENCL_VIDEO_MAX_LNCNT                     (volatile unsigned long *)0xd01072ec
#define P_ENCL_VIDEO_BLANKY_VAL                    (volatile unsigned long *)0xd01072f0
#define P_ENCL_VIDEO_BLANKPB_VAL                   (volatile unsigned long *)0xd01072f4
#define P_ENCL_VIDEO_BLANKPR_VAL                   (volatile unsigned long *)0xd01072f8
#define P_ENCL_VIDEO_HOFFST                        (volatile unsigned long *)0xd01072fc
#define P_ENCL_VIDEO_VOFFST                        (volatile unsigned long *)0xd0107300
#define P_ENCL_VIDEO_RGB_CTRL                      (volatile unsigned long *)0xd0107304
#define P_ENCL_VIDEO_FILT_CTRL                     (volatile unsigned long *)0xd0107308
#define P_ENCL_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned long *)0xd010730c
#define P_ENCL_VIDEO_OFLD_VOAV_OFST                (volatile unsigned long *)0xd0107310
#define P_ENCL_VIDEO_MATRIX_CB                     (volatile unsigned long *)0xd0107314
#define P_ENCL_VIDEO_MATRIX_CR                     (volatile unsigned long *)0xd0107318
#define P_ENCL_VIDEO_RGBIN_CTRL                    (volatile unsigned long *)0xd010731c
#define P_ENCL_MAX_LINE_SWITCH_POINT               (volatile unsigned long *)0xd0107320
#define P_ENCL_DACSEL_0                            (volatile unsigned long *)0xd0107324
#define P_ENCL_DACSEL_1                            (volatile unsigned long *)0xd0107328
//===========================================================================
// RDMA Registers       0xcf0 - 0xcff
// Bit 31: 0 RW AHB start address for manual start DMA
#define P_RDMA_AHB_START_ADDR_MAN                  (volatile unsigned long *)0xd01073c0
// Bit 31: 0 RW AHB end address for manual start DMA
#define P_RDMA_AHB_END_ADDR_MAN                    (volatile unsigned long *)0xd01073c4
// Bit 31: 0 RW AHB start address for auto start source 1
#define P_RDMA_AHB_START_ADDR_1                    (volatile unsigned long *)0xd01073c8
// Bit 31: 0 RW AHB end address for auto start source 1
#define P_RDMA_AHB_END_ADDR_1                      (volatile unsigned long *)0xd01073cc
// Bit 31: 0 RW AHB start address for auto start source 2
#define P_RDMA_AHB_START_ADDR_2                    (volatile unsigned long *)0xd01073d0
// Bit 31: 0 RW AHB end address for auto start source 2
#define P_RDMA_AHB_END_ADDR_2                      (volatile unsigned long *)0xd01073d4
// Bit 31: 0 RW AHB start address for auto start source 3
#define P_RDMA_AHB_START_ADDR_3                    (volatile unsigned long *)0xd01073d8
// Bit 31: 0 RW AHB end address for auto start source 3
#define P_RDMA_AHB_END_ADDR_3                      (volatile unsigned long *)0xd01073dc
// Auto start DMA control:
// Bit 31:24 RW ctrl_enable_int_3. Interrupt inputs enable mask for source 3.
// Bit 23:16 RW ctrl_enable_int_2. Interrupt inputs enable mask for source 2.
// Bit 15: 8 RW ctrl_enable_int_1. Interrupt inputs enable mask for source 1.
// Bit     7 RW ctrl_cbus_write_3. Register read/write mode for auto-start 3. 1=Register write; 0=Register read.
// Bit     6 RW ctrl_cbus_write_3. Register read/write mode for auto-start 2. 1=Register write; 0=Register read.
// Bit     5 RW ctrl_cbus_write_3. Register read/write mode for auto-start 1. 1=Register write; 0=Register read.
// Bit     4 R  Rsrv.
// Bit     3 RW ctrl_cbus_addr_incr_3. 1=Incremental register access for auto-start 3; 0=Non-incremental (individual) register access.
// Bit     2 RW ctrl_cbus_addr_incr_2. 1=Incremental register access for auto-start 2; 0=Non-incremental (individual) register access.
// Bit     1 RW ctrl_cbus_addr_incr_1. 1=Incremental register access for auto-start 1; 0=Non-incremental (individual) register access.
// Bit     0 R  Rsrv.
#define P_RDMA_ACCESS_AUTO                         (volatile unsigned long *)0xd01073e0
// Manual start DMA control:
// Bit 31: 3 R  Rsrv.
// Bit     2 RW ctrl_cbus_write_man. Register read/write mode for manual-start. 1=Register write; 0=Register read.
// Bit     1 RW ctrl_cbus_addr_incr_man. 1=Incremental register access for manual-start; 0=Non-incremental (individual) register access.
// Bit     0 W  ctrl_start_man. Write 1 to this bit to manual-start DMA. This bit always read back 0.
#define P_RDMA_ACCESS_MAN                          (volatile unsigned long *)0xd01073e4
// RDMA general control:
// Bit 31:25 R  Rsrv.
// Bit    24 W  ctrl_clr_rdma_done_int. Write 1 to reset rdma_int level to 0. No need to clear this bit.
// Bit 23:19 R  Rsrv.
// Bit 18:13 R  Rsrv.
// Bit 12: 7 R  Rsrv.
// Bit     6 RW ctrl_ddr_urgent.
// Bit  5: 4 RW ctrl_ahb_wr_burst_size. 0=ABH write request burst size 16;
//                                      1=ABH write request burst size 24;
//                                      2=ABH write request burst size 32;
//                                      3=ABH write request burst size 48.
// Bit  3: 2 RW ctrl_ahb_rd_burst_size. 0=ABH read request burst size 16;
//                                      1=ABH read request burst size 24;
//                                      2=ABH read request burst size 32;
//                                      3=ABH read request burst size 48.
// Bit     1 RW ctrl_sw_reset. 1=Reset RDMA logics except register.
// Bit     0 RW ctrl_free_clk_enable. 0=Default, Enable clock gating. 1=No clock gating, enable free clock.
#define P_RDMA_CTRL                                (volatile unsigned long *)0xd01073e8
// Read only.
// Bit 31:29 R  Rsrv.
// Bit    28 R  rdma_done_int.
// Bit 27:25 R  Rsrv.
// Bit 24:18 R  ahb_wrfifo_cnt. FIFO for buffering CBus read data to be sent to AHB
// Bit 17:11 R  ahb_rdfifo_cnt. FIFO for buffering data read from AHB.
// Bit 10: 8 R  ddr_req_st. =0 -- Idle; !=0 -- AHB interfacing ongoing.
// Bit  7: 4 R  curr_req. Latest requests that is being/been serviced. E.g. 0000=Idle; 0010=Latest serviced request is Req 1.
// Bit  3: 0 R  req_latch. Requests that are yet to be serviced. E.g. 0000=No request; 0001=Req 0 waiting; 1100=Req 2 and 3 waiting.
#define P_RDMA_STATUS                              (volatile unsigned long *)0xd01073ec
//
// Closing file:  venc2_regs.h
//
//
// Reading file:  lcd_regs.h
//
// -----------------------------------------------
// CBUS_BASE:  LCD_VCBUS_BASE = 0x14
// -----------------------------------------------
//========================================================================
//LCD DRV     12'h480~12'h4ef
//=======================================================================
#define P_L_GAMMA_CNTL_PORT                        (volatile unsigned long *)0xd0105000
#define P_L_GAMMA_DATA_PORT                        (volatile unsigned long *)0xd0105004
#define P_L_GAMMA_ADDR_PORT                        (volatile unsigned long *)0xd0105008
#define P_L_GAMMA_VCOM_HSWITCH_ADDR                (volatile unsigned long *)0xd010500c
#define P_L_RGB_BASE_ADDR                          (volatile unsigned long *)0xd0105014
#define P_L_RGB_COEFF_ADDR                         (volatile unsigned long *)0xd0105018
#define P_L_POL_CNTL_ADDR                          (volatile unsigned long *)0xd010501c
#define P_L_DITH_CNTL_ADDR                         (volatile unsigned long *)0xd0105020
#define P_L_GAMMA_PROBE_CTRL                       (volatile unsigned long *)0xd0105024
//read only
#define P_L_GAMMA_PROBE_COLOR_L                    (volatile unsigned long *)0xd0105028
#define P_L_GAMMA_PROBE_COLOR_H                    (volatile unsigned long *)0xd010502c
#define P_L_GAMMA_PROBE_HL_COLOR                   (volatile unsigned long *)0xd0105030
#define P_L_GAMMA_PROBE_POS_X                      (volatile unsigned long *)0xd0105034
#define P_L_GAMMA_PROBE_POS_Y                      (volatile unsigned long *)0xd0105038
#define P_L_STH1_HS_ADDR                           (volatile unsigned long *)0xd0105040
#define P_L_STH1_HE_ADDR                           (volatile unsigned long *)0xd0105044
#define P_L_STH1_VS_ADDR                           (volatile unsigned long *)0xd0105048
#define P_L_STH1_VE_ADDR                           (volatile unsigned long *)0xd010504c
#define P_L_STH2_HS_ADDR                           (volatile unsigned long *)0xd0105050
#define P_L_STH2_HE_ADDR                           (volatile unsigned long *)0xd0105054
#define P_L_STH2_VS_ADDR                           (volatile unsigned long *)0xd0105058
#define P_L_STH2_VE_ADDR                           (volatile unsigned long *)0xd010505c
#define P_L_OEH_HS_ADDR                            (volatile unsigned long *)0xd0105060
#define P_L_OEH_HE_ADDR                            (volatile unsigned long *)0xd0105064
#define P_L_OEH_VS_ADDR                            (volatile unsigned long *)0xd0105068
#define P_L_OEH_VE_ADDR                            (volatile unsigned long *)0xd010506c
#define P_L_VCOM_HSWITCH_ADDR                      (volatile unsigned long *)0xd0105070
#define P_L_VCOM_VS_ADDR                           (volatile unsigned long *)0xd0105074
#define P_L_VCOM_VE_ADDR                           (volatile unsigned long *)0xd0105078
#define P_L_CPV1_HS_ADDR                           (volatile unsigned long *)0xd010507c
#define P_L_CPV1_HE_ADDR                           (volatile unsigned long *)0xd0105080
#define P_L_CPV1_VS_ADDR                           (volatile unsigned long *)0xd0105084
#define P_L_CPV1_VE_ADDR                           (volatile unsigned long *)0xd0105088
#define P_L_CPV2_HS_ADDR                           (volatile unsigned long *)0xd010508c
#define P_L_CPV2_HE_ADDR                           (volatile unsigned long *)0xd0105090
#define P_L_CPV2_VS_ADDR                           (volatile unsigned long *)0xd0105094
#define P_L_CPV2_VE_ADDR                           (volatile unsigned long *)0xd0105098
#define P_L_STV1_HS_ADDR                           (volatile unsigned long *)0xd010509c
#define P_L_STV1_HE_ADDR                           (volatile unsigned long *)0xd01050a0
#define P_L_STV1_VS_ADDR                           (volatile unsigned long *)0xd01050a4
#define P_L_STV1_VE_ADDR                           (volatile unsigned long *)0xd01050a8
#define P_L_STV2_HS_ADDR                           (volatile unsigned long *)0xd01050ac
#define P_L_STV2_HE_ADDR                           (volatile unsigned long *)0xd01050b0
#define P_L_STV2_VS_ADDR                           (volatile unsigned long *)0xd01050b4
#define P_L_STV2_VE_ADDR                           (volatile unsigned long *)0xd01050b8
#define P_L_OEV1_HS_ADDR                           (volatile unsigned long *)0xd01050bc
#define P_L_OEV1_HE_ADDR                           (volatile unsigned long *)0xd01050c0
#define P_L_OEV1_VS_ADDR                           (volatile unsigned long *)0xd01050c4
#define P_L_OEV1_VE_ADDR                           (volatile unsigned long *)0xd01050c8
#define P_L_OEV2_HS_ADDR                           (volatile unsigned long *)0xd01050cc
#define P_L_OEV2_HE_ADDR                           (volatile unsigned long *)0xd01050d0
#define P_L_OEV2_VS_ADDR                           (volatile unsigned long *)0xd01050d4
#define P_L_OEV2_VE_ADDR                           (volatile unsigned long *)0xd01050d8
#define P_L_OEV3_HS_ADDR                           (volatile unsigned long *)0xd01050dc
#define P_L_OEV3_HE_ADDR                           (volatile unsigned long *)0xd01050e0
#define P_L_OEV3_VS_ADDR                           (volatile unsigned long *)0xd01050e4
#define P_L_OEV3_VE_ADDR                           (volatile unsigned long *)0xd01050e8
#define P_L_LCD_PWR_ADDR                           (volatile unsigned long *)0xd01050ec
#define P_L_LCD_PWM0_LO_ADDR                       (volatile unsigned long *)0xd01050f0
#define P_L_LCD_PWM0_HI_ADDR                       (volatile unsigned long *)0xd01050f4
#define P_L_LCD_PWM1_LO_ADDR                       (volatile unsigned long *)0xd01050f8
#define P_L_LCD_PWM1_HI_ADDR                       (volatile unsigned long *)0xd01050fc
#define P_L_INV_CNT_ADDR                           (volatile unsigned long *)0xd0105100
#define P_L_TCON_MISC_SEL_ADDR                     (volatile unsigned long *)0xd0105104
#define P_L_DUAL_PORT_CNTL_ADDR                    (volatile unsigned long *)0xd0105108
#define P_MLVDS_CLK_CTL1_HI                        (volatile unsigned long *)0xd010510c
#define P_MLVDS_CLK_CTL1_LO                        (volatile unsigned long *)0xd0105110
//  [31:30] enable mlvds clocks
//  [24]    mlvds_clk_half_delay       24 // Bit 0
//  [23:0]  mlvds_clk_pattern           0 // Bit 23:0
#define P_L_TCON_DOUBLE_CTL                        (volatile unsigned long *)0xd0105124
#define P_L_TCON_PATTERN_HI                        (volatile unsigned long *)0xd0105128
#define P_L_TCON_PATTERN_LO                        (volatile unsigned long *)0xd010512c
#define P_LDIM_BL_ADDR_PORT                        (volatile unsigned long *)0xd0105138
#define P_LDIM_BL_DATA_PORT                        (volatile unsigned long *)0xd010513c
#define P_L_DE_HS_ADDR                             (volatile unsigned long *)0xd0105144
#define P_L_DE_HE_ADDR                             (volatile unsigned long *)0xd0105148
#define P_L_DE_VS_ADDR                             (volatile unsigned long *)0xd010514c
#define P_L_DE_VE_ADDR                             (volatile unsigned long *)0xd0105150
#define P_L_HSYNC_HS_ADDR                          (volatile unsigned long *)0xd0105154
#define P_L_HSYNC_HE_ADDR                          (volatile unsigned long *)0xd0105158
#define P_L_HSYNC_VS_ADDR                          (volatile unsigned long *)0xd010515c
#define P_L_HSYNC_VE_ADDR                          (volatile unsigned long *)0xd0105160
#define P_L_VSYNC_HS_ADDR                          (volatile unsigned long *)0xd0105164
#define P_L_VSYNC_HE_ADDR                          (volatile unsigned long *)0xd0105168
#define P_L_VSYNC_VS_ADDR                          (volatile unsigned long *)0xd010516c
#define P_L_VSYNC_VE_ADDR                          (volatile unsigned long *)0xd0105170
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define P_L_LCD_MCU_CTL                            (volatile unsigned long *)0xd0105174
//**************************************************************************
//*  Dual port mLVDS registers
//**************************************************************************
// bit 3 - enable_u_dual_mlvds_dp_clk
// bit 2 - enable_u_map_mlvds_r_clk
// bit 1 - enable_u_map_mlvds_l_clk
// bit 0 - dual_mlvds_en
#define P_DUAL_MLVDS_CTL                           (volatile unsigned long *)0xd0105180
// bit[12:0] - dual_mlvds_line_start 
#define P_DUAL_MLVDS_LINE_START                    (volatile unsigned long *)0xd0105184
// bit[12:0] - dual_mlvds_line_end 
#define P_DUAL_MLVDS_LINE_END                      (volatile unsigned long *)0xd0105188
// bit[12:0] - dual_mlvds_w_pixel_start_l 
#define P_DUAL_MLVDS_PIXEL_W_START_L               (volatile unsigned long *)0xd010518c
// bit[12:0] - dual_mlvds_w_pixel_end_l 
#define P_DUAL_MLVDS_PIXEL_W_END_L                 (volatile unsigned long *)0xd0105190
// bit[12:0] - dual_mlvds_w_pixel_start_r 
#define P_DUAL_MLVDS_PIXEL_W_START_R               (volatile unsigned long *)0xd0105194
// bit[12:0] - dual_mlvds_w_pixel_end_r 
#define P_DUAL_MLVDS_PIXEL_W_END_R                 (volatile unsigned long *)0xd0105198
// bit[12:0] - dual_mlvds_r_pixel_start_l 
#define P_DUAL_MLVDS_PIXEL_R_START_L               (volatile unsigned long *)0xd010519c
// bit[12:0] - dual_mlvds_r_pixel_cnt_l 
#define P_DUAL_MLVDS_PIXEL_R_CNT_L                 (volatile unsigned long *)0xd01051a0
// bit[12:0] - dual_mlvds_r_pixel_start_r 
#define P_DUAL_MLVDS_PIXEL_R_START_R               (volatile unsigned long *)0xd01051a4
// bit[12:0] - dual_mlvds_r_pixel_cnt_r 
#define P_DUAL_MLVDS_PIXEL_R_CNT_R                 (volatile unsigned long *)0xd01051a8
// bit[15]   - v_inversion_en
// bit[12:0] - v_inversion_pixel
#define P_V_INVERSION_PIXEL                        (volatile unsigned long *)0xd01051c0
// bit[15]   - v_inversion_sync_en
// bit[12:0] - v_inversion_line 
#define P_V_INVERSION_LINE                         (volatile unsigned long *)0xd01051c4
// bit[15:12]  - v_loop_r
// bit[11:10]  - v_pattern_1_r
// bit[9:8]    - v_pattern_0_r
// bit[7:4]    - v_loop_l
// bit[3:2]    - v_pattern_1_l
// bit[1:0]    - v_pattern_0_l
#define P_V_INVERSION_CONTROL                      (volatile unsigned long *)0xd01051c8
#define P_MLVDS2_CONTROL                           (volatile unsigned long *)0xd01051d0
   #define     mLVDS2_RESERVED  15    // 15
   #define     mLVDS2_double_pattern  14    // 14
   #define     mLVDS2_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS2_dual_gate  7
   #define     mLVDS2_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS2_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS2_msb_first  4
   #define     mLVDS2_PORT_SWAP  3
   #define     mLVDS2_MLSB_SWAP  2
   #define     mLVDS2_PN_SWAP    1
   #define     mLVDS2_en         0
#define P_MLVDS2_CONFIG_HI                         (volatile unsigned long *)0xd01051d4
#define P_MLVDS2_CONFIG_LO                         (volatile unsigned long *)0xd01051d8
   #define     mLVDS2_reset_offset         29 // Bit 31:29 
   #define     mLVDS2_reset_length         23 // Bit 28:23
   #define     mLVDS2_config_reserved      20 // Bit 22:20
   #define     mLVDS2_reset_start_bit12    19 // Bit 19
   #define     mLVDS2_data_write_toggle    18
   #define     mLVDS2_data_write_ini       17
   #define     mLVDS2_data_latch_1_toggle  16
   #define     mLVDS2_data_latch_1_ini     15
   #define     mLVDS2_data_latch_0_toggle  14
   #define     mLVDS2_data_latch_0_ini     13
   #define     mLVDS2_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS2_reset_start           0 // Bit 11:0
#define P_MLVDS2_DUAL_GATE_WR_START                (volatile unsigned long *)0xd01051dc
   #define     mlvds2_dual_gate_wr_start    0 // Bit 12:0
#define P_MLVDS2_DUAL_GATE_WR_END                  (volatile unsigned long *)0xd01051e0
   #define     mlvds2_dual_gate_wr_end      0 // Bit 12:0
#define P_MLVDS2_DUAL_GATE_RD_START                (volatile unsigned long *)0xd01051e4
   #define     mlvds2_dual_gate_rd_start    0 // Bit 12:0
#define P_MLVDS2_DUAL_GATE_RD_END                  (volatile unsigned long *)0xd01051e8
   #define     mlvds2_dual_gate_rd_end      0 // Bit 12:0
#define P_MLVDS2_SECOND_RESET_CTL                  (volatile unsigned long *)0xd01051ec
   #define     mLVDS2_2nd_reset_start       0 // Bit 12:0
#define P_MLVDS2_DUAL_GATE_CTL_HI                  (volatile unsigned long *)0xd01051f0
#define P_MLVDS2_DUAL_GATE_CTL_LO                  (volatile unsigned long *)0xd01051f4
   #define     mlvds2_tcon_field_en        24 // Bit 7:0
   #define     mlvds2_dual_gate_reserved   21 // Bit 2:0
   #define     mlvds2_scan_mode_start_line_bit12 20 // Bit 0
   #define     mlvds2_scan_mode_odd        16 // Bit 3:0
   #define     mlvds2_scan_mode_even       12 // Bit 3:0
   #define     mlvds2_scan_mode_start_line  0 // Bit 11:0
#define P_MLVDS2_RESET_CONFIG_HI                   (volatile unsigned long *)0xd01051f8
#define P_MLVDS2_RESET_CONFIG_LO                   (volatile unsigned long *)0xd01051fc
   #define     mLVDS2_reset_range_enable   31 // Bit 0
   #define     mLVDS2_reset_range_inv      30 // Bit 0
   #define     mLVDS2_reset_config_res1    29 // Bit 0
   #define     mLVDS2_reset_range_line_0   16 // Bit 11:0
   #define     mLVDS2_reset_config_res3    13 // Bit 2:0
   #define     mLVDS2_reset_range_line_1    0 // Bit 11:0
//**************************************************************************
//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
//**************************************************************************
#define P_GAMMA_CNTL_PORT                          (volatile unsigned long *)0xd0105200
   #define  GAMMA_VCOM_POL    7     //RW
   #define  GAMMA_RVS_OUT     6     //RW
   #define  ADR_RDY           5     //Read Only
   #define  WR_RDY            4     //Read Only
   #define  RD_RDY            3     //Read Only
   #define  GAMMA_TR          2     //RW
   #define  GAMMA_SET         1     //RW
   #define  GAMMA_EN          0     //RW
#define P_GAMMA_DATA_PORT                          (volatile unsigned long *)0xd0105204
#define P_GAMMA_ADDR_PORT                          (volatile unsigned long *)0xd0105208
   #define  H_RD              12
   #define  H_AUTO_INC        11
   #define  H_SEL_R           10
   #define  H_SEL_G           9
   #define  H_SEL_B           8
   #define  HADR_MSB          7            //7:0
   #define  HADR              0            //7:0
#define P_GAMMA_VCOM_HSWITCH_ADDR                  (volatile unsigned long *)0xd010520c
#define P_RGB_BASE_ADDR                            (volatile unsigned long *)0xd0105214
#define P_RGB_COEFF_ADDR                           (volatile unsigned long *)0xd0105218
#define P_POL_CNTL_ADDR                            (volatile unsigned long *)0xd010521c
   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
   #define   CPH3_POL         8
   #define   CPH2_POL         7
   #define   CPH1_POL         6
   #define   TCON_DE_SEL      5
   #define   TCON_VS_SEL      4
   #define   TCON_HS_SEL      3
   #define   DE_POL           2
   #define   VS_POL           1
   #define   HS_POL           0
#define P_DITH_CNTL_ADDR                           (volatile unsigned long *)0xd0105220
   #define  DITH10_EN         10
   #define  DITH8_EN          9
   #define  DITH_MD           8
   #define  DITH10_CNTL_MSB   7          //7:4
   #define  DITH10_CNTL       4          //7:4
   #define  DITH8_CNTL_MSB    3          //3:0
   #define  DITH8_CNTL        0          //3:0
//Bit 1 highlight_en 
//Bit 0 probe_en
#define P_GAMMA_PROBE_CTRL                         (volatile unsigned long *)0xd0105224
//read only
//Bit [15:0]  probe_color[15:0]
#define P_GAMMA_PROBE_COLOR_L                      (volatile unsigned long *)0xd0105228
//Read only
//Bit 15: if true valid probed color
//Bit [13:0]  probe_color[29:16]
#define P_GAMMA_PROBE_COLOR_H                      (volatile unsigned long *)0xd010522c
//bit 15:0, 5:6:5 color
#define P_GAMMA_PROBE_HL_COLOR                     (volatile unsigned long *)0xd0105230
//12:0 pos_x
#define P_GAMMA_PROBE_POS_X                        (volatile unsigned long *)0xd0105234
//12:0 pos_y
#define P_GAMMA_PROBE_POS_Y                        (volatile unsigned long *)0xd0105238
#define P_STH1_HS_ADDR                             (volatile unsigned long *)0xd0105240
#define P_STH1_HE_ADDR                             (volatile unsigned long *)0xd0105244
#define P_STH1_VS_ADDR                             (volatile unsigned long *)0xd0105248
#define P_STH1_VE_ADDR                             (volatile unsigned long *)0xd010524c
#define P_STH2_HS_ADDR                             (volatile unsigned long *)0xd0105250
#define P_STH2_HE_ADDR                             (volatile unsigned long *)0xd0105254
#define P_STH2_VS_ADDR                             (volatile unsigned long *)0xd0105258
#define P_STH2_VE_ADDR                             (volatile unsigned long *)0xd010525c
#define P_OEH_HS_ADDR                              (volatile unsigned long *)0xd0105260
#define P_OEH_HE_ADDR                              (volatile unsigned long *)0xd0105264
#define P_OEH_VS_ADDR                              (volatile unsigned long *)0xd0105268
#define P_OEH_VE_ADDR                              (volatile unsigned long *)0xd010526c
#define P_VCOM_HSWITCH_ADDR                        (volatile unsigned long *)0xd0105270
#define P_VCOM_VS_ADDR                             (volatile unsigned long *)0xd0105274
#define P_VCOM_VE_ADDR                             (volatile unsigned long *)0xd0105278
#define P_CPV1_HS_ADDR                             (volatile unsigned long *)0xd010527c
#define P_CPV1_HE_ADDR                             (volatile unsigned long *)0xd0105280
#define P_CPV1_VS_ADDR                             (volatile unsigned long *)0xd0105284
#define P_CPV1_VE_ADDR                             (volatile unsigned long *)0xd0105288
#define P_CPV2_HS_ADDR                             (volatile unsigned long *)0xd010528c
#define P_CPV2_HE_ADDR                             (volatile unsigned long *)0xd0105290
#define P_CPV2_VS_ADDR                             (volatile unsigned long *)0xd0105294
#define P_CPV2_VE_ADDR                             (volatile unsigned long *)0xd0105298
#define P_STV1_HS_ADDR                             (volatile unsigned long *)0xd010529c
#define P_STV1_HE_ADDR                             (volatile unsigned long *)0xd01052a0
#define P_STV1_VS_ADDR                             (volatile unsigned long *)0xd01052a4
#define P_STV1_VE_ADDR                             (volatile unsigned long *)0xd01052a8
#define P_STV2_HS_ADDR                             (volatile unsigned long *)0xd01052ac
#define P_STV2_HE_ADDR                             (volatile unsigned long *)0xd01052b0
#define P_STV2_VS_ADDR                             (volatile unsigned long *)0xd01052b4
#define P_STV2_VE_ADDR                             (volatile unsigned long *)0xd01052b8
#define P_OEV1_HS_ADDR                             (volatile unsigned long *)0xd01052bc
#define P_OEV1_HE_ADDR                             (volatile unsigned long *)0xd01052c0
#define P_OEV1_VS_ADDR                             (volatile unsigned long *)0xd01052c4
#define P_OEV1_VE_ADDR                             (volatile unsigned long *)0xd01052c8
#define P_OEV2_HS_ADDR                             (volatile unsigned long *)0xd01052cc
#define P_OEV2_HE_ADDR                             (volatile unsigned long *)0xd01052d0
#define P_OEV2_VS_ADDR                             (volatile unsigned long *)0xd01052d4
#define P_OEV2_VE_ADDR                             (volatile unsigned long *)0xd01052d8
#define P_OEV3_HS_ADDR                             (volatile unsigned long *)0xd01052dc
#define P_OEV3_HE_ADDR                             (volatile unsigned long *)0xd01052e0
#define P_OEV3_VS_ADDR                             (volatile unsigned long *)0xd01052e4
#define P_OEV3_VE_ADDR                             (volatile unsigned long *)0xd01052e8
#define P_LCD_PWR_ADDR                             (volatile unsigned long *)0xd01052ec
   #define      LCD_VDD        5
   #define      LCD_VBL        4
   #define      LCD_GPI_MSB    3
   #define      LCD_GPIO       0
#define P_LCD_PWM0_LO_ADDR                         (volatile unsigned long *)0xd01052f0
#define P_LCD_PWM0_HI_ADDR                         (volatile unsigned long *)0xd01052f4
#define P_LCD_PWM1_LO_ADDR                         (volatile unsigned long *)0xd01052f8
#define P_LCD_PWM1_HI_ADDR                         (volatile unsigned long *)0xd01052fc
#define P_INV_CNT_ADDR                             (volatile unsigned long *)0xd0105300
   #define     INV_EN          4
   #define     INV_CNT_MSB     3
   #define     INV_CNT         0
#define P_TCON_MISC_SEL_ADDR                       (volatile unsigned long *)0xd0105304
   #define     STH2_SEL        12
   #define     STH1_SEL        11
   #define     OEH_SEL         10
   #define     VCOM_SEL         9
   #define     DB_LINE_SW       8
   #define     CPV2_SEL         7
   #define     CPV1_SEL         6
   #define     STV2_SEL         5
   #define     STV1_SEL         4
   #define     OEV_UNITE        3
   #define     OEV3_SEL         2
   #define     OEV2_SEL         1
   #define     OEV1_SEL         0
#define P_DUAL_PORT_CNTL_ADDR                      (volatile unsigned long *)0xd0105308
   #define     OUTPUT_YUV       15
   #define     DUAL_IDF         12   // 14:12
   #define     DUAL_ISF         9    // 11:9
   #define     LCD_ANALOG_SEL_CPH3   8
   #define     LCD_ANALOG_3PHI_CLK_SEL   7
   #define     LCD_LVDS_SEL54   6
   #define     LCD_LVDS_SEL27   5
   #define     LCD_TTL_SEL      4
   #define     DUAL_LVDC_EN     3
   #define     PORT_SWP         2
   #define     RGB_SWP          1
   #define     BIT_SWP          0
#define P_MLVDS_CONTROL                            (volatile unsigned long *)0xd010530c
   #define     mLVDS_RESERVED  15    // 15
   #define     mLVDS_double_pattern  14    // 14
   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS_dual_gate  7
   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS_msb_first  4
   #define     mLVDS_PORT_SWAP  3
   #define     mLVDS_MLSB_SWAP  2
   #define     mLVDS_PN_SWAP    1
   #define     mLVDS_en         0
#define P_MLVDS_RESET_PATTERN_HI                   (volatile unsigned long *)0xd0105310
#define P_MLVDS_RESET_PATTERN_LO                   (volatile unsigned long *)0xd0105314
   #define     mLVDS_reset_pattern  0 // Bit 47:16
#define P_MLVDS_RESET_PATTERN_EXT                  (volatile unsigned long *)0xd0105318
   #define     mLVDS_reset_pattern_ext  0 // Bit 15:0
#define P_MLVDS_CONFIG_HI                          (volatile unsigned long *)0xd010531c
#define P_MLVDS_CONFIG_LO                          (volatile unsigned long *)0xd0105320
   #define     mLVDS_reset_offset         29 // Bit 31:29 
   #define     mLVDS_reset_length         23 // Bit 28:23
   #define     mLVDS_config_reserved      20 // Bit 22:20
   #define     mLVDS_reset_start_bit12    19 // Bit 19
   #define     mLVDS_data_write_toggle    18
   #define     mLVDS_data_write_ini       17
   #define     mLVDS_data_latch_1_toggle  16
   #define     mLVDS_data_latch_1_ini     15
   #define     mLVDS_data_latch_0_toggle  14
   #define     mLVDS_data_latch_0_ini     13
   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS_reset_start           0 // Bit 11:0
#define P_TCON_DOUBLE_CTL                          (volatile unsigned long *)0xd0105324
   #define     tcon_double_ini          8 // Bit 7:0
   #define     tcon_double_inv          0 // Bit 7:0
#define P_TCON_PATTERN_HI                          (volatile unsigned long *)0xd0105328
#define P_TCON_PATTERN_LO                          (volatile unsigned long *)0xd010532c
   #define     tcon_pattern_loop_data     16 // Bit 15:0
   #define     tcon_pattern_loop_start    12 // Bit 3:0
   #define     tcon_pattern_loop_end       8 // Bit 3:0
   #define     tcon_pattern_enable         0 // Bit 7:0
#define P_TCON_CONTROL_HI                          (volatile unsigned long *)0xd0105330
#define P_TCON_CONTROL_LO                          (volatile unsigned long *)0xd0105334
   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
#define P_LVDS_BLANK_DATA_HI                       (volatile unsigned long *)0xd0105338
#define P_LVDS_BLANK_DATA_LO                       (volatile unsigned long *)0xd010533c
   #define     LVDS_blank_data_reserved 30  // 31:30
   #define     LVDS_blank_data_r        20  // 29:20
   #define     LVDS_blank_data_g        10  // 19:10
   #define     LVDS_blank_data_b         0  //  9:0
#define P_LVDS_PACK_CNTL_ADDR                      (volatile unsigned long *)0xd0105340
   #define     LVDS_USE_TCON    7
   #define     LVDS_DUAL        6
   #define     PN_SWP           5
   #define     LSB_FIRST        4
   #define     LVDS_RESV        3
   #define     ODD_EVEN_SWP     2
   #define     LVDS_REPACK      0
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN7-TCON4)
// Bit 11:0 -- de_hs(old tcon) second offset_hs (new tcon)
#define P_DE_HS_ADDR                               (volatile unsigned long *)0xd0105344
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN3-TCON0)
#define P_DE_HE_ADDR                               (volatile unsigned long *)0xd0105348
#define P_DE_VS_ADDR                               (volatile unsigned long *)0xd010534c
#define P_DE_VE_ADDR                               (volatile unsigned long *)0xd0105350
#define P_HSYNC_HS_ADDR                            (volatile unsigned long *)0xd0105354
#define P_HSYNC_HE_ADDR                            (volatile unsigned long *)0xd0105358
#define P_HSYNC_VS_ADDR                            (volatile unsigned long *)0xd010535c
#define P_HSYNC_VE_ADDR                            (volatile unsigned long *)0xd0105360
#define P_VSYNC_HS_ADDR                            (volatile unsigned long *)0xd0105364
#define P_VSYNC_HE_ADDR                            (volatile unsigned long *)0xd0105368
#define P_VSYNC_VS_ADDR                            (volatile unsigned long *)0xd010536c
#define P_VSYNC_VE_ADDR                            (volatile unsigned long *)0xd0105370
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define P_LCD_MCU_CTL                              (volatile unsigned long *)0xd0105374
// ReadOnly 
//   R5G6B5 when R5G6B5_format
//   G8R8   when R8G8B8_format
//   G5R10  Other
#define P_LCD_MCU_DATA_0                           (volatile unsigned long *)0xd0105378
// ReadOnly
//   G8B8   when R8G8B8_format
//   G5B10  Other
#define P_LCD_MCU_DATA_1                           (volatile unsigned long *)0xd010537c
// LVDS
#define P_LVDS_GEN_CNTL                            (volatile unsigned long *)0xd0105380
#define P_LVDS_PHY_CNTL0                           (volatile unsigned long *)0xd0105384
#define P_LVDS_PHY_CNTL1                           (volatile unsigned long *)0xd0105388
#define P_LVDS_PHY_CNTL2                           (volatile unsigned long *)0xd010538c
#define P_LVDS_PHY_CNTL3                           (volatile unsigned long *)0xd0105390
#define P_LVDS_PHY_CNTL4                           (volatile unsigned long *)0xd0105394
#define P_LVDS_PHY_CNTL5                           (volatile unsigned long *)0xd0105398
#define P_LVDS_SRG_TEST                            (volatile unsigned long *)0xd01053a0
#define P_LVDS_BIST_MUX0                           (volatile unsigned long *)0xd01053a4
#define P_LVDS_BIST_MUX1                           (volatile unsigned long *)0xd01053a8
#define P_LVDS_BIST_FIXED0                         (volatile unsigned long *)0xd01053ac
#define P_LVDS_BIST_FIXED1                         (volatile unsigned long *)0xd01053b0
#define P_LVDS_BIST_CNTL0                          (volatile unsigned long *)0xd01053b4
#define P_LVDS_CLKB_CLKA                           (volatile unsigned long *)0xd01053b8
#define P_LVDS_PHY_CLK_CNTL                        (volatile unsigned long *)0xd01053bc
#define P_LVDS_SER_EN                              (volatile unsigned long *)0xd01053c0
#define P_LVDS_PHY_CNTL6                           (volatile unsigned long *)0xd01053c4
#define P_LVDS_PHY_CNTL7                           (volatile unsigned long *)0xd01053c8
#define P_LVDS_PHY_CNTL8                           (volatile unsigned long *)0xd01053cc
#define P_MLVDS_CLK_CTL0_HI                        (volatile unsigned long *)0xd01053d0
#define P_MLVDS_CLK_CTL0_LO                        (volatile unsigned long *)0xd01053d4
   #define     mlvds_clk_pattern_reserved 31 // Bit 31
   #define     mpclk_dly                  28 // Bit 2:0 
   #define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
   #define     use_mpclk                  25 // Bit 0
   #define     mlvds_clk_half_delay       24 // Bit 0
   #define     mlvds_clk_pattern           0 // Bit 23:0
#define P_MLVDS_DUAL_GATE_WR_START                 (volatile unsigned long *)0xd01053d8
   #define     mlvds_dual_gate_wr_start    0 // Bit 12:0
#define P_MLVDS_DUAL_GATE_WR_END                   (volatile unsigned long *)0xd01053dc
   #define     mlvds_dual_gate_wr_end      0 // Bit 12:0
#define P_MLVDS_DUAL_GATE_RD_START                 (volatile unsigned long *)0xd01053e0
   #define     mlvds_dual_gate_rd_start    0 // Bit 12:0
#define P_MLVDS_DUAL_GATE_RD_END                   (volatile unsigned long *)0xd01053e4
   #define     mlvds_dual_gate_rd_end      0 // Bit 12:0
#define P_MLVDS_SECOND_RESET_CTL                   (volatile unsigned long *)0xd01053e8
   #define     mLVDS_2nd_reset_start       0 // Bit 12:0
#define P_MLVDS_DUAL_GATE_CTL_HI                   (volatile unsigned long *)0xd01053ec
#define P_MLVDS_DUAL_GATE_CTL_LO                   (volatile unsigned long *)0xd01053f0
   #define     mlvds_tcon_field_en        24 // Bit 7:0
   #define     mlvds_dual_gate_reserved   21 // Bit 2:0
   #define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
   #define     mlvds_scan_mode_odd        16 // Bit 3:0
   #define     mlvds_scan_mode_even       12 // Bit 3:0
   #define     mlvds_scan_mode_start_line  0 // Bit 11:0
#define P_MLVDS_RESET_CONFIG_HI                    (volatile unsigned long *)0xd01053f4
#define P_MLVDS_RESET_CONFIG_LO                    (volatile unsigned long *)0xd01053f8
   #define     mLVDS_reset_range_enable   31 // Bit 0
   #define     mLVDS_reset_range_inv      30 // Bit 0
   #define     mLVDS_reset_config_res1    29 // Bit 0
   #define     mLVDS_reset_range_line_0   16 // Bit 11:0
   #define     mLVDS_reset_config_res3    13 // Bit 2:0
   #define     mLVDS_reset_range_line_1    0 // Bit 11:0
//===============================================================
//LCD DRIVER BASE   END
//===============================================================
//
// Closing file:  lcd_regs.h
//
//======================================================================
//   vpu  register.
//======================================================================
// -----------------------------------------------
// CBUS_BASE:  VPU_VCBUS_BASE = 0x27
// -----------------------------------------------
#define P_VPU_OSD1_MMC_CTRL                        (volatile unsigned long *)0xd0109c04
#define P_VPU_OSD2_MMC_CTRL                        (volatile unsigned long *)0xd0109c08
#define P_VPU_VD1_MMC_CTRL                         (volatile unsigned long *)0xd0109c0c
#define P_VPU_VD2_MMC_CTRL                         (volatile unsigned long *)0xd0109c10
#define P_VPU_DI_IF1_MMC_CTRL                      (volatile unsigned long *)0xd0109c14
#define P_VPU_DI_MEM_MMC_CTRL                      (volatile unsigned long *)0xd0109c18
#define P_VPU_DI_INP_MMC_CTRL                      (volatile unsigned long *)0xd0109c1c
#define P_VPU_DI_MTNRD_MMC_CTRL                    (volatile unsigned long *)0xd0109c20
#define P_VPU_DI_CHAN2_MMC_CTRL                    (volatile unsigned long *)0xd0109c24
#define P_VPU_DI_MTNWR_MMC_CTRL                    (volatile unsigned long *)0xd0109c28
#define P_VPU_DI_NRWR_MMC_CTRL                     (volatile unsigned long *)0xd0109c2c
#define P_VPU_DI_DIWR_MMC_CTRL                     (volatile unsigned long *)0xd0109c30
#define P_VPU_VDIN0_MMC_CTRL                       (volatile unsigned long *)0xd0109c34
#define P_VPU_VDIN1_MMC_CTRL                       (volatile unsigned long *)0xd0109c38
#define P_VPU_BT656_MMC_CTRL                       (volatile unsigned long *)0xd0109c3c
#define P_VPU_TVD3D_MMC_CTRL                       (volatile unsigned long *)0xd0109c40
#define P_VPU_TVDVBI_MMC_CTRL                      (volatile unsigned long *)0xd0109c44
//Read only
#define P_VPU_TVDVBI_VSLATCH_ADDR                  (volatile unsigned long *)0xd0109c48
//Read only
#define P_VPU_TVDVBI_WRRSP_ADDR                    (volatile unsigned long *)0xd0109c4c
#define P_VPU_VDIN_PRE_ARB_CTRL                    (volatile unsigned long *)0xd0109c50
#define P_VPU_VDISP_PRE_ARB_CTRL                   (volatile unsigned long *)0xd0109c54
#define P_VPU_VPUARB2_PRE_ARB_CTRL                 (volatile unsigned long *)0xd0109c58
#define P_VPU_OSD3_MMC_CTRL                        (volatile unsigned long *)0xd0109c5c
#define P_VPU_OSD4_MMC_CTRL                        (volatile unsigned long *)0xd0109c60
#define P_VPU_VD3_MMC_CTRL                         (volatile unsigned long *)0xd0109c64
// [31:11] Reserved.
// [10: 8] cntl_viu_vdin_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
//          3'b000=Disable VIU to VDIN path;
//          3'b001=Enable VIU of ENC_I domain to VDIN;
//          3'b010=Enable VIU of ENC_P domain to VDIN;
//          3'b100=Enable VIU of ENC_T domain to VDIN;
// [ 6: 4] cntl_viu_vdin_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
//          3'b000=Disable VIU to VDIN clock;
//          3'b001=Select encI clock to VDIN;
//          3'b010=Select encP clock to VDIN;
//          3'b100=Select encT clock to VDIN;
// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
#define P_VPU_VIU_VENC_MUX_CTRL                    (volatile unsigned long *)0xd0109c68
// [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
// [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
// [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
//                          0=output CrYCb(BRG);
//                          1=output YCbCr(RGB);
//                          2=output YCrCb(RBG);
//                          3=output CbCrY(GBR);
//                          4=output CbYCr(GRB);
//                          5=output CrCbY(BGR);
//                          6,7=Rsrv.
// [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
// [    3] inv_vsync. 1=Invert Vsync polarity.
// [    2] inv_hsync. 1=Invert Hsync polarity.
// [ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
#define P_VPU_HDMI_SETTING                         (volatile unsigned long *)0xd0109c6c
#define P_ENCI_INFO_READ                           (volatile unsigned long *)0xd0109c70
#define P_ENCP_INFO_READ                           (volatile unsigned long *)0xd0109c74
#define P_ENCT_INFO_READ                           (volatile unsigned long *)0xd0109c78
#define P_ENCL_INFO_READ                           (volatile unsigned long *)0xd0109c7c
// Bit  0 RW, viu_rst_n
// Bit  1 RW, vdin_mmc_arb_rst_n
// Bit  2 RW, vdisp_mmc_arb_rst_n
// Bit  3 RW, vpuarb2_mmc_arb_rst_n
#define P_VPU_SW_RESET                             (volatile unsigned long *)0xd0109c80
//Bit 30     d2d3_depr_req_sel,  0:vdisp_pre_arb, 1: vpuarb2_pre_arb
//Bit 27:22  d2d3_depr_brst_num
//Bit 21:16  d2d3_depr_id
//Bit 14     d2d3_depw_req_sel, 0: vdin_pre_arb, 1: vdisp_pre_arb
//Bit 11:6   d2d3_depw_brst_num
//Bit 5:0    d2d3_depw_id
#define P_VPU_D2D3_MMC_CTRL                        (volatile unsigned long *)0xd0109c84
//Bit 30     mtn_contrd_req_pre,  0:disp1_arb, 1: vdin_pre_arb
//Bit 27:22  mtn_contrd_brst_num
//Bit 21:16  mtn_contrd_id
//Bit 14     mtn_contwr_req_pre, 0: vdisp1_arb, 1: vdin_pre_arb
//Bit 11:6   mtn_contwr_brst_num
//Bit 5:0    mtn_contwr_id
#define P_VPU_CONT_MMC_CTRL                        (volatile unsigned long *)0xd0109c88
// Bit  6 RW, gclk_mpeg_vpu_misc
// Bit  5 RW, gclk_mpeg_venc_l_top
// Bit  4 RW, gclk_mpeg_vencl_int
// Bit  3 RW, gclk_mpeg_vencp_int
// Bit  2 RW, gclk_mpeg_vi2_top
// Bit  1 RW, gclk_mpeg_vi_top
// Bit  0 RW, gclk_mpeg_venc_p_top
#define P_VPU_CLK_GATE                             (volatile unsigned long *)0xd0109c8c
//Bit    12 RW, rdma_pre
//Bit 11: 6 RW, rdma_num
//Bit  5: 0 RW, rdma_id
#define P_VPU_RDMA_MMC_CTRL                        (volatile unsigned long *)0xd0109c90
#define P_VPU_MEM_PD_REG0                          (volatile unsigned long *)0xd0109c94
#define P_VPU_MEM_PD_REG1                          (volatile unsigned long *)0xd0109c98
// [   31] hdmi_data_ovr_en: 1=Enable overriding data input to HDMI TX with hdmi_data_ovr[29:0]. 0=No override. Default 0.
// [   30] Reserved.                                                                                            Default 0
// [29: 0] hdmi_data_ovr.                                                                                       Default 0.
#define P_VPU_HDMI_DATA_OVR                        (volatile unsigned long *)0xd0109c9c
//Bit    15 RW, prot1_sel_osd4
//Bit    14 RW, prot1_sel_osd3
//Bit    13 RW, prot1_sel_osd2
//Bit    12 RW, prot1_sel_osd1
//Bit 11: 6 RW, prot1_brst_num
//Bit  5: 0 RW, prot1_id
#define P_VPU_PROT1_MMC_CTRL                       (volatile unsigned long *)0xd0109ca0
//Bit    14 RW, prot2_sel_vd3
//Bit    13 RW, prot2_sel_vd2
//Bit    12 RW, prot2_sel_vd1
//Bit 11: 6 RW, prot2_brst_num
//Bit  5: 0 RW, prot2_id
#define P_VPU_PROT2_MMC_CTRL                       (volatile unsigned long *)0xd0109ca4
//Bit    14 RW, prot3_sel_vd3
//Bit    13 RW, prot3_sel_vd2
//Bit    12 RW, prot3_sel_vd1
//Bit 11: 6 RW, prot3_brst_num
//Bit  5: 0 RW, prot3_id
#define P_VPU_PROT3_MMC_CTRL                       (volatile unsigned long *)0xd0109ca8
//Bit 29:24 RW, s3_brst_num
//Bit 21:16 RW, s2_brst_num
//Bit 13: 8 RW, s1_brst_num
//Bit  5: 0 RW, s0_brst_num
#define P_VPU_ARB4_V1_MMC_CTRL                     (volatile unsigned long *)0xd0109cac
//Bit 29:24 RW, s3_brst_num
//Bit 21:16 RW, s2_brst_num
//Bit 13: 8 RW, s1_brst_num
//Bit  5: 0 RW, s0_brst_num
#define P_VPU_ARB4_V2_MMC_CTRL                     (volatile unsigned long *)0xd0109cb0
//Bit 31    reg_vpu_pwm_inv, 1: invert the pwm signal, active low
//Bit 30:29 reg_vpu_pwm_src_sel, 00: encl, enct, encp
//Bit 28:16 reg_vpu_pwm_v_end0 
//Bit 12:0  reg_vpu_pwm_v_start0 
#define P_VPU_VPU_PWM_V0                           (volatile unsigned long *)0xd0109cc0
//Bit 28:16 reg_vpu_pwm_v_end1 
//Bit 12:0  reg_vpu_pwm_v_start1 
#define P_VPU_VPU_PWM_V1                           (volatile unsigned long *)0xd0109cc4
//Bit 28:16 reg_vpu_pwm_v_end2 
//Bit 12:0  reg_vpu_pwm_v_start2 
#define P_VPU_VPU_PWM_V2                           (volatile unsigned long *)0xd0109cc8
//Bit 28:16 reg_vpu_pwm_v_end3 
//Bit 12:0  reg_vpu_pwm_v_start3 
#define P_VPU_VPU_PWM_V3                           (volatile unsigned long *)0xd0109ccc
//Bit 28:16 reg_vpu_pwm_h_end0 
//Bit 12:0  reg_vpu_pwm_h_start0 
#define P_VPU_VPU_PWM_H0                           (volatile unsigned long *)0xd0109cd0
//Bit 28:16 reg_vpu_pwm_h_end1 
//Bit 12:0  reg_vpu_pwm_h_start1 
#define P_VPU_VPU_PWM_H1                           (volatile unsigned long *)0xd0109cd4
//Bit 28:16 reg_vpu_pwm_h_end2 
//Bit 12:0  reg_vpu_pwm_h_start2 
#define P_VPU_VPU_PWM_H2                           (volatile unsigned long *)0xd0109cd8
//Bit 28:16 reg_vpu_pwm_h_end3 
//Bit 12:0  reg_vpu_pwm_h_start3 
#define P_VPU_VPU_PWM_H3                           (volatile unsigned long *)0xd0109cdc
//Bit 4    csi2_pre, 1: using vpu pre arbiter0, 0: using vpu pre arbiter2
//Bit 2:1  isp_in_sel, 01: select bt656, 10: select Mipi CSI2, otherwise select nothing  
//Bit 0,   if true, force vencl clk enable, otherwise, it might auto turn off by mipi DSI 
#define P_VPU_MISC_CTRL                            (volatile unsigned long *)0xd0109d00
#define P_VPU_ISP_GCLK_CTRL0                       (volatile unsigned long *)0xd0109d04
#define P_VPU_ISP_GCLK_CTRL1                       (volatile unsigned long *)0xd0109d08
// Picture Rotate (PROT) module 1 (for OSD) registers:
#define P_VPU_PROT1_CLK_GATE                       (volatile unsigned long *)0xd0109d40
#define P_VPU_PROT1_GEN_CNTL                       (volatile unsigned long *)0xd0109d44
#define P_VPU_PROT1_X_START_END                    (volatile unsigned long *)0xd0109d48
#define P_VPU_PROT1_Y_START_END                    (volatile unsigned long *)0xd0109d4c
#define P_VPU_PROT1_Y_LEN_STEP                     (volatile unsigned long *)0xd0109d50
#define P_VPU_PROT1_RPT_LOOP                       (volatile unsigned long *)0xd0109d54
#define P_VPU_PROT1_RPT_PAT                        (volatile unsigned long *)0xd0109d58
#define P_VPU_PROT1_DDR                            (volatile unsigned long *)0xd0109d5c
#define P_VPU_PROT1_RBUF_ROOM                      (volatile unsigned long *)0xd0109d60
#define P_VPU_PROT1_STAT_0                         (volatile unsigned long *)0xd0109d64
#define P_VPU_PROT1_STAT_1                         (volatile unsigned long *)0xd0109d68
#define P_VPU_PROT1_STAT_2                         (volatile unsigned long *)0xd0109d6c
#define P_VPU_PROT1_REQ_ONOFF                      (volatile unsigned long *)0xd0109d70
// Picture Rotate (PROT) module 2 (for VD) registers:
#define P_VPU_PROT2_CLK_GATE                       (volatile unsigned long *)0xd0109d80
#define P_VPU_PROT2_GEN_CNTL                       (volatile unsigned long *)0xd0109d84
#define P_VPU_PROT2_X_START_END                    (volatile unsigned long *)0xd0109d88
#define P_VPU_PROT2_Y_START_END                    (volatile unsigned long *)0xd0109d8c
#define P_VPU_PROT2_Y_LEN_STEP                     (volatile unsigned long *)0xd0109d90
#define P_VPU_PROT2_RPT_LOOP                       (volatile unsigned long *)0xd0109d94
#define P_VPU_PROT2_RPT_PAT                        (volatile unsigned long *)0xd0109d98
#define P_VPU_PROT2_DDR                            (volatile unsigned long *)0xd0109d9c
#define P_VPU_PROT2_RBUF_ROOM                      (volatile unsigned long *)0xd0109da0
#define P_VPU_PROT2_STAT_0                         (volatile unsigned long *)0xd0109da4
#define P_VPU_PROT2_STAT_1                         (volatile unsigned long *)0xd0109da8
#define P_VPU_PROT2_STAT_2                         (volatile unsigned long *)0xd0109dac
#define P_VPU_PROT2_REQ_ONOFF                      (volatile unsigned long *)0xd0109db0
// Picture Rotate (PROT) module 3 (for VD) registers:
#define P_VPU_PROT3_CLK_GATE                       (volatile unsigned long *)0xd0109dc0
#define P_VPU_PROT3_GEN_CNTL                       (volatile unsigned long *)0xd0109dc4
#define P_VPU_PROT3_X_START_END                    (volatile unsigned long *)0xd0109dc8
#define P_VPU_PROT3_Y_START_END                    (volatile unsigned long *)0xd0109dcc
#define P_VPU_PROT3_Y_LEN_STEP                     (volatile unsigned long *)0xd0109dd0
#define P_VPU_PROT3_RPT_LOOP                       (volatile unsigned long *)0xd0109dd4
#define P_VPU_PROT3_RPT_PAT                        (volatile unsigned long *)0xd0109dd8
#define P_VPU_PROT3_DDR                            (volatile unsigned long *)0xd0109ddc
#define P_VPU_PROT3_RBUF_ROOM                      (volatile unsigned long *)0xd0109de0
#define P_VPU_PROT3_STAT_0                         (volatile unsigned long *)0xd0109de4
#define P_VPU_PROT3_STAT_1                         (volatile unsigned long *)0xd0109de8
#define P_VPU_PROT3_STAT_2                         (volatile unsigned long *)0xd0109dec
#define P_VPU_PROT3_REQ_ONOFF                      (volatile unsigned long *)0xd0109df0
//========================================================================
//  MIPI CSI2 Controller Adaptor    (16'h2a00 - 16'h2aff)
//
//========================================================================
//
// Reading file:  csi2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// MIPI CSI2 ADAPTOR Registers 0x2a00 - 0x2aff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  CSI2_VCBUS_BASE = 0x2a
// -----------------------------------------------
// [31: 4] Rsrv.
// [    3] RW   cfg_clk_enable_dwc. 1=Enable clock to DWC_CSI_HOST IP. Default 1.
// [    2] RW   cfg_clk_auto_gate_off. 1=Disable auto clock gating. Default 0.
// [    1] RW   cfg_clk_enable. 1=Enable clock. Default 0.
// [    0] RW   cfg_sw_reset. 1=Reset. Default 1.
#define P_CSI2_CLK_RESET                           (volatile unsigned long *)0xd010a800
// [31:28] Rsrv.
// [   27] RW   cfg_clr_wrrsp. Applicable only to data to MEM path. Default 0.
//              1=Clear DDR write response counter.
// [   26] RW   cfg_ddr_en. Applicable only to data to MEM path. Default 0.
//              0=Disable writing to MEM; 1=Enable.
// [25:20] RW   cfg_A_brst_num. Applicable only to data to MEM path. Default 6'h3f.
// [19:14] RW   cfg_A_id. Applicable only to data to MEM path. Default 0.
// [   13] RW   cfg_urgent_en. Applicable only to data to MEM path. Default 0.
//              0=DDR request is non-urgent; 1=Urgent.
// [   12] RW   cfg_ddr_addr_lpbk. Applicable only to data to MEM path. Default 0.
//              0=When memory write address reaches the define end addr, continuing incrementing;
//              1=When memory write address reaches the define end addr, loop back to start addr.
// [   11] RW   cfg_buffer_pic_size. Applicable only to data to VDIN path. Default 0.
//              0=For active video size status, use non-buffered/instataneous line/pixel count;
//              1=For active video size status, use line/pixel count that are buffered at end of field.
// [   10] RW   cfg_422to444_mode. Applicable only to data to VDIN path. Default 0.
//              0=Converting 422 to 444 by repeat pixel;
//              1=Converting 422 to 444 by average pixel.
// [    9] RW   cfg_inv_field. Applicable only to interlace video to VDIN path. Default 0.
//              0=first field is odd; 1=first field is even.
// [    8] RW   cfg_interlace_en. Applicable only to data to VDIN path. Default 0.
//              0=Progressive; 1=Interlace.
// [    7] RW   cfg_force_line_count. Applicable only to data to VDIN path. Default 0.
//              0=Do not limit field height;
//              1=Limit field height by CSI2_FORCE_PIC_SIZE.
// [    6] RW   cfg_force_pix_count. Applicable only to data to VDIN path. Default 0.
//              0=Do not limit line width;
//              1=Limit line width by CSI2_FORCE_PIC_SIZE.
// [    5] RW   cfg_color_expand. Applicable only to data to VDIN path. Default 0.
//              0=Expand less than 10-bit component to 10-bit, by appending 0;
//              1=Expand less than 10-bit component to 10-bit, by appending MSBs.
// [    4] RW   cfg_all_to_mem. Default 0.
//              0=Depends on data type, some type might go to VDIN path, some might go to memory;
//              1=All data will go to memory, regardless of data type.
// [ 3: 0] RW   cfg_virtual_channel_en. Enable one or more virtual channels.
//              E.g. set to 4'b0111 to enable virtual channel 0, 1 and 2. Default 0.
#define P_CSI2_GEN_CTRL0                           (volatile unsigned long *)0xd010a804
// [31:16] RW   cfg_line_count. Applicable only to data to VDIN path. Default 0.
//              Limit field height to be no more cfg_line_count if cfg_force_line_count=1.
//              E.g. set to 480 to limit field height to 480.
// [15: 0] RW   cfg_pix_count. Applicable only to data to VDIN path. Default 0.
//              Limit line width to be no more cfg_pix_count if cfg_force_pix_count=1.
//              E.g. set to 720 to limit line width to 720.
#define P_CSI2_FORCE_PIC_SIZE                      (volatile unsigned long *)0xd010a808
// [31: 0] RW   DDR start address. [2:0] must be 0.
#define P_CSI2_DDR_START_ADDR                      (volatile unsigned long *)0xd010a80c
// [31: 0] RW   DDR end address. [2:0] must be 0.
#define P_CSI2_DDR_END_ADDR                        (volatile unsigned long *)0xd010a810
// [31:19] Rsrv.
// [18:16] RW   interrupt status/clear. Default 0.
//              [16] vs_rise sticky status, write 1 to clear it;
//              [17] vs_fall sticky status, write 1 to clear it;
//              [16] field_done_int sticky status, write 1 to clear it.
// [15: 3] Rsrv.
// [ 2: 0] RW   cfg_interrupt_sel. Enable one or more interrupts. Default 0.
//              [0]=1 to enable vs_rise interrupt;
//              [1]=1 to enable vs_fall interrupt;
//              [2]=1 to enable field_done_int interrupt.
#define P_CSI2_INTERRUPT_CTRL_STAT                 (volatile unsigned long *)0xd010a814
// [31:16] R    line_count measure for VDIN path only. Maybe buffered or non-buffered, depends on cfg_buffer_pic_size.
// [15: 0] R    pix_count measure for VDIN path only. Maybe buffered or non-buffered, depends on cfg_buffer_pic_size.
#define P_CSI2_PIC_SIZE_STAT                       (volatile unsigned long *)0xd010a818
// [31:21] Rsrv.
// [   20] R    pending_ddr_wrrsp.
// [19:12] R    mem_fifo_count.
// [11:10] Rsrv.
// [    9] R    afifo_nempty.
// [    8] R    afifo_full.
// [ 7: 6] Rsrv.
// [ 5: 0] R    afifo_count.
#define P_CSI2_GEN_STAT0                           (volatile unsigned long *)0xd010a81c
// [31: 0] R    Current actual memory pointer.
#define P_CSI2_DDR_WRPT_STAT                       (volatile unsigned long *)0xd010a820
// [31: 0] R    DDR start address for embedded data at the start of frame, MEM path only.
#define P_CSI2_FS_EMBED_DDR_START                  (volatile unsigned long *)0xd010a824
// [31: 0] R    DDR end address for embedded data at the start of frame, MEM path only.
#define P_CSI2_FS_EMBED_DDR_END                    (volatile unsigned long *)0xd010a828
// [31: 0] R    DDR start address for embedded data at the end of frame, MEM path only.
#define P_CSI2_FE_EMBED_DDR_START                  (volatile unsigned long *)0xd010a82c
// [31: 0] R    DDR end address for embedded data at the end of frame, MEM path only.
#define P_CSI2_FE_EMBED_DDR_END                    (volatile unsigned long *)0xd010a830
// [31:16] R    pixel_byte_cnt_eline for pixel-based data within a frame, MEM path only.
//              If pixel_byte_cnt%8 != 0, SW must increase the count to %8==0 for calculating line width in DDR,
// [15: 0] R    pixel_byte_cnt_oline for pixel-based data within a frame, MEM path only.
//              If pixel_byte_cnt%8 != 0, SW must increase the count to %8==0 for calculating line width in DDR,
//              however the value data bytes within a line is only defined by pixel_byte_cnt.
#define P_CSI2_MEM_PIXEL_BYTE_CNT                  (volatile unsigned long *)0xd010a834
// [31:16] Rsrv.
// [15: 0] R    pixel_line_cnt for pixel-based data within a frame, MEM path only.
#define P_CSI2_MEM_PIXEL_LINE_CNT                  (volatile unsigned long *)0xd010a838
// [31: 0] R    DDR start address for pixel-based data within a frame, MEM path only.
#define P_CSI2_PIXEL_DDR_START                     (volatile unsigned long *)0xd010a83c
// [31: 0] R    DDR end address for pixel-based data within a frame, MEM path only.
#define P_CSI2_PIXEL_DDR_END                       (volatile unsigned long *)0xd010a840
// [31: 0] R    DDR start address for user-defined data within a frame, MEM path only.
#define P_CSI2_USER_DDR_START                      (volatile unsigned long *)0xd010a844
// [31: 0] R    DDR end address for user-defined data within a frame, MEM path only.
#define P_CSI2_USER_DDR_END                        (volatile unsigned long *)0xd010a848
// [   31] user_started.
// [   30] Rsrv.
// [29:24] R    user_type. The data type code for user-defined data within a frame, MEM path only.
// [   23] pixel_started.
// [   22] Rsrv.
// [21:16] R    pixel_type. The data type code for pixel-based data within a frame, MEM path only.
// [   15] fe_embed_started.
// [14: 8] Rsrv
// [    7] fs_embed_started.
// [ 6: 0] Rsrv
#define P_CSI2_DATA_TYPE_IN_MEM                    (volatile unsigned long *)0xd010a84c
// A write (of any value) to this register clears all errors.
// [31:16] Rsrv.
// [   15] R    err_mem_user_interleave. User-defined data were interleaved with other type. Applicable to MEM path only.
// [   14] R    err_mem_pixel_interleave. Pixel data were interleaved with other type. Applicable to MEM path only.
// [   13] R    err_mem_fe_embed_interleave. Frame-end embedded data were interleaved with other type. Applicable to MEM path only.
// [   12] R    err_mem_fs_embed_interleave. Frame-start embedded data were interleaved with other type. Applicable to MEM path only.
// [   11] R    err_mem_user_type. User-defined data type info not consistent on a line-by-line basis. Applicable to MEM path only.
// [   10] R    err_mem_pixel_type. Pixel-based data type info not consistent on a line-by-line basis. Applicable to MEM path only.
// [    9] R    err_mem_pixel_byte_cnt_eline. Pixel-based data byte_cnt info not consistent on a line-by-line basis, for even pixel line. Applicable to MEM path only.
// [    8] R    err_mem_pixel_byte_cnt_oline. Pixel-based data byte_cnt info not consistent on a line-by-line basis, for odd pixel line. Applicable to MEM path only.
// [    7] R    err_mem_ddr_ovfl. DDR write pointer exceeded end addr. Applicable to MEM path only.
// [    6] R    warn_mem_ddr_wrap. DDR write pointer wrapped around. Applicable to MEM path only.
// [    5] R    err_mem_fifo_ovfl. MEM FIFO overflow. Applicable to MEM path only.
// [    4] R    err_mem_le_missed. Line end missed. Applicable to MEM path only.
// [    3] R    err_mem_ls_missed. Line start missed. Applicable to MEM path only.
// [    2] R    err_afifo_ovfl. Async FIFO overflow.
// [    1] R    err_wc_ovfl. Incoming data's word_count is more than payload.
// [    0] R    err_wc_unfl. Incoming data's word_count is less than payload.
#define P_CSI2_ERR_STAT0                           (volatile unsigned long *)0xd010a850
// [31: 8] Rsrv.
// [ 7: 6] RW   cfg_din_byte3_sel: Re-map the received 32-bit data's byte3. default 3.
//              0=Use input data's byte0 as actual byte3;
//              1=Use input data's byte1 as actual byte3;
//              2=Use input data's byte2 as actual byte3;
//              3=Use input data's byte3 as actual byte3;
// [ 5: 4] RW   cfg_din_byte2_sel: Re-map the received 32-bit data's byte2. default 2.
//              0=Use input data's byte0 as actual byte2;
//              1=Use input data's byte1 as actual byte2;
//              2=Use input data's byte2 as actual byte2;
//              3=Use input data's byte3 as actual byte2;
// [ 3: 2] RW   cfg_din_byte1_sel: Re-map the received 32-bit data's byte1. default 1.
//              0=Use input data's byte0 as actual byte1;
//              1=Use input data's byte1 as actual byte1;
//              2=Use input data's byte2 as actual byte1;
//              3=Use input data's byte3 as actual byte1;
// [ 1: 0] RW   cfg_din_byte0_sel: Re-map the received 32-bit data's byte0. default 0.
//              0=Use input data's byte0 as actual byte0;
//              1=Use input data's byte1 as actual byte0;
//              2=Use input data's byte2 as actual byte0;
//              3=Use input data's byte3 as actual byte0;
#define P_CSI2_GEN_CTRL1                           (volatile unsigned long *)0xd010a854
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  csi2_regs.h
//
//======================================================================
// D2D3 registers 
//======================================================================
//`define     D2D3_VCBUS_BASE         8'h2b
//
// Reading file:  d2d3_regs.h
//
//===========================================================================
// D2D3 Registers    0x - 0x
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  D2D3_VCBUS_BASE = 0x2b
// -----------------------------------------------
//------------------------------------------------------------------------------
// D2D3 top-level registers
//------------------------------------------------------------------------------
// Bit 31    RW, rd_lock_en,     1 to allow update some read-only registers based on filed
// Bit 30    RW, sw_rst_nobuf,   1 to reset the whole d2d3 unit
// Bit 29:28 RW, clk_auto_dis,   [29] DBR clock disable
//                               [28] DPG clock disable
// Bit 27:16 RW, clk_ctrl,       [27:26] gated clock control for register unit 
//                               [25:24] gated clock control for DBR unit
//                               [23:22] gated clock control for LBDG unit
//                               [21:20] gated clock control for MBDG unit
//                               [19:18] gated clock control for CBDG unit
//                               [17:16] gated clock control for DBLD unit and SCD81 unit
// Bit 15:12 Reserved  
// Bit 11    RW, lo_chroma_sign, 0: negate the u/v component of DBR left channel video output, 1: bypass
// Bit 10    RW, ro_chroma_sign, 0: negate the u/v component of DBR right channel video output, 1: bypass
// Bit 9     RW, vi0_chroma_sign, 0: negate the u/v component of DPG video input, 1: bypass   
// Bit 8     RW, vi1_chroma_sign, 0: negate the u/v component of DBR video input, 1: bypass
// Bit 7:5   Reserved 
// Bit 4     RW, lg_en,          Enable the LBDG unit and LBDG clock        
// Bit 3     RW, mg_en,          Enable the MBDG unit and MBDG clock
// Bit 2     RW, cg_en,          Enable the CBDG unit and CBDG clock
// Bit 1     RW, dbr_en,         Enable the DBR unit and DBR clock
// Bit 0     RW, dpg_en,         Enable the DPG unit and clock except sub-unit CBDG, MBDG and LBDG
#define P_D2D3_GLB_CTRL                            (volatile unsigned long *)0xd010ac00
// Indicate the input picture size in DPG unit
// Bit 31:16 RW, szx_vi_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vi_m1,      The vertical size minus 1
#define P_D2D3_DPG_INPIC_SIZE                      (volatile unsigned long *)0xd010ac04
// Indicate the output picture size in DBR unit
// Bit 31:16 RW, szx_vo_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vo_m1,      The vertical size minus 1
#define P_D2D3_DBR_OUTPIC_SIZE                     (volatile unsigned long *)0xd010ac08
// Indicate the rectangular window to generate the "depth" in DPG unit 
// Bit 31:16 RW, dg_win_x_start, Horizontal start position, count from 0
// Bit 15:0  RW, dg_win_x_end,   Horizontal end position, count from 0
#define P_D2D3_DGEN_WIN_HOR                        (volatile unsigned long *)0xd010ac0c
// Indicate the rectangular window to generate the "depth" in DPG unit 
// Bit 31:16 RW, dg_win_y_start, Vertical start position, count from 0
// Bit 15:0  RW, dg_win_y_end,   Vertical end position, count from 0
#define P_D2D3_DGEN_WIN_VER                        (volatile unsigned long *)0xd010ac10
//------------------------------------------------------------------------------
// CBDG SCU18 SCD81 SCD81_PRE registers
// cg: color based depth generate module
// scu18: scale up module
// scd81: scale down module
// scd81_pre: scd81 pre-scale-down module
//------------------------------------------------------------------------------
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_hphs_step, horizontal step
// Bit 15:0  RW, scd81_hphs_ini, horizontal initial phase
#define P_D2D3_PRE_SCD_H                           (volatile unsigned long *)0xd010ac14
// Bit 31:16 RW, scu18_iniph,    initial phase in SCU18, 
//                               [23:16] indicate the horizontal phase offset from the first data of every line
//                               [31:24] indicate the vertical phase offset from the first line of every frame
// Bit 15:12 Reserved
// Bit 11    RW, scd81_predrop_en, 1 to enable scd81 pre-scale-down function
// Bit 10:9  RW, cg_csc_sel,     Color Space Conversion(CSC) matrix mode selector in CBDG 
//                               0: BT.601 (16-235/240)
//                               1: BT.709 (16-235/240)
//                               2: BT.601 (0-255)
//                               3: BT.709 (0-255)
// Bit 8     RW, scu18_rep_en,   1 to double each line of the SCU18 output 
// Bit 7:4   RW, scu18_factor,   up-scale factor in SCU18 on DBR input depth data 
//                               [7:6] for vertical, 0->1:1, 1->1:2, 2->1:4, 3->1:8
//                               [5:4] for horizontal, 0->1:1, 1->1:2, 2->1:4, 3->1:8
// Bit 3:0   RW, scd81_factor,   down-scale factor in SCD81 on DPG source video 
//                               [3:2] for vertical, 0->1:1, 1->2:1, 2->4:1, 3->8:1
//                               [1:0] for horizontal, 0->1:1, 1->2:1, 2->4:1, 3->8:1
#define P_D2D3_SCALER_CTRL                         (volatile unsigned long *)0xd010ac18
// Bit 31:24 RW, cg_rpg_dth,     the down |r-g| threshold for sky detect 
// Bit 23:16 RW, cg_rpg_uth,     the up |r-g| threshold for sky detect 
// Bit 15:8  RW, cg_lum_dth,     the down Y threshold for sky detect  
// Bit 7:0   RW, cg_lum_uth,     the up Y threshold for sky detect  
#define P_D2D3_CG_THRESHOLD_1                      (volatile unsigned long *)0xd010ac1c
// Bit 31:24 RW, cg_rpb_dth,     the down |r-b| threshold for sky detect
// Bit 23:16 RW, cg_rpb_uth,     the up |r-b| threshold for sky detect
// Bit 15:8  RW, cg_bpg_dth,     the down |b-g| threshold for sky detect
// Bit 7:0   RW, cg_bpg_uth,     the up |b-g| threshold for sky detect 
#define P_D2D3_CG_THRESHOLD_2                      (volatile unsigned long *)0xd010ac20
// Bit 31:24 RW, cg_vp_rel_k,    parameter to calculate vanish point reliability
// Bit 23:16 RW, cg_vp_y_thr,    the max limitation to calculate the vanish-point's vertical position
// Bit 15:8  RW, cg_meet_dval,   signed depth value in the sky-bitmap 
// Bit 7:0   RW, cg_unmt_dval,   signed depth value not in the sky-bitmap
#define P_D2D3_CG_PARAM_1                          (volatile unsigned long *)0xd010ac24
// Bit 31:16 RW, cg_vpos_thr,    Maximal vertical limitation for sky-bit map when cg_vpos_en=1 and cg_vpos_adpt_en=0
// Bit 15:8  Reserved
// Bit 7     RW, cg_vpos_en,     1 to enable the max vertical limitation for sky-bitmap
// Bit 6     RW, cg_vpos_adpt_en, 1 to enable the adaptive max vertical limitation for sky-bitmap. 
//                               It is only valid when cg_vpos_en=1.
//                               The max vertical limitation is the previous field's vanish-point (vertical position) if cg_vpos_adpt_en=1. 
// Bit 5:4   RW, cg_lpf_bypass,  bypass of low pass filter 
//                               [5]:Vertical bypass, 1: bypass the vertical LPF on the CBDG depth
//                               [4]:Horizontal bypass, 1: bypass the horizontal LPF on the CBDG depth
// Bit 3:0   RW, cg_vp_rel_s,    parameter to calculate vanish point reliability
#define P_D2D3_CG_PARAM_2                          (volatile unsigned long *)0xd010ac28
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_vphs_step, vertical step
// Bit 15:0  RW, scd81_vphs_ini, vertical initial phase
#define P_D2D3_PRE_SCD_V                           (volatile unsigned long *)0xd010ac2c
//------------------------------------------------------------------------------
// D2P registers
// d2p: depth to parallax transform module
//------------------------------------------------------------------------------
// Bit 31:24 RW, d2p_brdwid,     Horizontal boundary width for parallax, the parallax value would be forced to 0 in boundary, 
//                               the d2p_brdwid should not 0 when D2P_WRAP is enabled
// Bit 23:22 Reserved
// Bit 21:20 RW, d2p_lomode,     line output mode, 
//                               0:whole line is left or right;  1:whole line is left or right;
//                               2:left/right pixel interleaved;  3:left/right half-line interleaved
// Bit 19    RW, d2p_neg,        1 to exchange the left and right parallax value
// Bit 18    Reserved 
// Bit 17    RW, d2p_wrap_en,    1 to enable D2P_WRAP unit
// Bit 16    RW, d2p_lar,        Indicate the first output for left or right, 0: left; 1: right
// Bit 15    RW, d2p_lr_switch,  enable left/right flag filed switch automatically, only valid when parallax output mode is field interleaved
// Bit 14    RW, d2p_1dtolr,     enable to generate 2 parallax data (left and right) from one depth
// Bit 13:12 RW, d2p_out_mode,   Parallax output mode 
//                               0:left/right pixel interleaved; 1:line or half line interleaved; 2:field interleaved
// Bit 11:8  RW, d2p_smode,      Shift mode,
//                               0: no shift; 1: enable left shift;
//                               2: enable right shift; 3: both left and right shift are enabled
// Bit 7:0   RW, d2p_offset,     depth offset, signed, 
#define P_D2D3_D2P_PARAM_1                         (volatile unsigned long *)0xd010ac30
// Bit 31:24 RW, d2p_pg0,        positive parallax gain when Parallax value < pt
// Bit 23:16 RW, d2p_pg1,        positive parallax gain when Parallax value >= pt
// Bit 15:8  RW, d2p_pt,         unsigned value used to separate the positive parallax range
// Bit 7:0   RW, d2p_plimit,     The limitation for positive parallax
#define P_D2D3_D2P_PARAM_2                         (volatile unsigned long *)0xd010ac34
// Bit 31:24 RW, d2p_ng0,        negative parallax gain when Parallax value > -nt
// Bit 23:16 RW, d2p_ng1,        negative parallax gain when Parallax value <= -nt
// Bit 15:8  RW, d2p_nt,         unsigned value used to separate the negative parallax range
// Bit 7:0   RW, d2p_nlimit,     The limitation for negative parallax
#define P_D2D3_D2P_PARAM_3                         (volatile unsigned long *)0xd010ac38
// Indicate step parameters of SCU18 unit
// Bit 31:17 Reserved
// Bit 16    RW, scu18_step_en,   step set enable in SCU18
// Bit 15:8  RW, scu18_hphs_step, horizontal step in SCU18
// Bit 7:0   RW, scu18_vphs_step, vertical step in SCU18
#define P_D2D3_SCU18_STEP                          (volatile unsigned long *)0xd010ac3c
//------------------------------------------------------------------------------
// LBDG and DBLD registers
// lg: luma based depth generate module
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:22 Reserved
// Bit 21:20 RW, db_lpf_bpcoeff, [21]:Vertical factor of low pass filter, 
//                               1: Vfactor = 0/0/64/0/0, 0: Vfactor = {db_vf_a,db_vf_b,db_vf_c,db_vf_b,db_vf_a}, see D2D3_CTRL_15
//                               [20]:Horizontal factor of low pass filter, 
//                               1: Hfactor = 0/0/64/0/0, 0: Hfactor = {db_hf_a,db_hf_b,db_hf_c,db_hf_b,db_hf_a}, see D2D3_CTRL_14
// Bit 19:18 RW, lg_lpf_bpcoeff, [19]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [18]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 17:16 RW, cg_lpf_bpcoeff, [17]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [16]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 15:10 Reserved
// Bit 9:8   RW, db_lpf_bypass,  [9] 1 to bypass the vertical LPF on the DBLD depth
//                               [8] 1 to bypass the horizontal LPF on the DBLD depth
// Bit 7:6   RW, lg_lpf_bypass,  [7] 1 to bypass the vertical LPF on the LBDG depth
//                               [6] 1 to bypass the horizontal LPF on the LBDG depth
// Bit 5:0   RW, lg_kc,          gain of CPL(v-u+256-y) to calculate the depth in LBDG
#define P_D2D3_DPF_LPF_CTRL                        (volatile unsigned long *)0xd010ac40
//------------------------------------------------------------------------------
// DBLD registers
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:24 RW, db_g2_cg,       gain of CBDG depth in DBLD
// Bit 23:16 RW, db_o2_cg,       offset of CBDG depth in DBLD
// Bit 15:8  RW, db_g1_cg,       gain of CBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_cg,       offset of CBDG depth using for summary in DBLD
#define P_D2D3_DBLD_CG_PARAM                       (volatile unsigned long *)0xd010ac44
// Bit 31:24 RW, db_g2_mg,       gain of MBDG depth in DBLD
// Bit 23:16 RW, db_o2_mg,       offset of MBDG depth in DBLD
// Bit 15:8  RW, db_g1_mg,       gain of MBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_mg,       offset of MBDG depth using for summary in DBLD
#define P_D2D3_DBLD_MG_PARAM                       (volatile unsigned long *)0xd010ac48
// Bit 31:24 RW, db_g2_lg,       gain of LBDG depth in DBLD
// Bit 23:16 RW, db_o2_lg,       offset of LBDG depth in DBLD
// Bit 15:8  RW, db_g1_lg,       gain of LBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_lg,       offset of LBDG depth using for summary in DBLD
#define P_D2D3_DBLD_LG_PARAM                       (volatile unsigned long *)0xd010ac4c
// Bit 31:24 RW, db_factor,      unsigned gain of difference in DBLD
// Bit 23:16 RW, db_hf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_hf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_hf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define P_D2D3_DBLD_LPF_HCOEFF                     (volatile unsigned long *)0xd010ac50
// Bit 31:24 RW, db_owin_fill,   signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 23:16 RW, db_vf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_vf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_vf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define P_D2D3_DBLD_LPF_VCOEFF                     (volatile unsigned long *)0xd010ac54
// Bit 31:28 RW, hist_depth_idx,     
// Bit 27:26 Reserved   
// Bit 25    RW, mbdg_dep_neg,   1 to negate the output data of MBDG
// Bit 24    RW, lbdg_dep_neg,   1 to negate the output data of LBDG
// Bit 23:16 RW, db_f1_ctrl,     MUX1 selector
//                               [1:0] MUX1 path1 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX1 path2 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX1 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX1out0, others:summary
//                               [7] MUX1OUT0 selector, 0:MIN (MUX1PATH1,MUX1Path2), 1:MAX (MUX1Path1,MUX1Path2)
// Bit 15:8  RW, db_f2_ctrl,     MUX2 selector
//                               [1:0] MUX2 path1 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX2 path2 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX2 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX2out0, others:MUX2out0
//                               [7] MUX2OUT0 selector, 0:MIN (MUX2PATH1,MUX2Path2), 1:MAX (MUX2Path1,MUX2Path2)
// Bit 7:4   RW, db_fifo0_sel,   the source input of FIFO0
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG others:reserved
// Bit 3:0   RW, db_fifo1_sel,   the source input of FIFO1
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG 4: from FIFO0; others:reserved
#define P_D2D3_DBLD_PATH_CTRL                      (volatile unsigned long *)0xd010ac58
// Indicate the input picture size in SCU18 unit
// Bit 31:16 RW, szy_scui,       The vertical size 
// Bit 15:0  RW, szx_scui,       The horizontal size 
#define P_D2D3_SCU18_INPIC_SIZE                    (volatile unsigned long *)0xd010ac5c
//------------------------------------------------------------------------------
// MBDG registers
// mg: model based depth generate module
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, mg_vp_en,       mdg vanish point enable, not used
// Bit 16    RW, mg_sw_en,       1 to use the software forced parameter for the point D, U and C in MBDG
// Bit 15:8  RW, mg_owin_fill,   Signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 7     RW, mg_iir_en,      1 to enable the 2-taps IIR filter in MBDG
// Bit 6:0   RW, mg_iir,         [6]: 1 to bypass the 2-taps IIR filter in MBDG
//                               [5:0]:Unsigned coefficient of the 2-taps IIR filter in MBDG
//                               [6]:bypass, 1:bypass, 0:not bypass
#define P_D2D3_MBDG_CTRL                           (volatile unsigned long *)0xd010ac60
// Bit 31:28 RW, mg_dtl_pxl_left, Max pixel number (1<< mg_dtl_pxl_left) using in the left window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_right, Max pixel number (1<< mg_dtl_pxl_right) using in the right window for activities in MBDG
// Bit 23:16 RW, mg_cx_sw,       Depth of point C in horizontal curve in MBDG for software forced
// Bit 15:8  RW, mg_ux_sw,       Depth of point U in horizontal curve in MBDG for software forced
// Bit 7:0   RW, mg_dx_sw,       Depth of point D in horizontal curve in MBDG for software forced
#define P_D2D3_MBDG_PARAM_0                        (volatile unsigned long *)0xd010ac64
// Bit 31:28 RW, mg_dtl_pxl_up,  Max pixel number (1<< mg_dtl_pxl_up) using in the top window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_dn,  Max pixel number (1<< mg_dtl_pxl_dn) using in the bottom window for activities in MBDG
// Bit 23:16 RW, mg_cy_sw,       Depth of point C in vertical curve in MBDG for software forced       
// Bit 15:8  RW, mg_uy_sw,       Depth of point U in vertical curve in MBDG for software forced
// Bit 7:0   RW, mg_dy_sw,       Depth of point D in vertical curve in MBDG for software forced
#define P_D2D3_MBDG_PARAM_1                        (volatile unsigned long *)0xd010ac68
// Bit 31:24 RW, mg_dtl_ln_up,   Line number in the top window for activities in MBDG
// Bit 23:16 RW, mg_dtl_ln_dn,   Line number in the bottom window for activities in MBDG
// Bit 15:8  RW, mg_dtl_ln_left, Column number in the left window for activities in MBDG
// Bit 7:0   RW, mg_dtl_ln_right,Column number in the right window for activities in MBDG
#define P_D2D3_MBDG_PARAM_2                        (volatile unsigned long *)0xd010ac6c
// Bit 31:24 RW, mg_y_max,       Software initial depth of point D and U in vertical curve
// Bit 23:16 RW, mg_y_min,       Software initial depth of point C in vertical curve
// Bit 15:8  RW, mg_x_max,       Software initial depth of point D and U in horizontal curve
// Bit 7:0   RW, mg_x_min,       Software initial depth of point C in horizontal curve
#define P_D2D3_MBDG_PARAM_3                        (volatile unsigned long *)0xd010ac70
// Bit 31:27 Reserved
// Bit 26    RW, mg_y_adapt_en,  1 to enable the adaptive mode for point U/D in vertical curve calculation
// Bit 25    RW, mg_xmm_adapt_en, 1 to enable the XMM adaptive mode for point U/D in horizontal curve calculation
// Bit 24    RW, mg_x_adapt_en,  1 to enable the adaptive mode for point U/D in horizontal curve calculation
// Bit 23:20 RW, mg_ytrans_1,    Shifter controller in vertical curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 19:16 RW, mg_xtrans_1,    Shifter controller in horizontal curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 15:8  RW, mg_yk_0,        The based activities value of the ACT for vertical curve
// Bit 7:0   RW, mg_xk_0,        The based activities value of the ACT for horizontal curve
#define P_D2D3_MBDG_PARAM_4                        (volatile unsigned long *)0xd010ac74
// Bit 31:24 RW, mg_ysu3,        Quantized value 3 in vertical curve adaptive calculation
// Bit 23:16 RW, mg_ysu2,        Quantized value 2 in vertical curve adaptive calculation
// Bit 15:8  RW, mg_ysu1,        Quantized value 1 in vertical curve adaptive calculation
// Bit 7:0   RW, mg_ysu0,        Quantized value 0 in vertical curve adaptive calculation
#define P_D2D3_MBDG_PARAM_5                        (volatile unsigned long *)0xd010ac78
// Bit 31:24 RW, mg_xsu3,        Quantized value 3 in horizontal curve adaptive calculation
// Bit 23:16 RW, mg_xsu2,        Quantized value 2 in horizontal curve adaptive calculation
// Bit 15:8  RW, mg_xsu1,        Quantized value 1 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_xsu0,        Quantized value 0 in horizontal curve adaptive calculation
#define P_D2D3_MBDG_PARAM_6                        (volatile unsigned long *)0xd010ac7c
// Bit 31:16 Reserved 
// Bit 15:8  RW, mg_xsu4,        Quantized value 4 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_ysu4,        Quantized value 4 in vertical curve adaptive calculation
#define P_D2D3_MBDG_PARAM_7                        (volatile unsigned long *)0xd010ac80
// Bit 31:28 RW, dbg_hscnt_sel   see DBG_STATUS_2
// Bit 27:25 Reserved 
// Bit 24    RW, dbg_dbr_en,     1 to enable debug mode in DBR
// Bit 23:16 RW, dbg_force_data, Forced data in debug mode
// Bit 15:12 RW, dbg_bld_ctrl,   debug controller for DBLD
//                               [12]:enable;  [13]: 0 for passive mode, 0 for handshake mode
//                               [15:14]: 0 for constant mode, 1 for step1 mode
// Bit 11:8  RW, dbg_mg_ctrl,    debug controller for MBDG
//                               [8]:enable;  [9]: 0 for passive mode, 0 for handshake mode
//                               [11:10]: 0 for constant mode, 1 for step1 mode
// Bit 7:4   RW, dbg_cg_ctrl,    debug controller for CBDG
//                               [4]:enable;  [5]: 0 for passive mode, 0 for handshake mode
//                               [7:6]: 0 for constant mode, 1 for step1 mode
// Bit 3:0   RW, dbg_lg_ctrl,    debug controller for LBDG
//                               [0]:enable;  [1]: 0 for passive mode, 0 for handshake mode
//                               [3:2]: 0 for constant mode, 1 for step1 mode
#define P_D2D3_DBG_CTRL                            (volatile unsigned long *)0xd010ac8c
//------------------------------------------------------------------------------
// DWMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved 
// Bit 17    RW, dw_x_rev        0: Normal write data from left to right in horizontal
//                               1: Reversed write data from left to right in horizontal
// Bit 16    RW, dw_y_rev        0: Normal write data from top to bottom in horizontal
//                               1: Reversed write data from bottom to top in horizontal  
// Bit 15    RW, dw_done_clr     1 to clear register depw_done (DWMIF_STATUS)
// Bit 14    RW, dw_little_endian, 0: data is ordered in big-endian, 1: little endian
// Bit 13:12 RW, dw_pic_struct,  0:read every line, 1:reserved, 2:read even line, 3:read odd line
// Bit 11    RW, dw_urgent,      urgent index
// Bit 10    RW, dw_clr_wrrsp,   1:clear the write fifo counter
// Bit 9     RW, dw_canvas_wr,   canvas write initialization again
// Bit 8     RW, dw_req_en,      1 to enable write request
// Bit 7:0   RW, dw_canvas_index,Canvas index for the MSB of memory address for memory write
#define P_D2D3_DWMIF_CTRL                          (volatile unsigned long *)0xd010ac90
// Bit 31    Reserved
// Bit 30:16 RW, dw_end_x,       Horizontal end position for memory write, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dw_start_x,     Horizontal start position for memory write, count by BYTE
#define P_D2D3_DWMIF_HPOS                          (volatile unsigned long *)0xd010ac94
// Bit 31:29 Reserved
// Bit 28:16 RW, dw_end_y,       Vertical end position for memory write, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dw_start_y,     Vertical start position for memory write, count by BYTE
#define P_D2D3_DWMIF_VPOS                          (volatile unsigned long *)0xd010ac98
// Bit 31:28 Reserved
// Bit 27:16 RW, dw_vsizem1,     Vertical size for memory write, equal the size minus 1
// Bit 15:12 Reserved
// Bit 11:0  RW, dw_hsizem1,     Horizontal size for memory write, equal the size minus 1
#define P_D2D3_DWMIF_SIZE                          (volatile unsigned long *)0xd010ac9c
//------------------------------------------------------------------------------
// DRMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, dr_y_rev,       0: Normal Read data from top to bottom in horizontal
//                               1: Reversed read data from bottom to top in horizontal
// Bit 16    RW, dr_x_rev,       0: Normal Read data from left to right in horizontal
//                               1: Reversed read data from right to left in horizontal
// Bit 15    RW, dr_clr_fifo_error, 1 to clear the overflow flag of the sticky FIFO
// Bit 14    RW, dr_little_endian, 0: data is ordered in big-endian; 1: little-endian
// Bit 13:12 RW, dr_pic_struct,  0: progressive;  1: Reserved;
//                               2: interlaced, even line;  3: interlaced, odd line
// Bit 11    RW, dr_urgent,      urgent index, no use in this system
// Bit 10:9  RW, dr_burst_size,  Burst read length for each request; 0=24,1=32,2=48,3=64
// Bit 8     RW, dr_req_en,      1 to enable read request
// Bit 7:0   RW, dr_canvas_index, Canvas index for the MSB of memory address for memory read
#define P_D2D3_DRMIF_CTRL                          (volatile unsigned long *)0xd010aca0
// Bit 31    Reserved
// Bit 30:16 RW, dr_end_x,       Horizontal end position for memory read, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dr_start_x,     Horizontal start position for memory read, count by BYTE
#define P_D2D3_DRMIF_HPOS                          (volatile unsigned long *)0xd010aca4
// Bit 31:29 Reserved
// Bit 28:16 RW, dr_end_y,       Vertical end position for memory read, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dr_start_y,     Vertical start position for memory read, count by BYTE
#define P_D2D3_DRMIF_VPOS                          (volatile unsigned long *)0xd010aca8
//------------------------------------------------------------------------------
// PDR registers
// ddd: parallax based render
//------------------------------------------------------------------------------
// Bit 31:8  Reserved
// Bit 7     RW, ddd_brdlpf_en,  1 to enable the smooth filter on the depth around the boundary
// Bit 6     RW, ddd_extn_black, 1 to enable the function to fill black colour when interpolated pixels is outside the picture in DBR
// Bit 5     RW, ddd_wrap_en,    Reserved
// Bit 4     RW, ddd_hhalf,      1 to indicate the left/right line length is a half of original line. 
// Bit 3:2   RW, ddd_out_mode,   Reserved
// Bit 1:0   RW, ddd_lomode,     wrap & pbr interleave mode:                                        
//                               2'b0x: whole line is left or right;                           
//                               2'b10: d2p_lar=1(D2P_PARAM_1), rlrlrlrl inteleave in one line,
//                                      d2p_lar=0(D2P_PARAM_1), lrlrlrlr inteleave in one line,      
//                               2'b11: d2p_lar=1(D2P_PARAM_1), rrrrrlllll, half line is right, another half is left,
//                                      d2p_lar=0(D2P_PARAM_1), lllllrrrrr, half line is left, another half is right,
#define P_D2D3_DBR_DDD_CTRL                        (volatile unsigned long *)0xd010acb0
// Bit 31:0  RW, ddd_dbg_ctrl,   no use
#define P_D2D3_DBR_DDD_DBG                         (volatile unsigned long *)0xd010acb4
//------------------------------------------------------------------------------
// LRDMX registers
//------------------------------------------------------------------------------
// Bit 31:9  Reserved
// Bit 8     RW, lr_merge,       1: all the left/right input go to the left channel output
// Bit 7:6   RW, lrd_ff0_sel,    FF0 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 5:4   RW, lrd_ff1_sel,    FF1 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 3:2   RW, lrd_lout_sel,   left channel DEMUX
//                               00: ff0  01:ff1   10: left input  11:right input
// Bit 1:0   RW, lrd_rout_sel,   right channel DEMUX
//                               00: ff1  01:ff0   10: left input  11:right input 
#define P_D2D3_DBR_LRDMX_CTRL                      (volatile unsigned long *)0xd010acbc
//------------------------------------------------------------------------------
// Read Only registers
//------------------------------------------------------------------------------
// Bit 31:24 RO, ro_cg_vprel,    vanish point's reliability in CBDG
// Bit 23:12 RO, ro_cg_vpx,      vanish point's X-Axis in CBDG
// Bit 11:0  RO, ro_cg_vpy,      vanish point's Y-Axis in CBDG
#define P_D2D3_CBDG_STATUS_1                       (volatile unsigned long *)0xd010acc0
// Bit 31:24 RO, ro_mg_cx[7:0],  X-Axis of point C in horizontal curve in MBDG
// Bit 23:16 RO, ro_mg_ux,       Depth value of point U in horizontal curve in MBDG
// Bit 15:8  RO, ro_mg_dx,       Depth value of point D in horizontal curve in MBDG
// Bit 7:0   RO, ro_mg_minx,     Depth value of point C in horizontal curve in MBDG
#define P_D2D3_MBDG_STATUS_1                       (volatile unsigned long *)0xd010acc4
// Bit 31:24 RO, ro_mg_cy[7:0],  X-Axis of point C in vertical curve in MBDG
// Bit 23:16 RO, ro_mg_uy,       Depth value of point U in vertical curve in MBDG
// Bit 15:8  RO, ro_mg_dy,       Depth value of point D in vertical curve in MBDG
// Bit 7:0   RO, ro_mg_miny,     Depth value of point C in vertical curve in MBDG
#define P_D2D3_MBDG_STATUS_2                       (volatile unsigned long *)0xd010acc8
// Bit 31    RO, ro_wrap_status, 1 indicate the D2P_WRAP is busy to perform the initialization
// Bit 30:8  Reserved 
// Bit 7:4   RO, ro_mg_cy[11:8], X-Axis of point C in vertical curve in MBDG
// Bit 3:0   RO, ro_mg_cx[11:8], X-Axis of point C in horizontal curve in MBDG
#define P_D2D3_MBDG_STATUS_3                       (volatile unsigned long *)0xd010accc
// Bit 31:21 Reserved 
// Bit 20:0  RO, ro_mg_sum_u,    ACT(top): activities of the top part
#define P_D2D3_MBDG_STATUS_4                       (volatile unsigned long *)0xd010acd0
// Bit 31:21 Reserved 
// Bit 20:0  RO, ro_mg_sum_d,    ACT(bottom): activities of the bottom part
#define P_D2D3_MBDG_STATUS_5                       (volatile unsigned long *)0xd010acd4
// Bit 31:21 Reserved 
// Bit 20:0  RO, ro_mg_sum_l,    ACT(left): activities of the left part
#define P_D2D3_MBDG_STATUS_6                       (volatile unsigned long *)0xd010acd8
// Bit 31:21 Reserved  
// Bit 20:0  RO, ro_mg_sum_r,    ACT(right): activities of the right part
#define P_D2D3_MBDG_STATUS_7                       (volatile unsigned long *)0xd010acdc
// Bit 31:0 dbg_handshake_ro0,   handshake signal for debug, internal srdy and rrdy
#define P_D2D3_DBG_STATUS_1                        (volatile unsigned long *)0xd010ace0
// Bit 31:0 dbg_hscnt,           dbg_hscnt_sel == 4'h0, output lg hscnt
//                               dbg_hscnt_sel == 4'h1, output cg hscnt
//                               dbg_hscnt_sel == 4'h2, output mg hscnt
//                               dbg_hscnt_sel == 4'h3, output bld hscnt
//                               dbg_hscnt_sel == other value, output 32'h0
#define P_D2D3_DBG_STATUS_2                        (volatile unsigned long *)0xd010ace4
// Bit 31:0 RO, drmif_status,    drmif module internal status
#define P_D2D3_DRMIF_STATUS                        (volatile unsigned long *)0xd010ace8
// Bit 31:2 RO, Reserved
// Bit 1:0  RO, d2d3_status0,    [1]: depw_done, one field depth write to ddr has done
//                               [0]: dwmif_pending_ddr_wrrsp, 1 to indicate write response from ddr
#define P_D2D3_DWMIF_STATUS                        (volatile unsigned long *)0xd010acec
// Bit 31:24 Reserved  
// Bit 23:0  RO, ro_meet_sum,    register sumxy_sum_dbg in CBDG
#define P_D2D3_CBDG_STATUS_2                       (volatile unsigned long *)0xd010acf0
// Bit 31:20 Reserved  
// Bit 19:0  RO, ro_hist_depth,  
#define P_D2D3_DBLD_STATUS                         (volatile unsigned long *)0xd010acf4
// Bit 31:0 Reserved  
#define P_D2D3_RESEV_STATUS1                       (volatile unsigned long *)0xd010acf8
// Bit 31:0  Reserved  
#define P_D2D3_RESEV_STATUS2                       (volatile unsigned long *)0xd010acfc
//
// Closing file:  d2d3_regs.h
//
//========================================================================
//  MIPI DSI Host Controller        (16'h2c00 - 16'h2cff)
//
//========================================================================
//
// Reading file:  dsi_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// MIPI DSI HOST CONTROLLER Registers 0x2c00 - 0x2cff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  DSI_VCBUS_BASE = 0x2c
// -----------------------------------------------
// DWC IP registers
#define P_MIPI_DSI_DWC_VERSION_OS                  (volatile unsigned long *)0xd010b000
#define P_MIPI_DSI_DWC_PWR_UP_OS                   (volatile unsigned long *)0xd010b004
#define P_MIPI_DSI_DWC_CLKMGR_CFG_OS               (volatile unsigned long *)0xd010b008
#define P_MIPI_DSI_DWC_DPI_VCID_OS                 (volatile unsigned long *)0xd010b00c
#define P_MIPI_DSI_DWC_DPI_COLOR_CODING_OS         (volatile unsigned long *)0xd010b010
#define P_MIPI_DSI_DWC_DPI_CFG_POL_OS              (volatile unsigned long *)0xd010b014
#define P_MIPI_DSI_DWC_DPI_LP_CMD_TIM_OS           (volatile unsigned long *)0xd010b018
#define P_MIPI_DSI_DWC_PCKHDL_CFG_OS               (volatile unsigned long *)0xd010b02c
#define P_MIPI_DSI_DWC_GEN_VCID_OS                 (volatile unsigned long *)0xd010b030
#define P_MIPI_DSI_DWC_MODE_CFG_OS                 (volatile unsigned long *)0xd010b034
#define P_MIPI_DSI_DWC_VID_MODE_CFG_OS             (volatile unsigned long *)0xd010b038
#define P_MIPI_DSI_DWC_VID_PKT_SIZE_OS             (volatile unsigned long *)0xd010b03c
#define P_MIPI_DSI_DWC_VID_NUM_CHUNKS_OS           (volatile unsigned long *)0xd010b040
#define P_MIPI_DSI_DWC_VID_NULL_SIZE_OS            (volatile unsigned long *)0xd010b044
#define P_MIPI_DSI_DWC_VID_HSA_TIME_OS             (volatile unsigned long *)0xd010b048
#define P_MIPI_DSI_DWC_VID_HBP_TIME_OS             (volatile unsigned long *)0xd010b04c
#define P_MIPI_DSI_DWC_VID_HLINE_TIME_OS           (volatile unsigned long *)0xd010b050
#define P_MIPI_DSI_DWC_VID_VSA_LINES_OS            (volatile unsigned long *)0xd010b054
#define P_MIPI_DSI_DWC_VID_VBP_LINES_OS            (volatile unsigned long *)0xd010b058
#define P_MIPI_DSI_DWC_VID_VFP_LINES_OS            (volatile unsigned long *)0xd010b05c
#define P_MIPI_DSI_DWC_VID_VACTIVE_LINES_OS        (volatile unsigned long *)0xd010b060
#define P_MIPI_DSI_DWC_EDPI_CMD_SIZE_OS            (volatile unsigned long *)0xd010b064
#define P_MIPI_DSI_DWC_CMD_MODE_CFG_OS             (volatile unsigned long *)0xd010b068
#define P_MIPI_DSI_DWC_GEN_HDR_OS                  (volatile unsigned long *)0xd010b06c
#define P_MIPI_DSI_DWC_GEN_PLD_DATA_OS             (volatile unsigned long *)0xd010b070
#define P_MIPI_DSI_DWC_CMD_PKT_STATUS_OS           (volatile unsigned long *)0xd010b074
#define P_MIPI_DSI_DWC_TO_CNT_CFG_OS               (volatile unsigned long *)0xd010b078
#define P_MIPI_DSI_DWC_HS_RD_TO_CNT_OS             (volatile unsigned long *)0xd010b07c
#define P_MIPI_DSI_DWC_LP_RD_TO_CNT_OS             (volatile unsigned long *)0xd010b080
#define P_MIPI_DSI_DWC_HS_WR_TO_CNT_OS             (volatile unsigned long *)0xd010b084
#define P_MIPI_DSI_DWC_LP_WR_TO_CNT_OS             (volatile unsigned long *)0xd010b088
#define P_MIPI_DSI_DWC_BTA_TO_CNT_OS               (volatile unsigned long *)0xd010b08c
#define P_MIPI_DSI_DWC_SDF_3D_OS                   (volatile unsigned long *)0xd010b090
#define P_MIPI_DSI_DWC_LPCLK_CTRL_OS               (volatile unsigned long *)0xd010b094
#define P_MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS        (volatile unsigned long *)0xd010b098
#define P_MIPI_DSI_DWC_PHY_TMR_CFG_OS              (volatile unsigned long *)0xd010b09c
#define P_MIPI_DSI_DWC_PHY_RSTZ_OS                 (volatile unsigned long *)0xd010b0a0
#define P_MIPI_DSI_DWC_PHY_IF_CFG_OS               (volatile unsigned long *)0xd010b0a4
#define P_MIPI_DSI_DWC_PHY_ULPS_CTRL_OS            (volatile unsigned long *)0xd010b0a8
#define P_MIPI_DSI_DWC_PHY_TX_TRIGGERS_OS          (volatile unsigned long *)0xd010b0ac
#define P_MIPI_DSI_DWC_PHY_STATUS_OS               (volatile unsigned long *)0xd010b0b0
#define P_MIPI_DSI_DWC_PHY_TST_CTRL0_OS            (volatile unsigned long *)0xd010b0b4
#define P_MIPI_DSI_DWC_PHY_TST_CTRL1_OS            (volatile unsigned long *)0xd010b0b8
#define P_MIPI_DSI_DWC_INT_ST0_OS                  (volatile unsigned long *)0xd010b0bc
#define P_MIPI_DSI_DWC_INT_ST1_OS                  (volatile unsigned long *)0xd010b0c0
#define P_MIPI_DSI_DWC_INT_MSK0_OS                 (volatile unsigned long *)0xd010b0c4
#define P_MIPI_DSI_DWC_INT_MSK1_OS                 (volatile unsigned long *)0xd010b0c8
// Top-level registers
// 31: 3    Reserved.                                                                       Default 0.
//     2 RW dpi_rst_n:  1=Assert SW reset on mipi_dsi_host_dpi block.   0=Release reset.    Default 1.
//     1 RW intr_rst_n: 1=Assert SW reset on mipi_dsi_host_intr block.  0=Release reset.    Default 1.
//     0 RW dwc_rst_n:  1=Assert SW reset on IP core.                   0=Release reset.    Default 1.
#define P_MIPI_DSI_TOP_SW_RESET                    (volatile unsigned long *)0xd010b3c0
// 31: 5    Reserved.                                                                                                       Default 0.
//     4 RW manual_edpihalt:  1=Manual suspend VencL; 0=do not suspend VencL.                                               Default 0.
//     3 RW auto_edpihalt_en: 1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL. Default 0.
//     2 RW clock_freerun: Apply to auto-clock gate only.                                                                   Default 0.
//                          0=Default, use auto-clock gating to save power;
//                          1=use free-run clock, disable auto-clock gating, for debug mode.
//     1 RW enable_pixclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable pixclk.      Default 0.
//     0 RW enable_sysclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable sysclk.      Default 0.
#define P_MIPI_DSI_TOP_CLK_CNTL                    (volatile unsigned long *)0xd010b3c4
// 31:24    Reserved.                                                                           Default 0.
// 23:20 RW dpi_color_mode: Define DPI pixel format.                                            Default 0.
//                           0=16-bit RGB565 config 1;
//                           1=16-bit RGB565 config 2;
//                           2=16-bit RGB565 config 3;
//                           3=18-bit RGB666 config 1;
//                           4=18-bit RGB666 config 2;
//                           5=24-bit RGB888;
//                           6=20-bit YCbCr 4:2:2;
//                           7=24-bit YCbCr 4:2:2;
//                           8=16-bit YCbCr 4:2:2;
//                           9=30-bit RGB;
//                          10=36-bit RGB;
//                          11=12-bit YCbCr 4:2:0.
//    19    Reserved.                                                                           Default 0.
// 18:16 RW in_color_mode:  Define VENC data width.                                             Default 0.
//                          0=30-bit pixel;
//                          1=24-bit pixel;
//                          2=18-bit pixel, RGB666;
//                          3=16-bit pixel, RGB565.
// 15:14 RW chroma_subsample: Define method of chroma subsampling.                              Default 0.
//                            Applicable to YUV422 or YUV420 only.
//                            0=Use even pixel's chroma;
//                            1=Use odd pixel's chroma;
//                            2=Use averaged value between even and odd pair.
// 13:12 RW comp2_sel:  Select which component to be Cr or B: 0=comp0; 1=comp1; 2=comp2.        Default 2.
// 11:10 RW comp1_sel:  Select which component to be Cb or G: 0=comp0; 1=comp1; 2=comp2.        Default 1.
//  9: 8 RW comp0_sel:  Select which component to be Y  or R: 0=comp0; 1=comp1; 2=comp2.        Default 0.
//     7    Reserved.                                                                           Default 0.
//     6 RW de_pol:     If DE input is active low, set to 1 to invert to active high.           Default 0.
//     5 RW hsync_pol:  If HS input is active low, set to 1 to invert to active high.           Default 0.
//     4 RW vsync_pol:  If VS input is active low, set to 1 to invert to active high.           Default 0.
//     3 RW dpicolorm: Signal to IP.   Default 0.
//     2 RW dpishutdn: Signal to IP.   Default 0.
//     1    Reserved.                                                                           Default 0.
//     0    Reserved.                                                                           Default 0.
#define P_MIPI_DSI_TOP_CNTL                        (volatile unsigned long *)0xd010b3c8
#define P_MIPI_DSI_TOP_SUSPEND_CNTL                (volatile unsigned long *)0xd010b3cc
#define P_MIPI_DSI_TOP_SUSPEND_LINE                (volatile unsigned long *)0xd010b3d0
#define P_MIPI_DSI_TOP_SUSPEND_PIX                 (volatile unsigned long *)0xd010b3d4
#define P_MIPI_DSI_TOP_MEAS_CNTL                   (volatile unsigned long *)0xd010b3d8
//     0 R  stat_edpihalt:  edpihalt signal from IP.    Default 0.
#define P_MIPI_DSI_TOP_STAT                        (volatile unsigned long *)0xd010b3dc
#define P_MIPI_DSI_TOP_MEAS_STAT_TE0               (volatile unsigned long *)0xd010b3e0
#define P_MIPI_DSI_TOP_MEAS_STAT_TE1               (volatile unsigned long *)0xd010b3e4
#define P_MIPI_DSI_TOP_MEAS_STAT_VS0               (volatile unsigned long *)0xd010b3e8
#define P_MIPI_DSI_TOP_MEAS_STAT_VS1               (volatile unsigned long *)0xd010b3ec
// 31:16 RW intr_stat/clr. For each bit, read as this interrupt level status, write 1 to clear. Default 0.
//          [31:22] Reserved
//          [   21] stat/clr of eof interrupt
//          [   21] vde_fall interrupt
//          [   19] stat/clr of de_rise interrupt
//          [   18] stat/clr of vs_fall interrupt
//          [   17] stat/clr of vs_rise interrupt
//          [   16] stat/clr of dwc_edpite interrupt
// 15: 0 RW intr_enable. For each bit, 1=enable this interrupt, 0=disable.                      Default 0.
//          [15: 6] Reserved
//          [    5] eof interrupt
//          [    4] de_fall interrupt
//          [    3] de_rise interrupt
//          [    2] vs_fall interrupt
//          [    1] vs_rise interrupt
//          [    0] dwc_edpite interrupt
#define P_MIPI_DSI_TOP_INTR_CNTL_STAT              (volatile unsigned long *)0xd010b3f0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dsi_regs.h
//
//========================================================================
//  ISP register    (16'h2d00 - 16'h2dff)
//========================================================================
//`define ISP_VCBUS_BASE                   8'h2d
//
// Reading file:  isp_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  ISP_VCBUS_BASE = 0x2d
// -----------------------------------------------
#define P_ISP_GAMMA_LUT_ADDR                       (volatile unsigned long *)0xd010b708
#define P_ISP_GAMMA_LUT_DATA                       (volatile unsigned long *)0xd010b70c
#define P_ISP_DF1024_LUT_ADDR                      (volatile unsigned long *)0xd010b710
#define P_ISP_DF1024_LUT_DATA                      (volatile unsigned long *)0xd010b714
#define P_ISP_LNSD_LUT_ADDR                        (volatile unsigned long *)0xd010b718
#define P_ISP_LNSD_LUT_DATA                        (volatile unsigned long *)0xd010b71c
#define P_ISP_HV_SIZE                              (volatile unsigned long *)0xd010b400
//Bit 31:29, reserved  
//Bit 28:16, reg_hsize                      image horizontal size (number of cols)   default=1920 
//Bit 15:13, reserved                       
//Bit 12: 0, reg_vsize                      image vertical size   (number of rows)   default=1080
#define P_ISP_HBLANK                               (volatile unsigned long *)0xd010b404
//Bit 31:29, reserved
//Bit 28:16, reg_total_width                input data total width in the case no hsyn in,such as reg_frm_syn_mode[1]==0 or isp patterngen enable.  default=1920        
//Bit 15: 8, reserved        
//Bit  7: 0, reg_hblank                     df image horizontal blank length   default=10
#define P_ISP_TIMING_MODE                          (volatile unsigned long *)0xd010b408
//Bit 31:17, reserved                       
//Bit    16, reg_din_timing_sw_ph           for safeing, enable this bit to disable de/vsyn/hsyn pulse sample when the input de/vsyn/hsyn polarity switch default=0   
//Bit 15: 8, reg_out_hs_ofst                the offset of output hsync (between two de) generate after last de of each line,  default=0
//Bit     7, reserved                       
//Bit  6: 5, reg_frm_syn_mode               bit[0]: isp global reset generate mode   1--reg soft reset input; 0--vsyn generate reset     
//                                          bit[1]: input data process mode based on input hsyn  1--there is hsyn input; 0--no hsyn input   default=0
//Bit     4, reg_vs_samp_mode               vsyn posedge or negedge is sampled as trigger edge  
//                                          0--posedge sample;   1--negedge sample     default=0
//Bit     3, reserved                       
//Bit  2: 0, reg_syn_level_invs             high-level or low-level of vsyn/hsyn/de is valid   default=0
//                                          bit[2] for vsyn, 0--high-level valid    1--low is valid
//                                          bit[1] for hsyn, 0--high-level valid    1--low is valid
//                                          bit[0] for de  , 0--high-level valid    1--low is valid
#define P_ISP_RST_DLY_NUM                          (volatile unsigned long *)0xd010b40c
//Bit 31: 0, reg_frm_rst_dlynum             represent how many clock number delay after generated-global reset(from input vsyn or soft-reset).  default=0
#define P_ISP_OUTVS_DLY_NUM                        (volatile unsigned long *)0xd010b410
//Bit 31: 0, reg_out_vs_dlynum              represent how many clock number delay generate the output vsync after generated-global reset(from input vsyn or soft-reset).default=0
#define P_ISP_DIN_WIND_OFST                        (volatile unsigned long *)0xd010b414
//Bit 31:29, reserved                       
//Bit 28:16, reg_din_wind_vofst             data input window vertical top offset default=0
//Bit 15:13, reserved                       
//Bit 12: 0, reg_din_wind_hofst             data input window horizontal left offset default=0
#define P_ISP_FRM_SOFT_RST                         (volatile unsigned long *)0xd010b418
//Bit 31: 1, reserved                       
//Bit     0, reg_frm_soft_rst               frm soft reset default=0
#define P_ISP_RST_SYN_SEL                          (volatile unsigned long *)0xd010b41c
//Bit 31: 0, reg_rst_syn_sel                some important reg-setting signal, such as sub-function enable, need to switch sync to 
//                                          the isp reset time, this signal is cfg those signal whether sync-reset enable or real-time 
//                                          enable, when 1 is sync to reset default=32'hffffffff,
// address null
//////////////////////////////////////////////////////////////////////////////////////////////////////////
// pattern generator registers
//////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_PAT_GEN_CTRL                         (volatile unsigned long *)0xd010b420
//Bit 31:29, reserved  
//Bit    28, reg_isp_pat_enable             enable of pattern generator data path, 0- disable; 1- enable; default=0    
//Bit    27, reg_isp_pat_xinvt             invert the pattern in horizontal direction, 0- no invert; 1- invert; default=0 
//Bit    26, reg_isp_pat_yinvt              invert the pattern in vertical direction,   0- no invert; 1- invert; default=0 
//Bit    25, reg_isp_pat_xphase_ofst        bayer pattern xphase offset in pattern generator, 0- horizontally start from G(R)/B(G); 1- horizontally start from R(G)/G(B); default=0
//Bit    24, reg_isp_pat_yphase_ofst        bayer pattern yphase offset in pattern generator, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0
//Bit    23, reserved                       
//Bit 22:20, reg_isp_pat_xmode              pattern horizontal mode, 0: raster/bar16/burst; 1; ramp-up; 2/up: normalized gain of horizontal dirrection (no change); default = 0
//Bit    19, reserved                       
//Bit 18:16, reg_isp_pat_ymode              pattern vertical mode, 0: raster/bar16/burst; 1; ramp-up; 2/up: normalized gain of vertical dirrection (no change); default = 0
//Bit 15: 2, reserved                       
//Bit  1: 0, reg_isp_pat_dft_mode           defect pixel emulatiion mode in pattern generator; 0: no dft; 1: dead pixel (black); 2: hot pixel; 3:not dft default =0;
#define P_ISP_PAT_XRAMP_SCAL                       (volatile unsigned long *)0xd010b424
//Bit 31:24, reserved                       
//Bit 23:16, reg_isp_pat_xrmp_scale_r       ramp pattern horizontal scale for red channel,  default= 255
//Bit 15: 8, reg_isp_pat_xrmp_scale_g       ramp pattern horizontal scale for green channel,default= 255
//Bit  7: 0, reg_isp_pat_xrmp_scale_b       ramp pattern horizontal scale for blue channel, default= 255
#define P_ISP_PAT_YRAMP_SCAL                       (volatile unsigned long *)0xd010b428
//Bit 31:24, reserved
//Bit 23:16, reg_isp_pat_yrmp_scale_r       ramp pattern horizontal scale for red channel,   default= 255
//Bit 15: 8, reg_isp_pat_yrmp_scale_g       ramp pattern horizontal scale for green channel, default= 255
//Bit  7: 0, reg_isp_pat_yrmp_scale_b       ramp pattern horizontal scale for blue channel,  default= 255
#define P_ISP_PAT_XYIDX_OFST                       (volatile unsigned long *)0xd010b42c
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_pat_xidx_ofset         horizontal index ofset for pattern generation. default=0    
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_pat_yidx_ofset         vertical index ofset for pattern generation. default=0 
#define P_ISP_PAT_XYIDX_SCAL                       (volatile unsigned long *)0xd010b430
//Bit 31:30, reserved                       
//Bit 29:28, reg_isp_pat_xidx_rshft         pattern generator horizontal index scale right shift, 0~3: scale normalized to divx=2^(6-rshft); default = 0 
//Bit 27:16, reg_isp_pat_xidx_scale         pattern generator horizontal index scale. default=ceil((1024/reg_hsize)*divx) will cover one pattern cycle horizontally
//Bit 15:14, reserved                       
//Bit 13:12, reg_isp_pat_yidx_rshft         pattern generator vertical index scale right shift, 0~3: scale normalized to divy=2^(6-rshft); default = 0 
//Bit 11: 0, reg_isp_pat_yidx_scale         pattern generator vertical index scale. ceil((1024/reg_vsize)*divy) will cover one pattern cycle vertically
#define P_ISP_PAT_BAR16_RED0                       (volatile unsigned long *)0xd010b434
//Bit 31:24, reg_isp_pat_bar16rgb_r3     pattern generator 4th bar red value. 0~255.   default= 0
//Bit 23:16, reg_isp_pat_bar16rgb_r2     pattern generator 3rd bar red value. 0~255.   default= 0
//Bit 15: 8, reg_isp_pat_bar16rgb_r1     pattern generator 2nd bar red value. 0~255.   default= 255
//Bit  7: 0, reg_isp_pat_bar16rgb_r0     pattern generator 1st bar red value. 0~255.   default= 255
#define P_ISP_PAT_BAR16_RED1                       (volatile unsigned long *)0xd010b438
//Bit 31:24, reg_isp_pat_bar16rgb_r7     pattern generator 7th bar red value. 0~255.   default= 0
//Bit 23:16, reg_isp_pat_bar16rgb_r6     pattern generator 6th bar red value. 0~255.   default= 0
//Bit 15: 8, reg_isp_pat_bar16rgb_r5     pattern generator 5th bar red value. 0~255.   default= 255
//Bit  7: 0, reg_isp_pat_bar16rgb_r4     pattern generator 4th bar red value. 0~255.   default= 255
#define P_ISP_PAT_BAR16_RED2                       (volatile unsigned long *)0xd010b43c
//Bit 31:24, reg_isp_pat_bar16rgb_r11    pattern generator 11th bar red value. 0~255.   default= 128
//Bit 23:16, reg_isp_pat_bar16rgb_r10    pattern generator 10th bar red value. 0~255.   default= 96
//Bit 15: 8, reg_isp_pat_bar16rgb_r9     pattern generator  9th bar red value. 0~255.   default= 64
//Bit  7: 0, reg_isp_pat_bar16rgb_r8     pattern generator  8th bar red value. 0~255.   default= 32
#define P_ISP_PAT_BAR16_RED3                       (volatile unsigned long *)0xd010b440
//Bit 31:24, reg_isp_pat_bar16rgb_r15    pattern generator 15th bar red value. 0~255.   default= 255
//Bit 23:16, reg_isp_pat_bar16rgb_r14    pattern generator 14th bar red value. 0~255.   default= 224
//Bit 15: 8, reg_isp_pat_bar16rgb_r13    pattern generator 13th bar red value. 0~255.   default= 192
//Bit  7: 0, reg_isp_pat_bar16rgb_r12    pattern generator 12th bar red value. 0~255.   default= 160
#define P_ISP_PAT_BAR16_GRN0                       (volatile unsigned long *)0xd010b444
//Bit 31:24, reg_isp_pat_bar16rgb_g3     pattern generator 4th bar green value. 0~255.   default= 255
//Bit 23:16, reg_isp_pat_bar16rgb_g2     pattern generator 3rd bar green value. 0~255.   default= 255
//Bit 15: 8, reg_isp_pat_bar16rgb_g1     pattern generator 2nd bar green value. 0~255.   default= 255
//Bit  7: 0, reg_isp_pat_bar16rgb_g0     pattern generator 1st bar green value. 0~255.   default= 255
#define P_ISP_PAT_BAR16_GRN1                       (volatile unsigned long *)0xd010b448
//Bit 31:24, reg_isp_pat_bar16rgb_g7     pattern generator 7th bar green value. 0~255.   default= 0
//Bit 23:16, reg_isp_pat_bar16rgb_g6     pattern generator 6th bar green value. 0~255.   default= 0
//Bit 15: 8, reg_isp_pat_bar16rgb_g5     pattern generator 5th bar green value. 0~255.   default= 0
//Bit  7: 0, reg_isp_pat_bar16rgb_g4     pattern generator 4th bar green value. 0~255.   default= 0
#define P_ISP_PAT_BAR16_GRN2                       (volatile unsigned long *)0xd010b44c
//Bit 31:24, reg_isp_pat_bar16rgb_g11    pattern generator 11th bar green value. 0~255.   default= 128
//Bit 23:16, reg_isp_pat_bar16rgb_g10    pattern generator 10th bar green value. 0~255.   default= 96
//Bit 15: 8, reg_isp_pat_bar16rgb_g9    pattern generator  9th bar green value. 0~255.   default= 64
//Bit  7: 0, reg_isp_pat_bar16rgb_g8    pattern generator  8th bar green value. 0~255.   default= 32
#define P_ISP_PAT_BAR16_GRN3                       (volatile unsigned long *)0xd010b450
//Bit 31:24, reg_isp_pat_bar16rgb_g15    pattern generator 15th bar green value. 0~255.   default= 255
//Bit 23:16, reg_isp_pat_bar16rgb_g14    pattern generator 14th bar green value. 0~255.   default= 224
//Bit 15: 8, reg_isp_pat_bar16rgb_g13    pattern generator 13th bar green value. 0~255.   default= 192
//Bit  7: 0, reg_isp_pat_bar16rgb_g12    pattern generator 12th bar green value. 0~255.   default= 160 
#define P_ISP_PAT_BAR16_BLU0                       (volatile unsigned long *)0xd010b454
//Bit 31:24, reg_isp_pat_bar16rgb_b3     pattern generator 4th bar green value. 0~255.   default= 0  
//Bit 23:16, reg_isp_pat_bar16rgb_b2     pattern generator 3rd bar green value. 0~255.   default= 255  
//Bit 15: 8, reg_isp_pat_bar16rgb_b1     pattern generator 2nd bar green value. 0~255.   default= 0  
//Bit  7: 0, reg_isp_pat_bar16rgb_b0     pattern generator 1st bar green value. 0~255.   default= 255   
#define P_ISP_PAT_BAR16_BLU1                       (volatile unsigned long *)0xd010b458
//Bit 31:24, reg_isp_pat_bar16rgb_b7     pattern generator 7th bar green value. 0~255.   default= 0    
//Bit 23:16, reg_isp_pat_bar16rgb_b6     pattern generator 6th bar green value. 0~255.   default= 255    
//Bit 15: 8, reg_isp_pat_bar16rgb_b5     pattern generator 5th bar green value. 0~255.   default= 0    
//Bit  7: 0, reg_isp_pat_bar16rgb_b4     pattern generator 4th bar green value. 0~255.   default= 255     
#define P_ISP_PAT_BAR16_BLU2                       (volatile unsigned long *)0xd010b45c
//Bit 31:24, reg_isp_pat_bar16rgb_b11    pattern generator 11th bar green value. 0~255.   default= 128
//Bit 23:16, reg_isp_pat_bar16rgb_b10    pattern generator 10th bar green value. 0~255.   default= 96 
//Bit 15: 8, reg_isp_pat_bar16rgb_b9     pattern generator  9th bar green value. 0~255.   default= 64 
//Bit  7: 0, reg_isp_pat_bar16rgb_b8     pattern generator  8th bar green value. 0~255.   default= 32                                                                                                       
#define P_ISP_PAT_BAR16_BLU3                       (volatile unsigned long *)0xd010b460
//Bit 31:24, reg_isp_pat_bar16rgb_b15    pattern generator 15th bar green value. 0~255.   default= 255
//Bit 23:16, reg_isp_pat_bar16rgb_b14    pattern generator 14th bar green value. 0~255.   default= 224
//Bit 15: 8, reg_isp_pat_bar16rgb_b13    pattern generator 13th bar green value. 0~255.   default= 192
//Bit  7: 0, reg_isp_pat_bar16rgb_b12    pattern generator 12th bar green value. 0~255.   default= 160                                                                                                      
#define P_ISP_PAT_DFT_XYIDX                        (volatile unsigned long *)0xd010b464
//Bit 31:29, reserved  
//Bit 28:16, reg_isp_pat_dft_xidx           horizontal index of defect region center for pattern generation. default=100    
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_pat_dft_yidx           ver index of defect region center for pattern generation. default=200 
#define P_ISP_PAT_DFT_XYWID                        (volatile unsigned long *)0xd010b468
//Bit 31:29, reserved  
//Bit 28:16, reg_isp_pat_dft_xwid           horizontal half width of defect region for pattern generation. width = 2x+1, default=1    
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_pat_dft_ywid           vertical half width of defect region for pattern generation. width = 2y+1, default=64
#define P_ISP_PAT_DFT_GAIN                         (volatile unsigned long *)0xd010b46c
//Bit 31:30, reserved  
//Bit 29:24, reg_isp_pat_dft_gaingrbg0   lazy or active pixel gain of green channel (phase0). <32 means lazy pixel, >32 means active, 32: means normal; default=0    
//Bit 23:22, reserved                       
//Bit 21:16, reg_isp_pat_dft_gaingrbg1   lazy or active pixel gain of red channel (phase1). <32 means lazy pixel, >32 means active, 32: means normal; default=0   
//Bit 15:14, reserved                       
//Bit 13: 8, reg_isp_pat_dft_gaingrbg2   lazy or active pixel gain of blue channel (phase2). <32 means lazy pixel, >32 means active, 32: means normal; default=0   
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_isp_pat_dft_gaingrbg3   lazy or active pixel gain of green channel (phase3). <32 means lazy pixel, >32 means active, 32: means normal; default=0  
#define P_ISP_PAT_HVTOTAL                          (volatile unsigned long *)0xd010b470
//Bit 31:16, reg_isp_pat_vtotal             default=490    
//Bit 15: 0, reg_isp_pat_htotal             default=760
#define P_ISP_PAT_VDE_SLINE                        (volatile unsigned long *)0xd010b474
//Bit 31:29, reserved  
//Bit 15: 0, reg_isp_pat_vde_sline          default=64
#define P_ISP_OUTHS_PARA                           (volatile unsigned long *)0xd010b478
//Bit 31:16, reg_ouths_pre_dist             represent the output hsyn inter-distance when need some output hsyn in the head of each frame  default=0        
//Bit 15: 8, reserved                      
//Bit  7: 0, reg_ouths_pre_num              how many output hsyn is needed in the head of each frame   default=0        
#define P_ISP_FRM_DONE_PARA                        (volatile unsigned long *)0xd010b47c
//Bit 31:17, reserved                      
//Bit    16, reg_isp_intr_sel               isp interrupt source select  0--generated global reset 1--isp real frame process done  default=0        
//Bit 15: 0, reg_frm_done_dlynum            how many time frame done delay as the finally done  default=128        
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Clamp and Gain module registers
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_CLAMPGAIN_CTRL                       (volatile unsigned long *)0xd010b480
//Bit 31:26, reserved
//Bit    25, reg_isp_clp_xphase_ofst        bayer pattern xphase offset in clamp gain, 0- horizontally start from G(R)/B(G); 1- horizontally start from R(G)/G(B); default=0
//Bit    24, reg_isp_clp_yphase_ofst        bayer pattern yphase offset in clamp gain, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
//Bit 23:22, reserved
//Bit 21:20, reg_isp_aecraw_lpf_sel         low-pass filter mode for raw data components too bright statistics for auto exposure. 0: no lpf; 1:[1 2 1]/4; 2: [1 2 2 2 1]/8; 3:[1 2 3 4 3 2 1]/16; default = 0
//Bit 19:18, reserved                       
//Bit 17:16, reg_isp_bandsplit_mode         bandsplit filter mode for clamp and gain,  0- no lpf; 1: [1 2 1]/4; 2:[1 2 2 2 1]/8; 3: [1 2 3 4 3 2 1]/4;   default= 0
//Bit 15: 8, reserved                       
//Bit  7: 0, reg_isp_bandsplit_usk          digital gain to unsharped highpass portion of each channel before adding back, 0~255, 32 normalized to '1'.  default= 32
#define P_ISP_GAIN_BSCORE_GRBG                     (volatile unsigned long *)0xd010b484
//Bit 31:24, reg_isp_bandsplit_core0     coring to unsharp part of green (phase0) channel.   default= 0
//Bit 23:16, reg_isp_bandsplit_core1     coring to unsharp part of red   (phase1) channel.   default= 0
//Bit 15: 8, reg_isp_bandsplit_core2     coring to unsharp part of blue  (phase2) channel.   default= 0
//Bit  7: 0, reg_isp_bandsplit_core3     coring to unsharp part of green (phase3) channel.   default= 0
#define P_ISP_CLAMP_GRBG01                         (volatile unsigned long *)0xd010b488
//Bit 31:26, reserved
//Bit 25:16, reg_isp_clamp_grbg0         clamping offset to raw data green (phase0) channel, -512~511.   default= 0
//Bit 15:10, reserved                       
//Bit  9: 0, reg_isp_clamp_grbg1         clamping offset to raw data red (phase1) channel, -512~511.   default= 0
#define P_ISP_CLAMP_GRBG23                         (volatile unsigned long *)0xd010b48c
//Bit 31:26, reserved                       
//Bit 25:16, reg_isp_clamp_grbg2         clamping offset to raw data blue (phase2) channel, -512~511.   default= 0
//Bit 15:10, reserved                       
//Bit  9: 0, reg_isp_clamp_grbg3         clamping offset to raw data green (phase3) channel, -512~511.   default= 0
#define P_ISP_GAIN_GRBG01                          (volatile unsigned long *)0xd010b490
//Bit 31:28, reserved                       
//Bit 27:16, reg_isp_gain_grbg0          digital gain to raw data green (phase0) channel, 0~4095, 256 as normalized '1'.   default= 256
//Bit 15:12, reserved                       
//Bit 11: 0, reg_isp_gain_grbg1          digital gain to raw data red   (phase1) channel, 0~4095, 256 as normalized '1'.   default= 256
#define P_ISP_GAIN_GRBG23                          (volatile unsigned long *)0xd010b494
//Bit 31:28, reserved
//Bit 27:16, reg_isp_gain_grbg2          digital gain to raw data blue  (phase2) channel, 0~4095, 256 as normalized '1'.   default= 256
//Bit 15:12, reserved                       
//Bit 11: 0, reg_isp_gain_grbg3          digital gain to raw data green (phase3) channel, 0~4095, 256 as normalized '1'.   default= 256
// address 8'h26~ 8'h27 null
//////////////////////////////////////////////////////////////////////////////////////////////
// lens shading correction registers
//////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_LNS_CTRL                             (volatile unsigned long *)0xd010b4a0
//Bit 31:29, reserved
//Bit    28, reg_isp_lns_comp_enable    lens shading compensation enable. 0: no compensation; 1: compensation enable;  default= 0
//Bit 27:26, reserved
//Bit    25, reg_isp_lns_xphase_ofst    bayer pattern xphase offset in lens shading correction, 0- horizontally start from G(R)/B(G); 1- horizontally start from R(G)/G(B); default=0
//Bit    24, reg_isp_lns_yphase_ofst    bayer pattern yphase offset in lens shading correction, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
//Bit 23:22, reg_isp_lns_gainnorm_grbg0 normalization mode for green channel (phase0) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
//Bit 21:20, reg_isp_lns_gainnorm_grbg1 normalization mode for red   channel (phase1) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
//Bit 19:18, reg_isp_lns_gainnorm_grbg2 normalization mode for blue  channel (phase2) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
//Bit 17:16, reg_isp_lns_gainnorm_grbg3 normalization mode for green channel (phase3) of compensation gain. 0: norm to 128; 1: norm to 64; 2: norm to 32; 3: norm to 16; defautl =1
//Bit    15, reg_isp_lns_gain_mode      mode for gains from lut32x32x4. 0: final gain= x; 1: final gain = 1+x; default = 1
//Bit 14:12, reg_isp_lns_mesh_mode      mode for getting gain value from or write pixel raw components to lut32x32x4. if write pixel to lut (x>0), it was used for lut gain calculation during calibration. 0: read gain from lut 32x32x4; 1: gain='1', write pixel data without lpf to lut32x32x4 of the mesh position; 2; gain='1', write [1 2 1]/4 lpf filtered pixel data to lut32x32x4 of mesh position; 3: gain='1', write [1 2 2 2 1]/8 lpf filtered pixel data to lut32x32x4 of mesh position; default = 0;
//Bit 11: 0, reg_isp_lns_hold           TBD
#define P_ISP_LNS_XYSCAL                           (volatile unsigned long *)0xd010b4a4
//Bit 31:28, reserved                       
//Bit 27:16, reg_isp_lns_xscale             lens shading compensation horizontal index scale. extend the sensor region to 32x32 grid, xscale=floor(7936*32/reg_hsize)
//Bit 15:12, reserved                       
//Bit 11: 0, reg_isp_lns_yscale             lens shading compensation vertical index scale. extend the sensor region to 32x32 grid, yscale=floor(7936*32/reg_vsize)
#define P_ISP_LNS_XYIDX_SHFT                       (volatile unsigned long *)0xd010b4a8
//Bit 31:30, reserved                       
//Bit 29:16, reg_isp_lns_xidx_shift         lens shading compensation horizontal index offset. -8192~8191; default= 0;
//Bit 15:14, reserved                       
//Bit 13: 0, reg_isp_lns_yidx_shift         lens shading compensation vertical index offset.   -8192~8191; default= 0;
#define P_ISP_LNS_SENSOR_GAINGRBG                  (volatile unsigned long *)0xd010b4ac
//Bit 31:24, reg_isp_lns_sensor_gaingrbg0    gain to the lut 32x32 phase 0 green gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128                        
//Bit 23:16, reg_isp_lns_sensor_gaingrbg1    gain to the lut 32x32 phase 1   red gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128
//Bit 15: 8, reg_isp_lns_sensor_gaingrbg2    gain to the lut 32x32 phase 2  blue gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128                      
//Bit  7: 0, reg_isp_lns_sensor_gaingrbg3    gain to the lut 32x32 phase 3 green gain to compensate different Lenshading characters under different sensor gain. 0~255. normalized 128 as '1'; default=128
#define P_ISP_LNS_POST_OFSTGRBG                    (volatile unsigned long *)0xd010b4b0
//Bit 31:24, reg_isp_lns_post_ofset_grbg0    ofset to phase 0 green pixel after lens compensation (gain). -128~127. default= 0                        
//Bit 23:16, reg_isp_lns_post_ofset_grbg1    ofset to phase 1 red   pixel after lens compensation (gain). -128~127. default= 0
//Bit 15: 8, reg_isp_lns_post_ofset_grbg2    ofset to phase 2 blue  pixel after lens compensation (gain). -128~127. default= 0                      
//Bit  7: 0, reg_isp_lns_post_ofset_grbg3    ofset to phase 3 green pixel after lens compensation (gain). -128~127. default= 0
// address 8'h2d~ 8'h2f null
// TBD: lens shadding LUT memory operation registers?
////////////////////////////////////////////////////////////////////////////////////////////////
// gamma correction registers
////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_GMR0_CTRL                            (volatile unsigned long *)0xd010b4c0
//Bit 31:29, reserved
//Bit    28, reg_isp_gmr_correct_enable     raw data gammar correction enable;    default= 0;
//Bit 27:26, reserved                       
//Bit    25, reg_isp_gmr_xphase_ofst        bayer pattern xphase offset in gammar correction, 0- horizontally start from G(R)/B(G); 1- horizontally start from R(G)/G(B); default=0
//Bit    24, reg_isp_gmr_yphase_ofst        bayer pattern yphase offset in gammar correction, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
//Bit 23: 1, reserved                       
//Bit     0, reg_isp_gmr_lut_cbus_mode          TBD
// TBD: gammar LUT memory operation
///////////////////////////////////////////////////////////////////////////////////////////////
// defect pixel correction registers
///////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_DFT_CTRL                             (volatile unsigned long *)0xd010b4c4
//Bit 31:29, reserved
//Bit    28, reg_isp_dft_enable             defect pixel detection block operation enable, reg_isp_dft_detect_mode decides the detection mode; 0: no defect_detection; 1: detection logic on;    default= 1;
//Bit 27:26, reserved                       
//Bit    25, reg_isp_dft_xphase_ofst        bayer pattern xphase offset in defect pixel correction, 0- horizontally start from G(R)/B(G); 1- horizontally start from R(G)/G(B); default=0
//Bit    24, reg_isp_dft_yphase_ofst        bayer pattern yphase offset in defect pixel correction, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0 
//Bit 23:20, reserved
//Bit 19:16, reg_isp_dftmap_writeto_lut_stline starting line number to write dftmap to LUT1024. 0~15; default= 14;
//Bit 15:13, reserved
//Bit    12, reg_isp_dftmap_writeto_lut     enable to HW write dftmap info to LUT1024 in raster-scan mode. 0: no write to LUT1024; 1: write to LUT1024 (HW)
//Bit 11:10, reserved
//Bit  9: 8, reg_isp_dftmap_correct_drtrate  defect pixel correction directional rate for error. 0; x2; 1:1  2: 1/2; 3:1/4; default=1
//Bit  7: 6, reserved
//Bit  5: 4, reg_isp_dft_detect_mode        defect pixel detection mode. 0: manual mode; 1/2/3: adaptive mode, default = 2;
//Bit  3: 2, reserved
//Bit  1: 0, reg_isp_dftmap_correct_mode    defect map generation mode. 0: all dftmap=0; 1: dftmap based on LUT1024 only; 2: based on on dft_map9 (only sky mode only; 3 based on both LUT1024 and dft_map9) defaul=3
#define P_ISP_DFT_VAR_MINMAX                       (volatile unsigned long *)0xd010b4cc
//Bit 31:24, reg_isp_dft_varmin             min limit for 4x8 block variance.  default = 10;
//Bit 23:16, reg_isp_dft_varmax             max limit for 4x8 block variance.  default = 32;
//Bit 15: 8, reg_isp_dft_thdlow_minfloor    min limit for 4x8 block mininum value for thd_low calculation. default= 75;
//Bit  7: 0, reg_isp_dft_thdhig_maxfloor    max limit for 4x8 block maximum value for thd_low calculation. default= 175;
#define P_ISP_DFT_THDLOW                           (volatile unsigned long *)0xd010b4d0
//Bit 31:24, reg_isp_dft_thdlow_varrate     rate to variance in thdlow calculation. normalized to 16 as '1', default = 16; 
//Bit 23:16, reg_isp_dft_thdlow_minrate     rate to distance between min_BLK and avg_BLK in thdlow calculation. normalized to 16 as '1', default = 8; 
//Bit 15: 8, reg_isp_dft_thdlow_minrange    min limit of adaptive range for thd_low calculation. default= 2 (calibrat mode =0/1);  25 (calibrat mode =2/3);
//Bit  7: 0, reg_isp_dft_thdlow_maxrange    max limit of adaptive range for thd_low calculation. default= 2 (calibrat mode =0/1); 210 (calibrat mode =2/3);
#define P_ISP_DFT_THDHIG                           (volatile unsigned long *)0xd010b4d4
//Bit 31:24, reg_isp_dft_thdhig_varrate     rate to variance in thdhig calculation. normalized to 16 as '1', default = 16; 
//Bit 23:16, reg_isp_dft_thdhig_maxrate     rate to distance between min_BLK and avg_BLK in thdhig calculation. normalized to 16 as '1', default = 8; 
//Bit 15: 8, reg_isp_dft_thdhig_minrange    min limit of adaptive range for thdhig calculation. default= 2 (calibrat mode =0/1);  25 (calibrat mode =2/3);
//Bit  7: 0, reg_isp_dft_thdhig_maxrange    max limit of adaptive range for thdhig calculation. default= 2 (calibrat mode =0/1); 210 (calibrat mode =2/3);
#define P_ISP_DFT_CALIBRAT_REF                     (volatile unsigned long *)0xd010b4d8
//Bit 31:24, reserved
//Bit 23:16  reg_isp_dft_calibrat_ref_r     calibration reference   red color value under reg_ISP_dft_calibrat_mode=0; normally get from average of red component of the image (only work for raster pattern); default= 100;
//Bit 15: 8, reg_isp_dft_calibrat_ref_g     calibration reference green color value under reg_ISP_dft_calibrat_mode=0; normally get from average of green component of the image (only work for raster pattern); default= 100;
//Bit  7: 0, reg_isp_dft_calibrat_ref_b     calibration reference  blue color value under reg_ISP_dft_calibrat_mode=0; normally get from average of blue component of the image (only work for raster pattern); default= 100;
#define P_ISP_DFT_CALIBRAT_CTRL                    (volatile unsigned long *)0xd010b4dc
//Bit 31:30, reserved                       
//Bit 29:24, reg_isp_dft_calibrat_midnum    threshold of number of pixels (5x9 block) located in the [thdlow, thdhig] range, if num of pixels is larger than this midnum, the calibration reference will be updated. 0~45. default=44
//Bit 23:22, reserved                       
//Bit 21:16, reg_isp_dft_calibrat_tmidnum   threshold of number of pixels (4x9 block) located in the [thdlow, thdhig] range, if num of pixels is larger than this midnum, the calibration reference will be updated. 0~36. default=35 
//Bit 15:10, reserved                       
//Bit  9: 8, reg_isp_dft_lastvalid_mode     current phase color valid (not defect) status mode. it will be used in calibration update decision. 0: only current line; 1: n-2/n/n+2 lines; 2/3:n-4/n-2/n/n+2/n+4 lines; default = 1
//Bit  7: 6, reserved                       
//Bit  5: 4, reg_isp_dft_lastvalid_tmode    top phase color valid (not defect) status mode. it will be used in calibration update decision.0: not update; 1: n-1/n+1 lines; 2/3:n-3/n-1/n+1/n+3 lines; default = 1
//Bit  3: 2, reserved                       
//Bit  1: 0, reg_isp_dft_calibrat_mode      calibration reference selection mode. 0: from reg_isp_dft_calibrat_ref_r/g/b; 1: from local average of current phase if it is not dft; 
//                                          2: from local average of both current and other phases if it was not dft; 3:from local average of both current and other phases whether it was not dft; default=2
#define P_ISP_DFT_DET0_MANUALTH                    (volatile unsigned long *)0xd010b4e0
//Bit 31:24, reserved
//Bit 23:16  reg_isp_dft_manual_thrd_r      threshold of difference between pixel to calibration reference in red channel under reg_isp_dft_detect_mode=0 (manual mode). default= 80;
//Bit 15: 8, reg_isp_dft_manual_thrd_g      threshold of difference between pixel to calibration reference in green channel under reg_isp_dft_detect_mode=0 (manual mode). default= 80;
//Bit  7: 0, reg_isp_dft_manual_thrd_b      threshold of difference between pixel to calibration reference in blue channel under reg_isp_dft_detect_mode=0 (manual mode). default= 80;
#define P_ISP_DFT_DET1_ADPTLOWTH                   (volatile unsigned long *)0xd010b4e4
//Bit 31:24, reserved                       
//Bit 23:16  reg_isp_dft_low_thrd_r         low threshold to   red channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 50;
//Bit 15: 8, reg_isp_dft_low_thrd_g         low threshold to green channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 50;
//Bit  7: 0, reg_isp_dft_low_thrd_b         low threshold to  blue channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 50;
#define P_ISP_DFT_DET1_ADPTHIGTH                   (volatile unsigned long *)0xd010b4e8
//Bit 31:24, reserved                       
//Bit 23:16  reg_isp_dft_hig_thrd_r         high threshold to   red channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 200;
//Bit 15: 8, reg_isp_dft_hig_thrd_g         high threshold to green channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 200;
//Bit  7: 0, reg_isp_dft_hig_thrd_b         high threshold to  blue channel channel to decide dead pixel under reg_isp_dft_detect_mode=1 (adptive mode). default= 200;
#define P_ISP_DFT_DET1_ADPTNUM0                    (volatile unsigned long *)0xd010b4ec
//Bit 31:22, reserved                       
//Bit 21:16  reg_isp_dft_adapt_num_low      threshold of number of pixels smaller than thdlow in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~46; default= 4;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_isp_dft_adapt_num_mid      threshold of number of pixels within [thdlow, thdhig] in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~46; default= 4;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_isp_dft_adapt_num_hig      threshold of number of pixels larger than thdhig in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~46; default= 4;
#define P_ISP_DFT_DET1_ADPTNUM1                    (volatile unsigned long *)0xd010b4f0
//Bit 31:22, reserved
//Bit 21:16  reg_isp_dft_adapt_num_tlow     threshold of number of pixels smaller than tthdlow in 4x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~37; default= 3;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_isp_dft_adapt_num_tmid     threshold of number of pixels within [tthdlow, tthdhig] in 5x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~37; default= 3;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_isp_dft_adapt_num_thig     threshold of number of pixels larger than tthdhig in 4x9 window to decide defect pixel under reg_isp_dft_detect_mode=1 (adptive mode). 0~37; default= 3;
// address 8'h3d~ 8'h3e null
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// demosaicing registers
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_DMS_CTRL0                            (volatile unsigned long *)0xd010b500
//Bit    31, reserved
//Bit 30:28, reg_isp_dms_bypass             bypass of demosaicing module. 0: no bypass; 1: replace (n-2) line dms result to current line; 2: (n-1) line to current; 3: (n+1) line to current; 4: (n+2) lines to current; 5~6: (n)line tocurrent; 7: bypass dms and put bayer data to RGB channels as repeat; default =0;
//Bit 27:26, reserved                       
//Bit    25, reg_isp_dms_xphase_ofst        bayer pattern xphase offset in demosaicing, 0- horizontally start from G(R)/B(G); 1- horizontally start from R(G)/G(B); default=0
//Bit    24, reg_isp_dms_yphase_ofst        bayer pattern yphase offset in demosaicing, 0- vertically start from G(B)/R(G); 1- vertially start from B(G)/G(R); default=0
//Bit 23:22, reserved                       
//Bit 21:20, reg_isp_dms_l28_simple         line 2 and line 8 green interpolation mode. 0/2: full dlmmse; 1:  using 4/6 line's alpha to replace; 2:simple alpha calculation. default= 0
//Bit 19:18, reserved                       
//Bit 17:16, reg_isp_dms_l19_simple         line 1 and line 9 green interpolation mode. 0: using 2/8 line's green to replace; 1: using left/right green pixel to replace; 2: average of left/right and 2/8 line's green; 3:smaller transition directional nearby green average; default=3 
//Bit 15: 1, reserved
//Bit     0, reg_isp_dms_dvdh_filter_mode   filter mode for dh/dv calculation. 0: [1 0 1]/2; 1: [-1 2 2 2 -1]/4; default = 0.
#define P_ISP_DMS_CTRL1                            (volatile unsigned long *)0xd010b504
//Bit 31:30, reserved
//Bit 29:28, reg_isp_dms_grn_use_cdm        dms 1st step green recovery fallback mode. 0: ussing dlmmse; 1: simple cdm; 2; simple min gradient; 3: simple average; default = 0;
//Bit 27:26, reserved
//Bit 25:24, reg_isp_dms_dnr_mode           denoise mode in greem recovery est_h/est_v calculation for high frequency component; 0: no denoise; 1: high-freq degrade by half; 2: high-freq degrade to 1/4; 3: remove high-freq; default=0
//Bit 23:21, reserved                       
//Bit    20, reg_isp_dms_rb_min_enable      enable signal to use min transition directional dms. 0: always average; 1: adaptive directional; default=1;
//Bit 19:18, reserved                       
//Bit 17:16, reg_isp_dms_rb_min_rate        minimum transition (after offset) to maximum transition ratio (./4) threshold to decide using min direction dms. 0~3. default = 2
//Bit 15: 8, reg_isp_dms_rb_min_ofst        minimum transition offset (s8) to decide whether using min direction dms or average. if reg_ISP_dms_RB_min_rate=127, will use average. -128~127; default= 5
//Bit  7: 0, reg_isp_dms_g_alp_ofset        offset to alpha in lmmse algorithm green component recovery. the larger of this value, the more blender; default = 16
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// isp color matrix 0 registers
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_MATRIX_PRE_OFST0_1                   (volatile unsigned long *)0xd010b508
//Bit 31:27, reserved
//Bit 26:16, reg_isp_matrix_pre_ofst0       input offset of component 0 (most likely red) before going to 3x3 matrix; -1024:1023. default=0
//Bit 15:11, reserved                       
//Bit 10: 0, reg_isp_matrix_pre_ofst1       input offset of component 1 (most likely green) before going to 3x3 matrix; -1024:1023. default=0
#define P_ISP_MATRIX_PRE_OFST2                     (volatile unsigned long *)0xd010b50c
//Bit 31:18, reserved                       
//Bit 17:16, reg_isp_matrix_rs              default=0                        
//Bit 15:11, reserved                       
//Bit 10: 0, reg_isp_matrix_pre_ofst2       input offset of component 2 (most likely blue) before going to 3x3 matrix; -1024:1023. default=0
#define P_ISP_MATRIX_COEF00_01                     (volatile unsigned long *)0xd010b510
//Bit 31:30, reserved
//Bit 25:16, reg_isp_matrix_coef00          3x3 matrix (0,0) coef; -512:511. default= 77.
//Bit 15:10, reserved
//Bit  9: 0, reg_isp_matrix_coef01          3x3 matrix (0,1) coef; -512:511. default=150.
#define P_ISP_MATRIX_COEF02_10                     (volatile unsigned long *)0xd010b514
//Bit 31:30, reserved                       
//Bit 25:16, reg_isp_matrix_coef02          3x3 matrix (0,2) coef; -512:511. default= 29.
//Bit 15:10, reserved                       
//Bit  9: 0, reg_isp_matrix_coef10          3x3 matrix (1,0) coef; -512:511. default=-43.
#define P_ISP_MATRIX_COEF11_12                     (volatile unsigned long *)0xd010b518
//Bit 31:30, reserved                       
//Bit 25:16, reg_isp_matrix_coef11          3x3 matrix (1,1) coef; -512:511. default=-85.
//Bit 15:10, reserved                       
//Bit  9: 0, reg_isp_matrix_coef12          3x3 matrix (1,2) coef; -512:511. default=128.
#define P_ISP_MATRIX_COEF20_21                     (volatile unsigned long *)0xd010b51c
//Bit 31:30, reserved                       
//Bit 25:16, reg_isp_matrix_coef20          3x3 matrix (2,0) coef; -512:511. default=128.
//Bit 15:10, reserved                       
//Bit  9: 0, reg_isp_matrix_coef21          3x3 matrix (2,1) coef; -512:511. default=-107.
#define P_ISP_MATRIX_COEF22                        (volatile unsigned long *)0xd010b520
//Bit 31:10, reserved                       
//Bit  9: 0, reg_isp_matrix_coef22          3x3 matrix (2,2) coef; -512:511. default=-21.
#define P_ISP_MATRIX_POS_OFST0_1                   (volatile unsigned long *)0xd010b524
//Bit 31:27, reserved
//Bit 26:16, reg_isp_matrix_pos_ofst0       output offset of component 0 (most likely Y) before going to 3x3 matrix; -1024:1023. default=0
//Bit 15:11, reserved                       
//Bit 10: 0, reg_isp_matrix_pos_ofst1       output offset of component 1 (most likely U) before going to 3x3 matrix; -1024:1023. default=512
#define P_ISP_MATRIX_POS_OFST2                     (volatile unsigned long *)0xd010b528
//Bit 31:11, reserved                       
//Bit 10: 0, reg_isp_matrix_pos_ofst2       output offset of component 2 (most likely V) before going to 3x3 matrix; -1024:1023. default=512
// address 8'h4b~ 8'h4f null
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// noise reduction and peaking registers
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_PKNR_HVBLANK_NUM                     (volatile unsigned long *)0xd010b540
//Bit 31:24, reg_isp_dms_hblank_num         dms horizontal blank pixel number.  default = 8
//Bit 23:16, reg_isp_dms_vblank_num         dms vertical blank pixel number.   default = 30
//Bit 15: 8, reg_pknr_hblank_num            peaking and noise reduction horizontal blank pixel number.  default = 8
//Bit  7: 0, reg_pknr_vblank_num            peaking and noise reduction vertical blank pixel number.   default = 30
#define P_ISP_NR_GAUSSIAN_MODE                     (volatile unsigned long *)0xd010b544
//Bit 31: 5, reserved
//Bit     4, reg_nr_gau_ymode               noise reduction luma gaussian filter mode. 0: 3x3 gaussian filter; 1:5x5 gaussian filter. default=1;
//Bit  3: 1, reserved                       
//Bit     0, reg_nr_gau_cmode               noise reduction chroma gaussian filter mode. 0: 3x3 gaussian filter; 1:5x5 gaussian filter. default=1;
#define P_ISP_PK_HVCON_LPF_MODE                    (volatile unsigned long *)0xd010b548
//Bit 31:30, reserved
//Bit 29:28, reg_hcon_hpf_mode              horizontal highpass transition ([-1 2 -1]) detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
//Bit 27:26, reserved                       
//Bit 25:24, reg_hcon_bpf_mode              horizontal bandpass transition ([-1 1 0]+[0 1 -1])detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
//Bit 23:22, reserved                       
//Bit 21:20, reg_hcon_lbpf_mode             horizontal low-bandpass transition ([-2 0 2])detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
//Bit 19:18, reserved                       
//Bit 17:16, reg_hcon_llbpf_mode            horizontal very low-bandpass transition ([1 1 0  1 1])detection vertical lowpass filter mode. 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
//Bit 15:14, reserved                       
//Bit 13:12, reg_vcon_hpf_mode              vertical highpass transition ([-1 2 -1]) detection horizontal lowpass filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
//Bit 11:10, reserved                       
//Bit  9: 8, reg_vcon_bpf_mode              vertical bandpass transition ([-1 1 0]+[0 1 -1])detection horizontal lowpass filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
//Bit  7: 6, reserved                       
//Bit  5: 4, reg_vcon_lbpf_mode             vertical low-bandpass transition ([-2 0 2])detection vertical horizontal filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
//Bit  3: 2, reserved                       
//Bit  1: 0, reg_vcon_llbpf_mode            vertical very low-bandpass transition ([1 1 0  1 1])detection horizontal lowpass filter mode. 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. default= 2;
#define P_ISP_PK_CON_BLEND_GAIN                    (volatile unsigned long *)0xd010b54c
//Bit 31:28, reg_pk_hpcon_hpgain            gain to con_hp (blended from hcon_hp, vcon_hp) to get hpcon. normalized 8 to '1'; default =4
//Bit 27:24, reg_pk_hpcon_bpgain            gain to con_bp (blended from hcon_bp, vcon_bp) to get hpcon. normalized 8 to '1'; default =4
//Bit 23:20, reg_pk_hpcon_lbpgain           gain to con_lbp (blended from hcon_lbp, vcon_lbp) to get hpcon. normalized 8 to '1'; default =0
//Bit 19:16, reg_pk_hpcon_llbpgain          gain to con_llbp (blended from hcon_llbp, vcon_llbp) to get hpcon. normalized 8 to '1'; default =0
//Bit 15:12, reg_pk_bpcon_hpgain            gain to con_hp (blended from hcon_hp, vcon_hp) to get bpcon. normalized 8 to '1'; default =0
//Bit 11: 8, reg_pk_bpcon_bpgain            gain to con_bp (blended from hcon_bp, vcon_bp) to get bpcon. normalized 8 to '1'; default =2
//Bit  7: 4, reg_pk_bpcon_lbpgain           gain to con_lbp (blended from hcon_lbp, vcon_lbp) to get bpcon. normalized 8 to '1'; default =6
//Bit  3: 0, reg_pk_bpcon_llbpgain          gain to con_llbp (blended from hcon_llbp, vcon_llbp) to get bpcon. normalized 8 to '1'; default =0
#define P_ISP_PK_CON_2CIRHPGAIN_TH_RATE            (volatile unsigned long *)0xd010b550
//reg_pk_cirhp_con2gain (0 1 5 6)
//Bit 31:24, reg_pk_cirhp_con2gain_th0      threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 25;
//Bit 23:16, reg_pk_cirhp_con2gain_th1      threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 60;
//Bit 15: 8, reg_pk_cirhp_con2gain_rate0    rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 80;
//Bit  7: 0, reg_pk_cirhp_con2gain_rate1    rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 20;
#define P_ISP_PK_CON_2CIRHPGAIN_LIMIT              (volatile unsigned long *)0xd010b554
//reg_pk_cirhp_con2gain (2 3 4)
//Bit 31:24, reg_pk_cirhp_con2gain_lv0      level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 0;
//Bit 23:16, reg_pk_cirhp_con2gain_lv1      level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 96;
//Bit 15: 8, reg_pk_cirhp_con2gain_lv2      level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255. default = 5;
//Bit  7: 0, reserved                       
#define P_ISP_PK_CON_2CIRBPGAIN_TH_RATE            (volatile unsigned long *)0xd010b558
//reg_pk_cirbp_con2gain (0 1 5 6)           
//Bit 31:24, reg_pk_cirbp_con2gain_th0      threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 20;
//Bit 23:16, reg_pk_cirbp_con2gain_th1      threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 50;
//Bit 15: 8, reg_pk_cirbp_con2gain_rate0    rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 50;
//Bit  7: 0, reg_pk_cirbp_con2gain_rate1    rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 25;
#define P_ISP_PK_CON_2CIRBPGAIN_LIMIT              (volatile unsigned long *)0xd010b55c
//reg_pk_cirbp_con2gain (2 3 4)             
//Bit 31:24, reg_pk_cirbp_con2gain_lv0      level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 0;
//Bit 23:16, reg_pk_cirbp_con2gain_lv1      level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 40;
//Bit 15: 8, reg_pk_cirbp_con2gain_lv2      level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255. default = 5;
//Bit  7: 0, reserved                       
#define P_ISP_PK_CON_2DRTHPGAIN_TH_RATE            (volatile unsigned long *)0xd010b560
//reg_pk_drthp_con2gain (0 1 5 6)
//Bit 31:24, reg_pk_drthp_con2gain_th0      threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 25;
//Bit 23:16, reg_pk_drthp_con2gain_th1      threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 60;
//Bit 15: 8, reg_pk_drthp_con2gain_rate0    rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 80;
//Bit  7: 0, reg_pk_drthp_con2gain_rate1    rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 20;
#define P_ISP_PK_CON_2DRTHPGAIN_LIMIT              (volatile unsigned long *)0xd010b564
//reg_pk_drthp_con2gain (2 3 4)             
//Bit 31:24, reg_pk_drthp_con2gain_lv0      level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 0;
//Bit 23:16, reg_pk_drthp_con2gain_lv1      level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 96;
//Bit 15: 8, reg_pk_drthp_con2gain_lv2      level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255. default = 5;
//Bit  7: 0, reserved                       
#define P_ISP_PK_CON_2DRTBPGAIN_TH_RATE            (volatile unsigned long *)0xd010b568
//reg_pk_drtbp_con2gain (0 1 5 6)           
//Bit 31:24, reg_pk_drtbp_con2gain_th0      threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 20;
//Bit 23:16, reg_pk_drtbp_con2gain_th1      threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 50;
//Bit 15: 8, reg_pk_drtbp_con2gain_rate0    rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 50;
//Bit  7: 0, reg_pk_drtbp_con2gain_rate1    rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 25;
#define P_ISP_PK_CON_2DRTBPGAIN_LIMIT              (volatile unsigned long *)0xd010b56c
//reg_pk_drtbp_con2gain (2 3 4)             
//Bit 31:24, reg_pk_drtbp_con2gain_lv0      level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 0;
//Bit 23:16, reg_pk_drtbp_con2gain_lv1      level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 40;
//Bit 15: 8, reg_pk_drtbp_con2gain_lv2      level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255. default = 5;
//Bit  7: 0, reserved                       
// address 8'h5c~ 8'h5f null
#define P_ISP_PK_CIRFB_LPF_MODE                    (volatile unsigned long *)0xd010b580
//Bit 31:30, reserved
//Bit 29:28, reg_cirhp_horz_flt_mode        vertical highpass filter ([-1 2 -1]') horizontal lpf mode for circle hpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 1;
//Bit 27:26, reserved                       
//Bit 25:24, reg_cirhp_vert_flt_mode        horizontal highpass filter ([-1 2 -1]) vertical lpf mode  for circle hpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 1;
//Bit 23:21, reserved                       
//Bit    20, reg_cirhp_diag_flt_mode        diagonal highpass filter crossing lpf mode for circle hpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
//Bit 19:14, reserved                       
//Bit 13:12, reg_cirbp_horz_flt_mode        vertical bandpass filte ([-3 1 4 1 -3]') horizontal lpf mode for circle bpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 1;
//Bit 11:10, reserved                       
//Bit  9: 8, reg_cirbp_vert_flt_mode        horizontal bandpass filte ([-3 1 4 1 -3]) vertical lpf mode  for circle bpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 1;
//Bit  7: 5, reserved                       
//Bit     4, reg_cirbp_diag_flt_mode        diagonal bandpass filter crossing lpf mode for circle bpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
//Bit  3: 0, reserved                       
#define P_ISP_PK_DRTFB_LPF_MODE                    (volatile unsigned long *)0xd010b584
//Bit 31:30, reserved                       
//Bit 29:28, reg_drthp_horz_flt_mode        vertical highpass filter ([-1 2 -1]') horizontal lpf mode for directional hpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 2;
//Bit 27:26, reserved                       
//Bit 25:24, reg_drthp_vert_flt_mode        horizontal highpass filter ([-1 2 -1]) vertical lpf mode  for directional hpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
//Bit 23:21, reserved                       
//Bit    20, reg_drthp_diag_flt_mode        diagonal highpass filter crossing lpf mode for directional hpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
//Bit 19:14, reserved                       
//Bit 13:12, reg_drtbp_horz_flt_mode        vertical bandpass filte ([-3 1 4 1 -3]') horizontal lpf mode for directional bpf calculation. 0: no lpf filter;1:[1 2 1]/4 filter; 2/3: [1 2 2 2 1]/8 filter. default= 2;
//Bit 11:10, reserved                       
//Bit  9: 8, reg_drtbp_vert_flt_mode        horizontal bandpass filte ([-3 1 4 1 -3]) vertical lpf mode  for directional bpf calculation. 0: no lpf filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter. default= 2;
//Bit  7: 5, reserved                       
//Bit     4, reg_drtbp_diag_flt_mode        diagonal bandpass filter crossing lpf mode for directional bpf calculaton. 0: no lpf filter; 1:[1 2 1]/4 filter; default =1;
//Bit  3: 0, reserved                       
#define P_ISP_PK_CIRFB_HP_CORING                   (volatile unsigned long *)0xd010b588
//Bit 31:22, reserved
//Bit 21:16, reg_cirhp_horz_core            coring to vertical highpass filter ([-1 2 -1]') in circle hpf calculation. 0~63. default= 20;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_cirhp_vert_core            coring to horizontal highpass filter ([-1 2 -1])  in circle hpf calculation. 0~63. default= 20;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_cirhp_diag_core            coring to diagonal highpass filter ([-1 2 -1])  in circle hpf calculation. 0~63. default= 20;
#define P_ISP_PK_CIRFB_BP_CORING                   (volatile unsigned long *)0xd010b58c
//Bit 31:22, reserved                       
//Bit 21:16, reg_cirbp_horz_core            coring to vertical bandpass filter ([-1 2 -1]') in circle bpf calculation. 0~63. default= 15;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_cirbp_vert_core            coring to horizontal bandpass filter ([-1 2 -1])  in circle bpf calculation. 0~63. default= 15;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_cirbp_diag_core            coring to diagonal bandpass filter ([-1 2 -1])  in circle bpf calculation. 0~63. default= 15;
#define P_ISP_PK_DRTFB_HP_CORING                   (volatile unsigned long *)0xd010b590
//Bit 31:22, reserved                       
//Bit 21:16, reg_drthp_horz_core            coring to vertical highpass filter ([-1 2 -1]') in directional hpf calculation. 0~63. default= 20;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_drthp_vert_core            coring to horizontal highpass filter ([-1 2 -1])  in directional hpf calculation. 0~63. default= 20;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_drthp_diag_core            coring to diagonal highpass filter ([-1 2 -1])  in directional hpf calculation. 0~63. default= 20;
#define P_ISP_PK_DRTFB_BP_CORING                   (volatile unsigned long *)0xd010b594
//Bit 31:22, reserved                       
//Bit 21:16, reg_drtbp_horz_core            coring to vertical bandpass filter ([-1 2 -1]') in directional bpf calculation. 0~63. default= 15;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_drtbp_vert_core            coring to horizontal bandpass filter ([-1 2 -1])  in directional bpf calculation. 0~63. default= 15;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_drtbp_diag_core            coring to diagonal bandpass filter ([-1 2 -1])  in directional bpf calculation. 0~63. default= 15;
#define P_ISP_PK_CIRFB_BLEND_GAIN                  (volatile unsigned long *)0xd010b598
//Bit 31:28, reg_hp_cir_hgain               vertical hpf gain for hp_cir calculation. 0~15. normalize 8 as '1';  default = 8;
//Bit 27:24, reg_hp_cir_vgain               horizontal hpf gain for hp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
//Bit 23:20, reg_hp_cir_dgain               diagonal hpf gain for hp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
//Bit 19:16, reserved                       
//Bit 15:12, reg_bp_cir_hgain               vertical bpf gain for bp_cir calculation. 0~15. normalize 8 as '1';  default = 8;
//Bit 11: 8, reg_bp_cir_vgain               horizontal bpf gain for bp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
//Bit  7: 4, reg_bp_cir_dgain               diagonal bpf gain for bp_cir calculation. 0~15. normalize 8 as '1'; default = 8;
//Bit  3: 0, reserved                       
// address 8'h67~ 8'h67 null
//nr_alp0 is for blending of gaussian and original results
#define P_ISP_NR_ALPY_SSD_GAIN_OFST                (volatile unsigned long *)0xd010b5a0
//Bit 31:16, reserved
//Bit 15: 8, reg_nr_alp0_ssd_gain           gain to signed sum difference (SSD for transition detection) for alpha0 calculation. the smaller of this value, the more blur of image (more Gaussian results). 0~255, normalized 16 as '1'; default= 16     
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_nr_alp0_ssd_ofst           ofsset to SSD before dividing to min_err. the smaller of this value, the more blur of image (more Gaussian results); -32:31. default= -2;
#define P_ISP_NR_ALP0Y_ERR2CURV_TH_RATE            (volatile unsigned long *)0xd010b5a4
//reg_nr_alp0_minerr_ypar (0 1 5 6)
//Bit 31:24, reg_nr_alp0_minerr_ypar_th0    threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255. default = 10;
//Bit 23:16, reg_nr_alp0_minerr_ypar_th1    threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur. 0~255. default = 25;
//Bit 15: 8, reg_nr_alp0_minerr_ypar_rate0  rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255. default = 80;
//Bit  7: 0, reg_nr_alp0_minerr_ypar_rate1  rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255. default = 64;
//reg_nr_alp0_minerr_ypar (2 3 4)
#define P_ISP_NR_ALP0Y_ERR2CURV_LIMIT              (volatile unsigned long *)0xd010b5a8
//Bit 31:24, reg_nr_alp0_minerr_ypar_lv0    level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255. default = 63;
//Bit 23:16, reg_nr_alp0_minerr_ypar_lv1    level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255. default = 0;
//Bit 15: 8, reg_nr_alp0_minerr_ypar_lv2    level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255. default = 63;
//Bit  7: 0, reserved                       
//reg_nr_alp0_minerr_cpar (0 1 5 6)         
#define P_ISP_NR_ALP0C_ERR2CURV_TH_RATE            (volatile unsigned long *)0xd010b5ac
//Bit 31:24, reg_nr_alp0_minerr_cpar_th0    threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur. 0~255. default = 10;
//Bit 23:16, reg_nr_alp0_minerr_cpar_th1    threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur. 0~255. default = 25;
//Bit 15: 8, reg_nr_alp0_minerr_cpar_rate0  rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255. default = 80;
//Bit  7: 0, reg_nr_alp0_minerr_cpar_rate1  rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255. default = 64;
//reg_nr_alp0_minerr_cpar (2 3 4)
#define P_ISP_NR_ALP0C_ERR2CURV_LIMIT              (volatile unsigned long *)0xd010b5b0
//Bit 31:24, reg_nr_alp0_minerr_cpar_lv0    level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255. default = 63;
//Bit 23:16, reg_nr_alp0_minerr_cpar_lv1    level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255. default = 0;
//Bit 15: 8, reg_nr_alp0_minerr_cpar_lv2    level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255. default = 63;
//Bit  7: 0, reserved                       
#define P_ISP_NR_ALP0_MIN_MAX                      (volatile unsigned long *)0xd010b5b4
//Bit 31:30, reserved                       
//Bit 29:24, reg_nr_alp0_ymin               minumum limit of alp0 for luma channel, if it is 63, means all gaussian lpf result, 0~63, . default = 2;
//Bit 23:22, reserved                       
//Bit 21:16, reg_nr_alp0_ymax               maximum limit of alp0 for luma channel, if it is  0, means all orginal result, 0~63, . default = 63;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_nr_alp0_cmin               minumum limit of alp0 for chroma channel, if it is 63, means all gaussian lpf result, 0~63, . default = 2;
//Bit  7: 6, reserved
//Bit  5: 0, reg_nr_alp0_cmax               maximum limit of alp0 for chroma channel, if it is  0, means all orginal result, 0~63, . default = 63;
#define P_ISP_NR_ALP1_MIERR_CORING                 (volatile unsigned long *)0xd010b5b8
//Bit 31:17, reserved
//Bit    16, reg_nr_alp1_maxerr_mode        mxerr select mode. 0: max_err of eight directions; 1: crossing direction of min_err direction. default=0;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_nr_alp1_core_rate          rate to (mxerr-min_err) to get coring to min_err. normalized to 64 as '1'. 0~63. default =0;   
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_nr_alp1_core_ofst          offset of coring to min_err. normalized to 64 as '1'. 0~63. default =3;
#define P_ISP_NR_ALP1_ERR2CURV_TH_RATE             (volatile unsigned long *)0xd010b5bc
//reg_nr_alp1_minerr_par (0 1 5 6)          
//Bit 31:24, reg_nr_alp1_minerr_par_th0     threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255. default = 0;
//Bit 23:16, reg_nr_alp1_minerr_par_th1     threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255. default = 24;
//Bit 15: 8, reg_nr_alp1_minerr_par_rate0   rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. default = 0;
//Bit  7: 0, reg_nr_alp1_minerr_par_rate1   rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. default = 20;
#define P_ISP_NR_ALP1_ERR2CURV_LIMIT               (volatile unsigned long *)0xd010b5c0
//reg_nr_alp1_minerr_par (2 3 4)            
//Bit 31:24, reg_nr_alp1_minerr_par_lv0     level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255. default = 0;
//Bit 23:16, reg_nr_alp1_minerr_par_lv1     level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255. default = 16;
//Bit 15: 8, reg_nr_alp1_minerr_par_lv2     level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255. default = 63;
//Bit  7: 0, reserved                       
#define P_ISP_NR_ALP1_MIN_MAX                      (volatile unsigned long *)0xd010b5c4
//Bit 31:30, reserved
//Bit 29:24, reg_nr_alp1_ymin               minumum limit of alp1 for luma channel, if it is 63, means all directional lpf result, 0~63, . default = 0;
//Bit 23:22, reserved                       
//Bit 21:16, reg_nr_alp1_ymax               maximum limit of alp1 for luma channel, if it is  0, means all gaussian blend  result, 0~63, . default = 63;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_nr_alp1_cmin               minumum limit of alp1 for chroma channel, if it is 63, means all directonal lpf result, 0~63, . default = 0;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_nr_alp1_cmax               maximum limit of alp1 for chroma channel, if it is  0, means all gaussian blend result, 0~63, . default = 63;
#define P_ISP_PK_ALP2_MIERR_CORING                 (volatile unsigned long *)0xd010b5c8
//Bit 31:17, reserved                       
//Bit    16, reg_nr_alp2_maxerr_mode        mxerr select mode for alp2 calculation. 0: max_err of eight directions; 1: crossing direction of min_err direction. default=1;
//Bit 15:14, reserved                       
//Bit 13: 8, reg_nr_alp2_core_rate          rate to (mxerr-min_err) to get coring to min_err for alp2 calculation. normalized to 64 as '1'. 0~63. default =13;   
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_nr_alp2_core_ofst          offset of coring to min_err for alp2 calculation. normalized to 64 as '1'. 0~63. default =1;
#define P_ISP_PK_ALP2_ERR2CURV_TH_RATE             (volatile unsigned long *)0xd010b5cc
//reg_nr_alp2_minerr_par (0 1 5 6)          
//Bit 31:24, reg_nr_alp2_minerr_par_th0     threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking. 0~255. default = 0;
//Bit 23:16, reg_nr_alp2_minerr_par_th1     threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255. default = 24;
//Bit 15: 8, reg_nr_alp2_minerr_par_rate0   rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255. default = 0;
//Bit  7: 0, reg_nr_alp2_minerr_par_rate1   rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255. default = 20;
#define P_ISP_PK_ALP2_ERR2CURV_LIMIT               (volatile unsigned long *)0xd010b5d0
//reg_nr_alp1_minerr_par (2 3 4)            
//Bit 31:24, reg_nr_alp2_minerr_par_lv0     level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255. default = 0;
//Bit 23:16, reg_nr_alp2_minerr_par_lv1     level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255. default = 16;
//Bit 15: 8, reg_nr_alp2_minerr_par_lv2     level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 63;
//Bit  7: 0, reserved                       
#define P_ISP_PK_ALP2_MIN_MAX                      (volatile unsigned long *)0xd010b5d4
//Bit 31:14, reserved
//Bit 13: 8, reg_nr_alp2_min                minumum limit of alp2 for luma channel, if it is 63, means directional peaking result, 0~63, . default = 0;
//Bit  7: 6, reserved                       
//Bit  5: 0, reg_nr_alp2_max                maximum limit of alp2 for luma channel, if it is  0, means all circle peaking result, 0~63, . default = 63;
#define P_ISP_PK_FINALGAIN_HP_BP                   (volatile unsigned long *)0xd010b5d8
//Bit 31:16, reserved                       
//Bit 15: 8, reg_hp_final_gain              gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. default = 40;
//Bit  7: 0, reg_bp_final_gain              gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. default = 40;
// address 8'h77~ 8'h77 null 
#define P_ISP_PK_OS_HORZ_CORE_GAIN                 (volatile unsigned long *)0xd010b5e0
//Bit 31:24, reg_os_hside_core              side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255; default= 8;             
//Bit 23:16, reg_os_hside_gain              side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255; default= 20;     
//Bit 15: 8, reg_os_hmidd_core              midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255; default= 2;             
//Bit  7: 0, reg_os_hmidd_gain              midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255; default= 20;   
#define P_ISP_PK_OS_VERT_CORE_GAIN                 (volatile unsigned long *)0xd010b5e4
//Bit 31:24, reg_os_vside_core              side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255; default= 2;             
//Bit 23:16, reg_os_vside_gain              side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255; default= 20;     
//Bit 15: 8, reg_os_vmidd_core              midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255; default= 8;             
//Bit  7: 0, reg_os_vmidd_gain              midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255; default= 20;   
#define P_ISP_PK_OS_ADPT_MISC                      (volatile unsigned long *)0xd010b5e8
//Bit 31:24, reg_pk_os_minerr_core          coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255; default= 40;             
//Bit 23:16, reg_pk_os_minerr_gain          gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255; default= 6;     
//Bit 15: 8, reg_pk_os_adpt_max             maximum limit adaptive overshoot margin (4x). 0~255; default= 200;             
//Bit  7: 0, reg_pk_os_adpt_min             minimun limit adaptive overshoot margin (1x). 0~255; default= 20; 
#define P_ISP_PK_OS_STATIC                         (volatile unsigned long *)0xd010b5ec
//Bit 31:30, reserved
//Bit 29:28, reg_pk_osh_mode                horizontal min_max window size for overshoot. window size =(2x+1); 0~3. default=2;   
//Bit 27:26, reserved                       
//Bit 25:24, reg_pk_osv_mode                vertical min_max window size for overshoot. window size =(2x+1); 0~2. default=2;
//Bit 23:22, reserved                       
//Bit 21:12, reg_pk_os_down                 static negative overshoot margin. 0~1023; default= 0;     
//Bit 11:10, reserved                       
//Bit  9: 0, reg_pk_os_up                   static positive overshoot margin. 0~1023; default= 0; 
// address 8'h7c~ 8'h7f null 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// special digital effect register
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_PKSDE_MODE_PKGAIN                    (volatile unsigned long *)0xd010b600
//Bit    31, reserved
//Bit 30:28, reg_pksde_ymode                luma channel sde mode. 0~7. 0, no SDE; 1: rplc+ peaking; 2: rplc - peaking; 3: rplc+ peaking>0; 4: rplc + peaking<0; 5: rplc+ abs(peaking) 6: rplc-abs(peaking); 7: binary; default = 0;
//Bit    27, reserved                       
//Bit 26:24, reg_pksde_umode                U channel sde mode. 0~7. 0, no SDE; 1: rplc+ peaking; 2: rplc - peaking; 3: rplc+ peaking>0; 4: rplc + peaking<0; 5: rplc+ abs(peaking) 6: rplc-abs(peaking); 7: binary ; default = 0;
//Bit    23, reserved                       
//Bit 22:20, reg_pksde_vmode                V channel sde mode. 0~7. 0, no SDE; 1: rplc+ peaking; 2: rplc - peaking; 3: rplc+ peaking>0; 4: rplc + peaking<0; 5: rplc+ abs(peaking) 6: rplc-abs(peaking); 7: binary ; default = 0;
//Bit 19:12, reserved                       
//Bit 11: 8, reg_pksde_pk4y_gain            gain to peaking boost component and add delta to luma channel. normalized 8 as '1'. 0~15; default=8 
//Bit  7: 4, reg_pksde_pk4u_gain            gain to peaking boost component and add delta to u channel. normalized 8 as '1'. 0~15; default=8 
//Bit  3: 0, reg_pksde_pk4v_gain            gain to peaking boost component and add delta to v channel. normalized 8 as '1'. 0~15; default=8 
#define P_ISP_PKSDE_REPLACE_Y_U                    (volatile unsigned long *)0xd010b604
//Bit 31:29, reserved
//Bit    28, reg_pksde_rplc_yen             enable to replace Y channel with reg_pksde_rplc_y. default = 0
//Bit 27:26, reserved                       
//Bit 25:16, reg_pksde_rplc_y               luma value to be replaced to Y channel when reg_pksde_rplc_yen=1. 0~1023. default = 512
//Bit 15:13, reserved                       
//Bit    12, reg_pksde_rplc_uen             enable to replace U channel with reg_pksde_rplc_u. default = 0
//Bit 11:10, reserved                       
//Bit  9: 0, reg_pksde_rplc_u               U value to be replaced to U channel when reg_pksde_rplc_uen=1. 0~1023. default = 512
#define P_ISP_PKSDE_REPLACE_V                      (volatile unsigned long *)0xd010b608
//Bit 31:29, reserved                       
//Bit    28, reg_pksde_rplc_ven             enable to replace V channel with reg_pksde_rplc_v. default = 0
//Bit 27:26, reserved                       
//Bit 25:16, reg_pksde_rplc_v               V value to be replaced to V channel when reg_pksde_rplc_ven=1. 0~1023. default = 512
//Bit 15: 0, reserved                       
#define P_ISP_PKSDE_BINARY_HIG                     (volatile unsigned long *)0xd010b60c
//Bit 31:24, reserved                       
//Bit 23:16, reg_pksde_yposi                binary effect high luma level for Y. 0~255. default = 192
//Bit 15: 8, reg_pksde_uposi                binary effect high U level for U. 0~255. default = 192
//Bit  7: 0, reg_pksde_vposi                binary effect high V level for V. 0~255. default = 192
#define P_ISP_PKSDE_BINARY_LOW                     (volatile unsigned long *)0xd010b610
//Bit 31:24, reserved
//Bit 23:16, reg_pksde_ynegi                binary effect low luma level for Y. 0~255. default = 64
//Bit 15: 8, reg_pksde_unegi                binary effect low U level for U. 0~255. default = 128
//Bit  7: 0, reg_pksde_vnegi                binary effect low V level for V. 0~255. default = 128
#define P_ISP_PKNR_ENABLE                          (volatile unsigned long *)0xd010b614
//Bit 31: 2, reserved
//Bit     1, reg_isp_pk_en                isp peaking enable default = 1
//Bit     0, reg_isp_nr_en                isp noise reduction enable default = 1
// address 8'h86~ 8'h87 null 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  auto white balance statistics registers
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_AWB_WIND_LR                          (volatile unsigned long *)0xd010b620
//Bit 31:29, reserved
//Bit 28:16, reg_isp_awb_wind_left          window left x index for rgb raw statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_awb_wind_righ          window right x index for rgb raw statistics. 0~8191. default = 100.
#define P_ISP_AWB_WIND_TB                          (volatile unsigned long *)0xd010b624
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_awb_wind_top           window top y index for awb rgb statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_awb_wind_bot           window bot y index for awb rgb statistics. 0~8191. default = 100.
#define P_ISP_AWB_GBGRBR_THRD                      (volatile unsigned long *)0xd010b628
//Bit 31:24, reserved                       
//Bit 23:16, reg_isp_awb_gb_thrd            threshold to abs(g-b) to decide adding to awb statistics. 0~255. default = 200.
//Bit 15: 8, reg_isp_awb_gr_thrd            threshold to abs(g-r) to decide adding to awb statistics. 0~255. default = 200.
//Bit  7: 0, reg_isp_awb_br_thrd            threshold to abs(b-r) to decide adding to awb statistics. 0~255. default = 200.
#define P_ISP_AWB_UVTH_YPIECE                      (volatile unsigned long *)0xd010b62c
//Bit 31:24, reg_isp_awb_u_thrd             threshold to abs(u-128) to decide adding to awb statistics. 0~255. default = 200.
//Bit 23:16, reg_isp_awb_v_thrd             threshold to abs(v-128) to decide adding to awb statistics. 0~255. default = 200.
//Bit 15: 8, reg_isp_awb_ypiece_low         low threshold of Y to decide adding to awb statistics to yluv_sum/num and ymuv_sum/num. 0~255. default = 50. 
//Bit  7: 0, reg_isp_awb_ypiece_hig         hig threshold of Y to decide adding to awb statistics to yhuv_sum/num and ymuv_sum/num. 0~255. default = 200. 
#define P_ISP_AWB_AEC_ENABLE                       (volatile unsigned long *)0xd010b630
//Bit 31: 3, reserved
//Bit     2, reg_isp_aec_raw_en             default = 1.
//Bit     1, reg_isp_aec_stat_en            default = 1.
//Bit     0, reg_isp_awb_stat_en            default = 1. 
// address 8'h8d~ 8'h8f null 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  auto exposure statistics registers
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_AEC_THRESHOLDS                       (volatile unsigned long *)0xd010b640
//Bit 31:24, reg_isp_aec_luma_lowlmt        luma low limit when added to aec statistics in 4x4 regions. 0~255, default = 128
//Bit 23:16, reg_isp_aec_rawbright_r        red pixels considered as too bright threshold. 0~255, default = 200
//Bit 15: 8, reg_isp_aec_rawbright_g        green pixels considered as too bright threshold. 0~255, default = 200
//Bit  7: 0, reg_isp_aec_rawbright_b        blue pixels considered as too bright threshold. 0~255, default = 200
#define P_ISP_AEC_WIND_XYSTART                     (volatile unsigned long *)0xd010b644
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_aec_wind_xstart        window 0 left x index for AEC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_aec_wind_ystart        window 0 top y index for AEC statistics. 0~8191. default = 0.
#define P_ISP_AEC_WIND_XYSTEP                      (volatile unsigned long *)0xd010b648
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_aec_wind_xstep         window 0 sub-window x lenght for AEC statistics. 0~8191. default = 64.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_aec_wind_ystep         window 0 sub-window y lenght for AEC statistics. 0~8191. default = 64.
#define P_ISP_AECRAW_WIND_LR                       (volatile unsigned long *)0xd010b64c
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_aecraw_wind_left       window left x index for AEC raw statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_aecraw_wind_righ       window right x index for AEC raw statistics. 0~8191. default = 100.
#define P_ISP_AECRAW_WIND_TB                       (volatile unsigned long *)0xd010b650
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_aecraw_wind_top        window top y index for AEC raw statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_aecraw_wind_bot        window bot y index for AEC raw statistics. 0~8191. default = 100.
// address 8'h95~ 8'h97 null 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  auto focus statistics registers
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_AFC_FILTER_SEL                       (volatile unsigned long *)0xd010b660
//Bit 31:17, reserved
//Bit    16, reg_isp_afc_stat_en            auto focus statistics read-only register update enable. 0: no update; 1: update in v blank time default=1
//Bit    15, reserved                       
//Bit 14:12, reg_isp_afc_f0_select          filter 0 selection mode. 0: [-2 2]; 1: [-1 0  1;-1 0 1; -1 0 1]; 2: [-1 0  1;-2 0 2; -1 0 1]; 3: [-1 0 0 0  1;-2 0 0 0 2; -1 0 0 0 1]; 4:[-1 2 -1;-1 2 -1;-1 2 -1]; 5/up:[-1 0 2 0 -1;-1 0 2 0 -1;-1 0 2 0 -1]; default= 2
//Bit    11, reserved                       
//Bit 10: 8, reg_isp_afc_f1_select          filter 1 selection mode. 0: [-2 2]; 1: [-1 0  1;-1 0 1; -1 0 1]; 2: [-1 0  1;-2 0 2; -1 0 1]; 3: [-1 0 0 0  1;-2 0 0 0 2; -1 0 0 0 1]; 4:[-1 2 -1;-1 2 -1;-1 2 -1]; 5/up:[-1 0 2 0 -1;-1 0 2 0 -1;-1 0 2 0 -1]; default= 4
//Bit  7: 4, reg_isp_afc_f0_coring          coring to filter 0 filtering result before doing accum, to reduce noise interference. 0~15. default=2
//Bit  3: 0, reg_isp_afc_f1_coring          coring to filter 1 filtering result before doing accum, to reduce noise interference. 0~15. default=2
#define P_ISP_AFC_WIND0_LR                         (volatile unsigned long *)0xd010b664
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind0_left         window 0 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind0_righ         window 0 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND0_TB                         (volatile unsigned long *)0xd010b668
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind0_top          window 0 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind0_bot          window 0 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND1_LR                         (volatile unsigned long *)0xd010b66c
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind1_left         window 1 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind1_righ         window 1 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND1_TB                         (volatile unsigned long *)0xd010b670
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind1_top          window 1 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind1_bot          window 1 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND2_LR                         (volatile unsigned long *)0xd010b674
//Bit 31:29, reserved
//Bit 28:16, reg_isp_afc_wind2_left         window 2 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind2_righ         window 2 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND2_TB                         (volatile unsigned long *)0xd010b678
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind2_top          window 2 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind2_bot          window 2 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND3_LR                         (volatile unsigned long *)0xd010b67c
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind3_left         window 3 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind3_righ         window 3 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND3_TB                         (volatile unsigned long *)0xd010b680
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind3_top          window 3 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind3_bot          window 3 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND4_LR                         (volatile unsigned long *)0xd010b684
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind4_left         window 4 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind4_righ         window 4 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND4_TB                         (volatile unsigned long *)0xd010b688
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind4_top          window 4 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved
//Bit 12: 0, reg_isp_afc_wind4_bot          window 4 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND5_LR                         (volatile unsigned long *)0xd010b68c
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind5_left         window 5 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind5_righ         window 5 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND5_TB                         (volatile unsigned long *)0xd010b690
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind5_top          window 5 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind5_bot          window 5 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND6_LR                         (volatile unsigned long *)0xd010b694
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind6_left         window 6 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind6_righ         window 6 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND6_TB                         (volatile unsigned long *)0xd010b698
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind6_top          window 6 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind6_bot          window 6 bot y index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND7_LR                         (volatile unsigned long *)0xd010b69c
//Bit 31:29, reserved
//Bit 28:16, reg_isp_afc_wind7_left         window 7 left x index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind7_righ         window 7 right x index for AFC statistics. 0~8191. default = 100.
#define P_ISP_AFC_WIND7_TB                         (volatile unsigned long *)0xd010b6a0
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_afc_wind7_top          window 7 top y index for AFC statistics. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_afc_wind7_bot          window 7 bot y index for AFC statistics. 0~8191. default = 100.
// address 8'ha9~ 8'hab null 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  black level and noise level statistics registers
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_BLNR_CTRL                            (volatile unsigned long *)0xd010b6b0
//Bit 31: 9, reserved
//Bit     8, reg_isp_blnr_stat_en           enable for black level and noise level statistics on raw data. 0: no statistics; 1: enable. default =1
//Bit  7: 6, reserved                       
//Bit  5: 4, reg_isp_blnr_lpf_mode          mode for lpf in black level and noise level statistics on raw data.0~3. 0: no lpf; 1: [1 2 1]/4 2/3: [1 2 2 2 1]/8; . default =3
//Bit  3: 2, reserved                       
//Bit  1: 0, reg_isp_blnr_ac_adaptive       mode for noise statistics in horizontal and vertical ac blending. 0~3. u2: 0: (H+V)/2; 1: sqrt(H^2 + V^2); 2: min(H,V); 3: max(H,V). default = 2
#define P_ISP_BLNR_WIND_LR                         (volatile unsigned long *)0xd010b6b4
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_blnr_wind_left         window left x index for black level and noise level statistics on raw data. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_blnr_wind_righ         window right x index for black level and noise level statistics on raw data. 0~8191. default = 100.
#define P_ISP_BLNR_WIND_TB                         (volatile unsigned long *)0xd010b6b8
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_blnr_wind_top          window top y index for black level and noise level statistics on raw data. 0~8191. default = 0.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_blnr_wind_bot          window bot y index for black level and noise level statistics on raw data. 0~8191. default = 100.
// don't add to reg script
#define P_ISP_RAM_ACC_MODE                         (volatile unsigned long *)0xd010b6bc
// 31: 4, reserved                       
//  3: 2, reg_isp_lnsd_lut_cbus_mode      default = 0
//  1: 0, reg_isp_dft_lut_cbus_mode      default = 0
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  raw component statistics registers
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define P_ISP_DBG_PIXEL_CTRL                       (volatile unsigned long *)0xd010b6c0
//Bit 31: 2, reserved
//Bit  3: 2, reg_isp_dbg_bypass_outfmt      bypass the raw data format.
//                                          2'b00: not bypass; 
//                                          2'b01: force the LSB 2bits of channal 0 to 0,force channel 1 and channel 2 to 0;
//                                          2'b10: force the LSB 2bits of channal 0 to 0,force channel 1 and channel to the LSB 2bits of channal 0
//                                          2'b11: same as 2'b00   
//Bit  1: 0, reg_isp_dbg_pixel_lpf          low-pass filter mode for debug pixel position. 0~3. 0: no lpf; 1: [1 2 1]/4; 2: [1 2 1]'/4; 3: [0 1 0; 1 1 1;0 1 0]; default = 0
#define P_ISP_DBG_PIXEL_POSITION                   (volatile unsigned long *)0xd010b6c4
//Bit 31:29, reserved                       
//Bit 28:16, reg_isp_dbg_pixel_xpos         x index of pixel for debug on raw data. 0~8191. default = 100.
//Bit 15:13, reserved                       
//Bit 12: 0, reg_isp_dbg_pixel_ypos         y index of pixel for debug on raw data. 0~8191. default = 1000.
#define P_ISP_RO_DBG_PIXEL_GRBG0_1                 (volatile unsigned long *)0xd010b6c8
//Bit 31:26, reserved                       
//Bit 25:16, ro_isp_dbg_pixel_grbg_0        phasDATA_PORTe 0 green component value of the debuged postion (x,y).
//Bit 15:10, reserved                       
//Bit  9: 0, ro_isp_dbg_pixel_grbg_1        phase 1 red component value of the debuged postion (x,y).
#define P_ISP_RO_DBG_PIXEL_GRBG2_3                 (volatile unsigned long *)0xd010b6cc
//Bit 31:26, reserved                       
//Bit 25:16, ro_isp_dbg_pixel_grbg_2        phase 2 blue component value of the debuged postion (x,y).
//Bit 15:10, reserved                       
//Bit  9: 0, ro_isp_dbg_pixel_grbg_3        phase 3 green component value of the debuged postion (x,y).
// LUT1024/dft_LUT9x32
#define P_ISP_RO_DFT_LUTMEM_CTRL                   (volatile unsigned long *)0xd010b4c8
//Bit 31:11, reserved
//Bit 10: 0, ro_isp_dft_lutpointer          pointer of the latest defect pixel position in LUT1024. will be accumulated in HW, but will be readout
#define P_ISP_RO_DFT_DET_NUM                       (volatile unsigned long *)0xd010b4fc
//Bit 31:28, reserved
//Bit 27: 0, ro_isp_dftpixel_num            read-only register for detected defect pixels numbers of each frame. shadow locked version during v-blank.
#define P_ISP_RO_INFORD_STATE                      (volatile unsigned long *)0xd010b6d0
//Bit 31: 4, reserved                       
//Bit  3: 0, ro_isp_stat_ram_rw_st          statistic ram rd/wr state        
#define P_ISP_RO_DINVLD_HVCNT                      (volatile unsigned long *)0xd010b6d4
//Bit 31:29, reserved                       
//Bit 28:16, ro_dinvld_row_cnt              din valid row count         
//Bit 15:13, reserved                       
//Bit 12: 0, ro_dinvld_col_cnt              din valid collumn count
#define P_ISP_RO_FRM_HS_STAT                       (volatile unsigned long *)0xd010b6d8
//Bit 31:17, reserved
//Bit    16, ro_short_line_sta              for check the short line state
//Bit 15: 0, ro_frm_hs_stat                 for statistic the hsyn num in each frame
//////////////////////////////////////////////////////////////////////////////////////////////////////
//  index + data
/////////////////////////////////////////////////////////////////////////////////////////////////////
// note there are some space in the header
#define P_ISP_RO_ADDR_PORT                         (volatile unsigned long *)0xd010b700
#define P_ISP_RO_DATA_PORT                         (volatile unsigned long *)0xd010b704

//////////////////////////////////////////////////////////////////////////////////////////////////////
// read-only registers
//////////////////////////////////////////////////////////////////////////////////////////////////////
//=================================awb readonly=======================================================

#define ISP_RO_AWB_RED_SUM                  0x00  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_red_sum             red accum statistics for awb.
#define ISP_RO_AWB_GRN_SUM                  0x01  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_grn_sum             green accum statistics for awb.
#define ISP_RO_AWB_BLU_SUM                  0x02  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_blu_sum             blue accum statistics for awb.
#define ISP_RO_AWB_RGB_NUM                  0x03  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_rgb_num             number of rgb pixels added to statistics for awb.

#define ISP_RO_AWB_LOW_UNEG_SUM             0x04  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_low_uneg_sum        u (u<0) accum statistics for y<reg_isp_awb_ypiece_low awb.
#define ISP_RO_AWB_LOW_VNEG_SUM             0x05  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_low_vneg_sum        v (v<0) accum statistics for y<reg_isp_awb_ypiece_low awb.
#define ISP_RO_AWB_LOW_UPOS_SUM             0x06  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_low_upos_sum        u (u>=0) accum statistics for y>=reg_isp_awb_ypiece_high awb.
#define ISP_RO_AWB_LOW_VPOS_SUM             0x07  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_low_vpos_sum        v (v>=0) accum statistics for y>=reg_isp_awb_ypiece_high awb.

#define ISP_RO_AWB_LOW_UNEG_NUM             0x08  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_low_uneg_num        number of u (u<0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
#define ISP_RO_AWB_LOW_VNEG_NUM             0x08  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_low_vneg_num        number of v (v<0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
#define ISP_RO_AWB_LOW_UPOS_NUM             0x0a  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_low_upos_num        number of u (u>=0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.
#define ISP_RO_AWB_LOW_VPOS_NUM             0x0b  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_low_vpos_num        number of v (v>=0) put to accum statistics for y<reg_isp_awb_ypiece_low awb.

#define ISP_RO_AWB_MID_UNEG_SUM             0x0c  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_mid_uneg_sum        u (u<0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_MID_VNEG_SUM             0x0d  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_mid_vneg_sum        v (v<0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_MID_UPOS_SUM             0x0e  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_mid_upos_sum        u (u>=0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_MID_VPOS_SUM             0x0f  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_mid_vpos_sum        v (v>=0) accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.

#define ISP_RO_AWB_MID_UNEG_NUM             0x10  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_mid_uneg_num        number of u (u<0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_MID_VNEG_NUM             0x11  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_mid_vneg_num        number of v (v<0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_MID_UPOS_NUM             0x12  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_mid_upos_num        number of u (u>=0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_MID_VPOS_NUM             0x13  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_mid_vpos_num        number of v (v>=0) put to accum statistics for reg_isp_awb_ypiece_low<=y<=reg_isp_awb_ypiece_hig awb.

#define ISP_RO_AWB_HIG_UNEG_SUM             0x14  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_hig_uneg_sum        u (u<0) accum statistics for y>reg_isp_awb_ypiece_hig awb.isp_top.v
#define ISP_RO_AWB_HIG_VNEG_SUM             0x15  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_hig_vneg_sum        v (v<0) accum statistics for y>reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_HIG_UPOS_SUM             0x16  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_hig_upos_sum        u (u>=0) accum statistics for y>reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_HIG_VPOS_SUM             0x17  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_awb_hig_vpos_sum        v (v>=0) accum statistics for y>reg_isp_awb_ypiece_hig awb.

#define ISP_RO_AWB_HIG_UNEG_NUM             0x18  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_hig_uneg_num        number of u (u<0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_HIG_VNEG_NUM             0x19  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_hig_vneg_num        number of v (v<0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_HIG_UPOS_NUM             0x1a  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_hig_upos_num        number of u (u>=0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.
#define ISP_RO_AWB_HIG_VPOS_NUM             0x1b  //read-only register, update each v-blank
//Bit 31:24, reserved                       
//Bit 23: 0, ro_isp_awb_hig_vpos_num        number of v (v>=0) put to accum statistics for y>reg_isp_awb_ypiece_hig awb.

//======================================aec readonly ==========================================================
#define ISP_RO_AEC_LUMA_WIND0_0             0x1c  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma0_0             window 00 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND0_1             0x1d  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma0_1             window 01 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND0_2             0x1e  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma0_2             window 02 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND0_3             0x1f  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma0_3             window 03 luma accum statistics

#define ISP_RO_AEC_LUMA_WIND1_0             0x20  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma1_0             window 10 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND1_1             0x21  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma1_1             window 11 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND1_2             0x22  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma1_2             window 12 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND1_3             0x23  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma1_3             window 13 luma accum statistics 

#define ISP_RO_AEC_LUMA_WIND2_0             0x24  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma2_0             window 20 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND2_1             0x25  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma2_1             window 21 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND2_2             0x26  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma2_2             window 22 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND2_3             0x27  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma2_3             window 23 luma accum statistics 

#define ISP_RO_AEC_LUMA_WIND3_0             0x28  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma3_0             window 30 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND3_1             0x29  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma3_1             window 31 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND3_2             0x2a  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma3_2             window 32 luma accum statistics 
#define ISP_RO_AEC_LUMA_WIND3_3             0x2b  //read-only register, update each v-blank
//Bit 31: 0, ro_isp_aec_luma3_3             window 33 luma accum statistics 

#define ISP_RO_AECRAW_NUM_RED               0x2c  //read-only register, update each v-blank
//Bit 31:26, reserved                       
//Bit 25: 0, ro_isp_aecraw_num_r            red bright pixels numbers in raw window    

#define ISP_RO_AECRAW_NUM_GREEN             0x2d  //read-only register, update each v-blank
//Bit 31:26, reserved                       
//Bit 25: 0, ro_isp_aecraw_num_g            green bright pixels numbers in raw window                 
#define ISP_RO_AECRAW_NUM_BLUE              0x2e  //read-only register, update each v-blank
//Bit 31:26, reserved                       
//Bit 25: 0, ro_isp_aecraw_num_b            blue bright pixels numbers in raw window   

//===================================afc readonly====================================================
 
#define ISP_RO_AFC_WIND0_F0                 0x2f  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind0_f0            f0 accum within window 0. the larger the better focus lock. 
#define ISP_RO_AFC_WIND0_F1                 0x30  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind0_f1            f1 accum within window 0. the larger the better focus lock. 

#define ISP_RO_AFC_WIND1_F0                 0x31  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind1_f0            f0 accum within window 1. the larger the better focus lock. 
#define ISP_RO_AFC_WIND1_F1                 0x32  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind1_f1            f1 accum within window 1. the larger the better focus lock.

#define ISP_RO_AFC_WIND2_F0                 0x33  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind2_f0            f0 accum within window 2. the larger the better focus lock. 
#define ISP_RO_AFC_WIND2_F1                 0x34  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind2_f1            f1 accum within window 2. the larger the better focus lock. 

#define ISP_RO_AFC_WIND3_F0                 0x35  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind3_f0            f0 accum within window 3. the larger the better focus lock. 
#define ISP_RO_AFC_WIND3_F1                 0x36  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind3_f1            f1 accum within window 3. the larger the better focus lock. 

#define ISP_RO_AFC_WIND4_F0                 0x37  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind4_f0            f0 accum within window 4. the larger the better focus lock. 
#define ISP_RO_AFC_WIND4_F1                 0x38  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind4_f1            f1 accum within window 4. the larger the better focus lock. 

#define ISP_RO_AFC_WIND5_F0                 0x39  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind5_f0            f0 accum within window 5. the larger the better focus lock. 
#define ISP_RO_AFC_WIND5_F1                 0x3a  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind5_f1            f1 accum within window 5. the larger the better focus lock. 

#define ISP_RO_AFC_WIND6_F0                 0x3b  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind6_f0            f0 accum within window 6. the larger the better focus lock. 
#define ISP_RO_AFC_WIND6_F1                 0x3c  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind6_f1            f1 accum within window 6. the larger the better focus lock. 

#define ISP_RO_AFC_WIND7_F0                 0x3d  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_afc_wind7_f0            f0 accum within window 7. the larger the better focus lock. 
#define ISP_RO_AFC_WIND7_F1                 0x3e  // read-only register, update each v-blank
//Bit 31: 0, ro_isp_afc_wind7_f1            f1 accum within window 7. the larger the better focus lock. 

//=================================blnr readonly=====================================================

#define ISP_RO_BLNR_GRBG_DCSUM0             0x3f  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_dcsum0        phase 0 green chanel DC sum within stattistic window for black level statistics. 
#define ISP_RO_BLNR_GRBG_DCSUM1             0x40  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_dcsum1        phase 1 red chanel DC sum within stattistic window for black level statistics. 
#define ISP_RO_BLNR_GRBG_DCSUM2             0x41  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_dcsum2        phase 2 blue chanel DC sum within stattistic window for black level statistics. 
#define ISP_RO_BLNR_GRBG_DCSUM3             0x42  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_dcsum3        phase 2 green chanel DC sum within stattistic window for black level statistics.

#define ISP_RO_BLNR_GRBG_ACSUM0             0x43  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_acsum0        phase 0 green chanel AC sum within stattistic window for noise level statistics. 
#define ISP_RO_BLNR_GRBG_ACSUM1             0x44  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_acsum1        phase 1 red chanel AC sum within stattistic window for noise level statistics. 
#define ISP_RO_BLNR_GRBG_ACSUM2             0x45  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_acsum2        phase 2 blue chanel AC sum within stattistic window for noise level statistics. 
#define ISP_RO_BLNR_GRBG_ACSUM3             0x46  // read-only register, update each v-blank 
//Bit 31: 0, ro_isp_blnr_grbg_acsum3        phase 2 green chanel AC sum within stattistic window for noise level statistics. 

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  isp_reg.h
//
//========================================================================
//  BT656 register    (16'h2d00 - 16'h2dff)
//========================================================================
//`define 
//`define BT656_VCBUS_BASE                   8'h2f
//
// Reading file:  bt656_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// BT656 0x2d  
// ----------------------------
// -----------------------------------------------
// CBUS_BASE:  BT656_VCBUS_BASE = 0x2f
// -----------------------------------------------
#define P_BT_CTRL                                  (volatile unsigned long *)0xd010bd00
    #define BT_SOFT_RESET           31      // Soft reset
    #define BT_JPEG_START           30  
    #define BT_JPEG_IGNORE_BYTES    18     //20:18
    #define BT_JPEG_IGNORE_LAST     17
    #define BT_UPDATE_ST_SEL        16 
    #define BT_COLOR_REPEAT         15
    #define BT_VIDEO_MODE           13     // 14:13
    #define BT_AUTO_FMT             12   
    #define BT_PROG_MODE            11
    #define BT_JPEG_MODE            10
    #define BT_XCLK27_EN_BIT        9      // 1 : xclk27 is input.     0 : xclk27 is output.
    #define BT_FID_EN_BIT           8       // 1 : enable use FID port.
    #define BT_CLK27_SEL_BIT        7       // 1 : external xclk27      0 : internal clk27.
    #define BT_CLK27_PHASE_BIT      6       // 1 : no inverted          0 : inverted.
    #define BT_ACE_MODE_BIT         5       // 1 : auto cover error by hardware.
    #define BT_SLICE_MODE_BIT       4       // 1 : no ancillay flag     0 : with ancillay flag.
    #define BT_FMT_MODE_BIT         3       // 1 : ntsc                 0 : pal.
    #define BT_REF_MODE_BIT         2       // 1 : from bit stream.     0 : from ports.
    #define BT_MODE_BIT             1       // 1 : BT656 model          0 : SAA7118 mode.
    #define BT_EN_BIT               0       // 1 : enable.
#define P_BT_VBISTART                              (volatile unsigned long *)0xd010bd04
#define P_BT_VBIEND                                (volatile unsigned long *)0xd010bd08
#define P_BT_FIELDSADR                             (volatile unsigned long *)0xd010bd0c
#define P_BT_LINECTRL                              (volatile unsigned long *)0xd010bd10
#define P_BT_VIDEOSTART                            (volatile unsigned long *)0xd010bd14
#define P_BT_VIDEOEND                              (volatile unsigned long *)0xd010bd18
#define P_BT_SLICELINE0                            (volatile unsigned long *)0xd010bd1c
#define P_BT_SLICELINE1                            (volatile unsigned long *)0xd010bd20
#define P_BT_PORT_CTRL                             (volatile unsigned long *)0xd010bd24
  #define BT_HSYNC_PHASE      0
  #define BT_VSYNC_PHASE      1
  #define BT_HSYNC_PULSE      2
  #define BT_VSYNC_PULSE      3
  #define BT_FID_PHASE        4
  #define BT_FID_HSVS         5
  #define BT_IDQ_EN           6
  #define BT_IDQ_PHASE        7
  #define BT_D8B              8
  #define BT_10BTO8B          9
  #define BT_FID_DELAY       10    //12:10
  #define BT_VSYNC_DELAY     13    //
  #define BT_HSYNC_DELAY     16
#define P_BT_SWAP_CTRL                             (volatile unsigned long *)0xd010bd28
#define P_BT_ANCISADR                              (volatile unsigned long *)0xd010bd2c
#define P_BT_ANCIEADR                              (volatile unsigned long *)0xd010bd30
#define P_BT_AFIFO_CTRL                            (volatile unsigned long *)0xd010bd34
#define P_BT_601_CTRL0                             (volatile unsigned long *)0xd010bd38
#define P_BT_601_CTRL1                             (volatile unsigned long *)0xd010bd3c
#define P_BT_601_CTRL2                             (volatile unsigned long *)0xd010bd40
#define P_BT_601_CTRL3                             (volatile unsigned long *)0xd010bd44
#define P_BT_FIELD_LUMA                            (volatile unsigned long *)0xd010bd48
#define P_BT_RAW_CTRL                              (volatile unsigned long *)0xd010bd4c
#define P_BT_STATUS                                (volatile unsigned long *)0xd010bd50
#define P_BT_INT_CTRL                              (volatile unsigned long *)0xd010bd54
#define P_BT_ANCI_STATUS                           (volatile unsigned long *)0xd010bd58
#define P_BT_VLINE_STATUS                          (volatile unsigned long *)0xd010bd5c
#define P_BT_AFIFO_PTR                             (volatile unsigned long *)0xd010bd60
#define P_BT_JPEGBYTENUM                           (volatile unsigned long *)0xd010bd64
#define P_BT_ERR_CNT                               (volatile unsigned long *)0xd010bd68
#define P_BT_JPEG_STATUS0                          (volatile unsigned long *)0xd010bd6c
#define P_BT_JPEG_STATUS1                          (volatile unsigned long *)0xd010bd70
#define P_BT_LCNT_STATUS                           (volatile unsigned long *)0xd010bd74
#define P_BT_PCNT_STATUS                           (volatile unsigned long *)0xd010bd78
#define P_BT656_ADDR_END                           (volatile unsigned long *)0xd010bd7c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  bt656_reg.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vcbus_regs.h
//

#endif // C_ARC_POINTER_H

